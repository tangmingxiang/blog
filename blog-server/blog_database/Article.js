module.exports = 
[{
  "_id": "62c522877a8419b5c00608fb",
  "title": "“整洁架构”和商家前端的重构之路",
  "cover": "",
  "body": "<div class='wang-editor'><h2 style=\"text-indent: 0px; text-align: start;\">1.&nbsp;背景</h2><p style=\"text-indent: 0px; text-align: start;\">团队归属于后方业务支撑部门，组内的项目都以pc中后台应用为主。对比移动端应用，代码库比较庞大，业务逻辑也相对复杂。在持续的迭代过程中，我们发现当前的代码仓库仍然有不少可以优化的点：</p><h4 style=\"text-indent: 0px; text-align: start;\">可以减弱对ui框架的依赖</h4><p style=\"text-indent: 0px; text-align: start;\">21年前端平台决定技术栈统一迁移到React生态，后续平台的基础建设也都围绕React展开，这就使得商家使用Vue生态做开发的系统面临技术栈迁移的难题，将业务逻辑和UI框架节藕变得异常重要。</p><h4 style=\"text-indent: 0px; text-align: start;\">代码风格可以更加统一</h4><p style=\"text-indent: 0px; text-align: start;\">随着代码量和团队成员的增加，应用里风格迥异的代码也越来越多。为了能够持续迅速的进行迭代，团队急需一套统一的顶层代码架构设计方案。</p><h4 style=\"text-indent: 0px; text-align: start;\">可以集成自动化测试用例</h4><p style=\"text-indent: 0px; text-align: start;\">随着业务变得越来越复杂，在迅速的迭代过程中团队需要频繁地对功能进行回归，因此我们对于自动化单测用例的诉求也变的越来越强烈。</p><p style=\"text-indent: 0px; text-align: start;\">为了完成以上的优化，四组对现有的应用架构做了一次重构，而重构的核心就是整洁架构。</p><h2 style=\"text-indent: 0px; text-align: start;\">2.&nbsp;整洁架构(The&nbsp;Clean&nbsp;Architecture)</h2><p style=\"text-indent: 0px; text-align: start;\">整洁架构(The&nbsp;clean&nbsp;architecture)是由&nbsp;Robert&nbsp;C.&nbsp;Martin&nbsp;(Uncle&nbsp;Bob)在2012年提出的一套代码组织的理念，其核心主要是依据各部分代码作用的不同将其拆分成不同的层次，在各层次间制定了明确的依赖原则，以达到以下目的：</p><ol style=\"text-indent: 0px; text-align: start;\"><li>与框架无关：无论是前端代码还是服务端代码，其逻辑本身都应该是独立的，不应该依赖于某一个第三方框架或工具库。一套独立的代码可以把第三方框架等作为工具使用。</li><li>可测试：代码中的业务逻辑可以在不依赖ui、数据库、服务器的情况下进行测试。</li><li>和ui无关：代码中的业务逻辑不应该和ui做强绑定。比如把一个web应用切换成桌面应用，业务逻辑不应该受到影响。</li><li>和数据库无关：无论数据库用的是mysql还是mongodb，无论其怎么变，都不该影响到业务逻辑。</li><li>和外部服务无关：无论外部服务怎么变，都不影响到使用该服务的业务逻辑。</li></ol><p><img src=\"https://image-static.segmentfault.com/326/260/3262603032-62c3f50a0bedd_fix732\" alt=\"\" data-href=\"\" style=\"\"/></p><p style=\"text-indent: 0px; text-align: start;\">为了实现以上目的，整洁架构把应用划分成了entities、use&nbsp;cases、interface&nbsp;adapters(MVC、MVP等)、Web/DB等至少四层。这套架构除了分层之外，在层与层之间还有一个非常明确的依赖关系，外层的逻辑依赖内层的逻辑。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>Entity</strong><br>entities封装了企业级的业务逻辑和规则。entities没有什么固定的形式，无论是一个对象也好，是一堆函数的集合也好，唯一的标准就是能够被企业的各个应用所复用。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>Use&nbsp;Case</strong><br>entities封装了企业里最通用的一部分逻辑，而应用各自的业务逻辑就都封装在use&nbsp;case里面。日常开发中最常见的对于某个模型的crud操作就属于usecase这一层。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>Interface&nbsp;Adapter</strong><br>这一层类似于胶水层，需要负责内圈的entity和use&nbsp;case同外圈的external&nbsp;interfaces之间的数据转化。需要把外层服务的数据转化成内层entity和usecase可以消费的数据，反之亦然。如上面图上画的，这一层有时候可能很简单(一个转化函数)，&nbsp;有时候可能复杂到包含一整个MVC/MVP的架构。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>External&nbsp;Interfaces</strong><br>我们需要依赖的外部服务，第三方框架，以及需要糊的页面UI都归属在这一层。这一层完全不感知内圈的任何逻辑，所以无论这一层怎么变(ui变化)，都不应该影响到内圈的应用层逻辑(usecase)和企业级逻辑(entity)。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>依赖原则</strong><br>在整洁架构的原始设计中，并不是强制一定只能写这么四层，根据业务的需要还可以拆分的更细。不过无论怎么拆，都需要遵守前面提到的从外至内的依赖原则。即entity作为企业级的通用逻辑，不能依赖任何模块。而外层的ui等则可以使用usecase、entity。</p><h2 style=\"text-indent: 0px; text-align: start;\">3.&nbsp;重构</h2><p style=\"text-indent: 0px; text-align: start;\">前面介绍了当前代码库目前的一些具体问题，而整洁架构的理念正好可以帮助我们优化代码可维护性。</p><p style=\"text-indent: 0px; text-align: start;\">作为前端，我们的业务逻辑不应该依赖视图层(ui框架及其生态)，同时应当保证业务逻辑的独立性和可复用性(usecase&nbsp;&amp;&nbsp;entity)。最后，作为数据驱动的端应用，要保证应用视图渲染和业务逻辑等不受数据变动的影响(adapter&nbsp;&amp;&nbsp;entity)。</p><h2 style=\"text-indent: 0px; text-align: start;\">4.后续</h2><p style=\"text-indent: 0px; text-align: start;\">通过整洁架构我们形成了统一的编码规范，在前端应用标准化的道路上迈下了坚实的一步。可以预见的是整个标准化的过程会非常漫长，我们会陆续往标准中增加新的规范使其更加完善，短期内在规划中的有：</p><ul style=\"text-indent: 0px; text-align: start;\"><li>单测即文档：上面提到了usecase通过依赖倒置来配合单测落地，后续团队期望将一些业务逻辑的实现细则通过单测的描述来进行沉淀，解决业务文档实时性的问题。</li><li>完善监控体系：前端常遇到的3种异常包括&nbsp;代码逻辑异常、性能瓶颈(渲染卡顿、内存不足等)、数据导致异常。对于数据异常，我们可以在entity层映射的过程中加入对异常数据的埋点上报来填补目前监控的空白。（代码逻辑异常通过sentry已经监控，性能监控对于中后台应用不需要）</li></ul><p style=\"text-indent: 0px; text-align: start;\">后续在标准逐渐稳定之后，我们也期望基于稳定的规范进行一些工程化的实践(比如根据mooncake文档自动生成adapter层、基于usecase实现功能开关等)，敬请期待。</p></div>",
  "hit_num": 121,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31b"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c57b694edbe750448490c3",
  "title": "Web 应用实时版本检测，这么做最方便",
  "cover": "",
  "body": "<div class='wang-editor'><p style=\"text-indent: 0px; text-align: start;\">一个用于&nbsp;web&nbsp;应用检测版本更新的小工具。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>经常会发生这样的情况:</strong>&nbsp;当用户在浏览器中打开某&nbsp;web&nbsp;应用较长时间且未刷新页面,&nbsp;在应用有新版本更新或问题修复时,&nbsp;用户会无法及时知晓有新版发布,&nbsp;导致用户继续使用旧的版本,&nbsp;影响用户体验和后端数据准确性。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>在团队合作中可能会有这样的情况</strong>:&nbsp;你作为前端工程师,&nbsp;在联调测试或部署上线时,&nbsp;每次部署后都需要跟团队成员口头传达已经部署成功,&nbsp;增加了沟通成本,&nbsp;不够自动化,&nbsp;也没有部署记录以有迹可循。</p><p style=\"text-indent: 0px; text-align: start;\">使用&nbsp;<strong>version-rocket</strong>&nbsp;可以帮你解决以上困扰。</p><h3 style=\"text-indent: 0px; text-align: start;\">简介</h3><p style=\"text-indent: 0px; text-align: start;\"><strong>version-rocket</strong>&nbsp;将用户当前浏览器中的版本与远程服务器中的版本文件进行比较。</p><p style=\"text-indent: 0px; text-align: start;\">如果有新的版本发布，将在页面中展示一个新版本更新提示弹窗，用户可以通过点击刷新按钮来更新版本。另外，<strong>version-rocket</strong>&nbsp;也可传入一个回调函数来自定义版本更新提示界面。</p><p style=\"text-indent: 0px; text-align: start;\">我们使用基于javascript的&nbsp;<strong>Web&nbsp;Worker&nbsp;API</strong>&nbsp;来做监测轮询，不会影响浏览器渲染进程。</p><hr/><p style=\"text-indent: 0px; text-align: start;\">另外,&nbsp;如果你所在的团队,&nbsp;使用&nbsp;Lark&nbsp;或&nbsp;飞书来团队协作,&nbsp;<strong>version-rocket</strong>&nbsp;可以帮你推送“部署成功”的消息到&nbsp;Lark&nbsp;群聊中&nbsp;(通过&nbsp;Lark&nbsp;机器人)。&nbsp;使用方法非常快捷简单,&nbsp;使用方法见下文。</p><p style=\"text-indent: 0px; text-align: start;\"><em>如果有其他平台的推送需求,&nbsp;可以提&nbsp;issue</em></p><p style=\"text-indent: 0px; text-align: start;\"><strong>觉得有用，欢迎来点个&nbsp;🌟，https://github.com/guMcrey/version-rocket</strong></p><h3 style=\"text-indent: 0px; text-align: start;\">功能特点</h3><ul style=\"text-indent: 0px; text-align: start;\"><li>支持所有现代浏览器</li><li>可用版本实时监测</li><li>部署成功后，将部署消息同步到&nbsp;Lark&nbsp;群聊</li><li>版本提示界面支持自定义，部署信息卡片的内容也可以自定义</li><li><a href=\"https://link.segmentfault.com/?enc=RuT1ZQ0Nue6UWU%2FhMF2iXw%3D%3D.xkM1Q2WNopdyLjtN3Ze9PBlyJaq95idRfOIkzLQi5BwcnULzlSJbe2LpZTIwaGwK\" target=\"_blank\">支持&nbsp;Npm&nbsp;安装</a></li></ul><h3 style=\"text-indent: 0px; text-align: start;\">效果截图</h3><ul style=\"text-indent: 0px; text-align: start;\"><li><strong>第一张图:</strong>&nbsp;当有新版本更新时,&nbsp;及时提醒用户刷新页面的功能弹窗。</li><li><strong>第二张图:</strong>&nbsp;在项目成功部署后，部署信息将被发送到群聊，以通知团队成员,&nbsp;卡片文案通过一个&nbsp;json&nbsp;文件来配置,&nbsp;请参见下文。</li><li><strong>第三张图:</strong>&nbsp;基于第二张图片的可选设置,&nbsp;可以配置是否要@全员,&nbsp;设置后所有人会收到提示。</li><li></li></ul></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31b"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c57d2f4edbe750448490d7",
  "title": "智慧能源一体化管控平台",
  "cover": "",
  "body": "<div class='wang-editor'><h3 style=\"text-indent: 0px; text-align: start;\"><strong>前言</strong></h3><p style=\"text-indent: 0px; text-align: start;\">十四五规划提出：“加快推动数字产业化，培育壮大人工智能、大数据、区块链、云计算、网络安全等新兴数字产业”。2022&nbsp;年一季度，国家能源局认真贯彻落实“四个革命、一个合作”的能源安全新战略，锚定碳达峰碳中和目标，积极落实“十四五”可再生能源发展规划，推进大型风电光伏基地等重大项目建设，促使全国可再生能源发电量达&nbsp;5336&nbsp;亿千瓦时。</p><p style=\"text-indent: 0px; text-align: start;\">可再生能源装机量的迅速提升也为电力系统的稳定运行带来巨大压力。由于风电、光伏的输出功率受气象情况和运行环境影响较大，致使电站输出功率难以预测，亟需智慧电力一体化管控平台进行监管，以保障电网的平稳运行。运用图扑软件自主研发引擎&nbsp;HT&nbsp;for&nbsp;Web，构建可交互式的&nbsp;Web&nbsp;三维电力场景，实现全国新能源设施的有效管控，保障电力系统的运行通畅。</p><h3 style=\"text-indent: 0px; text-align: start;\"><strong>系统分析</strong></h3><h4 style=\"text-indent: 0px; text-align: start;\"><strong>绿色智慧电网系统</strong></h4><p style=\"text-indent: 0px; text-align: start;\">为推进新能源建设和消纳，《电力可靠性管理办法（暂行）》提出新能源发电企业要加强发电功率预测管理，建立新型储能建设需求发布机制，积极稳妥推动发电侧储能建设，推进源网荷储一体化和多能互补。“十三五”期间，我国常规发电机组的等效可用系数保持在&nbsp;91%&nbsp;以上，变压器、断路器、架空送电线路等输变电设备等效可用系数长期保持&nbsp;99%&nbsp;以上，直流输电系统运行总体稳定。</p><p style=\"text-indent: 0px; text-align: start;\"><img src=\"https://image-static.segmentfault.com/294/122/2941221038-62c3b510ebbc4\" alt=\"\" data-href=\"\" style=\"width: 100%;\">图扑软件双高绿色智慧电网系统以首个国内最高电压等级特高压交流示范工程为依据，以动态流光线条展示电流的输送。它是我国自主研发、设计和建设的具有自主知识产权的&nbsp;1000&nbsp;千伏交流输变电工程——晋东南—南阳—荆门特高压交流试验示范工程，全长&nbsp;640&nbsp;公里。</p><p style=\"text-indent: 0px; text-align: start;\">通过与&nbsp;HT&nbsp;for&nbsp;Web&nbsp;GIS&nbsp;产品的结合，实现智慧电网的精细化管理。支持对不同地图瓦片服务或数据、航拍倾斜摄影实景的&nbsp;3DTiles&nbsp;格式数据以及城市建筑群等不同的&nbsp;GIS&nbsp;数据的加载，同时，结合&nbsp;BIM&nbsp;数据轻量化、三维视频融合以及&nbsp;2D&nbsp;和&nbsp;3D&nbsp;的无缝融合等技术优势，在&nbsp;GIS&nbsp;系统中对海量的&nbsp;POI&nbsp;数据、交通流量数据、规划数据，现状数据等进行多样化的可视化展示。</p><h3 style=\"text-indent: 0px; text-align: start;\"><img src=\"https://image-static.segmentfault.com/326/060/3260603551-62c3b580a4e69\" alt=\"\" data-href=\"\" style=\"width: 100%;\"><strong>总结</strong></h3><p style=\"text-indent: 0px; text-align: start;\">2021&nbsp;年水电、风电、光伏发电平均利用率分别约达&nbsp;98%、97%和&nbsp;98%，能源技术创新能力进一步增强。建立了完备的水电、核电、风电、太阳能发电等清洁能源装备制造产业链，成功研发制造全球最大单机容量&nbsp;100&nbsp;万千瓦水电机组，具备最大单机容量达&nbsp;10&nbsp;兆瓦的全系列风电机组制造能力，不断刷新光伏电池转换效率世界纪录。</p><p style=\"text-indent: 0px; text-align: start;\">图扑软件提供&nbsp;Web&nbsp;端的&nbsp;UI/2D/3D、GIS、BIM&nbsp;及&nbsp;VR/AR&nbsp;等可视化相关解决方案，自研核心引擎&nbsp;HT&nbsp;提供图形化组态&nbsp;SCADA&nbsp;能力，支持构建零代码物联网&nbsp;IoT&nbsp;平台，共同构建工业元宇宙，普遍应用于智慧城市、智慧水务、光伏、风电、新基建、智慧医疗、智能制造等各行业的数字孪生、二维组态和三维组态项目。</p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31b"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c57e244edbe750448490e9",
  "title": "揭秘得物客服IM全链路通信过程",
  "cover": "",
  "body": "<div class='wang-editor'><p style=\"text-indent: 0px; text-align: start;\">先来看下客服会话和对接系统的整体架构图，如下所示：</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><ul style=\"text-indent: 0px; text-align: start;\"><li><strong>访客端：</strong>&nbsp;用户触达端（c端），主要三个功能：人工会话、满意度评价、机器人会话</li><li><strong>客服端：</strong>&nbsp;主要的对接平台有：章鱼一站式工作台（人工会话聊天）、机器人管理后台（机器人对话相关）、工单工作台（与人工会话紧密相连）、在线客服工作台（为人工会话服务）。</li></ul><p style=\"text-indent: 0px; text-align: start;\">想要客服能够接线到用户，并且能准确的分配给指定的客服，我们开发了在线客服工作台，经过了服务时间设置，人机交互，进线分配，排队溢出会话流程设置一系列规则。</p><h2 style=\"text-indent: 0px; text-align: start;\"><strong>1.&nbsp;先从服务时间设置说起</strong></h2><h3 style=\"text-indent: 0px; text-align: start;\"><strong>1.1&nbsp;得物客服服务时间</strong></h3><p style=\"text-indent: 0px; text-align: start;\">首先有：得物常规服务时间，只有在限制的服务区间内，可以进行人工会话咨询，超出常规服务时间的咨询可以进行机器人问答或者留言，人工客服上线后可以进行响应的解答。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>常规服务时间：</strong>&nbsp;工作日和周末早上八点到次日凌晨</p><p style=\"text-indent: 0px; text-align: start;\"><strong>非常规服务时间：</strong>&nbsp;当然除了常规时间还有特殊服务时间设置，比如双十一、618等大促期间的用户流量增加，订单量增加在某一个时间段内服务时间需要提前或者延长时进行特殊设置。符合特殊时间进线时间的情况也可以正常进线到人工客服。</p><h2 style=\"text-indent: 0px; text-align: start;\"><strong>2.&nbsp;分流规则</strong></h2><p style=\"text-indent: 0px; text-align: start;\">正如有网购经验进行过客服咨询的大家所知道的，想要咨询的问题有<strong>下单前</strong>的疑问，<strong>下单后</strong>的疑问，对<strong>物流进度</strong>的疑问，对<strong>到货商品</strong>尺码颜色等问题的咨询。</p><p style=\"text-indent: 0px; text-align: start;\">不仅这些，还有买不同的商品时候产生的针对性的问题比如：<strong>鞋类，化妆品，服装，包包手表，</strong>&nbsp;<strong>3C</strong>类等等。这些问题都需要专业的客服进行解答，那就不能随便分配一个客服去接线，所以<strong>在用户进线咨询之前要先进线分流规则的匹配</strong>，这是一个复杂的逻辑。</p><p style=\"text-indent: 0px; text-align: start;\">用户有从不同渠道来的，从配置维度先按渠道做一个区分：</p><ul style=\"text-indent: 0px; text-align: start;\"><li>得物有哪些进线渠道？</li></ul><p style=\"text-indent: 0px; text-align: start;\">目前得物的进线渠道有多个，包括得物App和小程序等等。</p><ul style=\"text-indent: 0px; text-align: start;\"><li>根据渠道如何做进线分配？</li></ul><p style=\"text-indent: 0px; text-align: start;\">举例说明：比如从得物App的商品详情页进线客服</p><p style=\"text-indent: 0px; text-align: start;\">根据<strong>渠道</strong>（得物App）+<strong>来源</strong>（商品详情）+<strong>分流维度</strong>&nbsp;+<strong>分配方式</strong>&nbsp;可以分配到指定的客服组。（分流维度可以设置机器人优先规则）</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><h2 style=\"text-indent: 0px; text-align: start;\"><strong>3.&nbsp;排队溢出规则</strong></h2><p style=\"text-indent: 0px; text-align: start;\">如上所说符合了进线时间，又满足了渠道来源分配终于要进线到人工聊天了，但是来的稍微晚了一步，假设只有10个客服，每个客服的同时接线量是10，刚好你是第101个怎么办了。一不小心就触发了排队规则。</p><h3 style=\"text-indent: 0px; text-align: start;\"><strong>3.1&nbsp;排队流程</strong></h3><p style=\"text-indent: 0px; text-align: start;\">为了避免客服接线到已经离开等待的排队用户，首先要判断用户是否在客服页面，不在线的情况给用户push&nbsp;排队即将结束的提示，在线的情况正常进入排队进线流程。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">App端排队进线示意图：</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><h3 style=\"text-indent: 0px; text-align: start;\"><strong>3.2&nbsp;溢出留言</strong></h3><p style=\"text-indent: 0px; text-align: start;\">客服业务高峰大量咨询排队的时候，会出现排队量不均衡，无法调控。为了确保各组排队量、用户等待时长均衡，通过溢出规则，合理调配人工客服资源。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><h3 style=\"text-indent: 0px; text-align: start;\"><strong>3.3实时数据监控</strong></h3><p style=\"text-indent: 0px; text-align: start;\">在监控大屏有监控数据保留排队人次，来回进出保留队列只计算一次，但是如果用户多次进线发生多次排队，则计算多次。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>实时数据：</strong>&nbsp;为当日数据。根据所选客服组查看不同队列的保留排队人次</p><p style=\"text-indent: 0px; text-align: start;\">根据监控正在<strong>排队人数</strong>和<strong>排队时长</strong>判断用户行为和客服接线能力是否符合当前用户数量</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><h2 style=\"text-indent: 0px; text-align: start;\"><strong>4.&nbsp;进线人工客服</strong></h2><p style=\"text-indent: 0px; text-align: start;\">经过前面一系列的规则匹配进线分配，终于来到了人工会话，到了人工客服聊天的阶段，客户和我们的客服是怎么进行聊天交互的呢？用过得物App的且咨询过人工客服的同学应该都知道客户端的使用情况那么客服是怎么接线怎么跟用户沟通的呢？前后我们开发了两代系统。</p><h3 style=\"text-indent: 0px; text-align: start;\"><strong>4.1&nbsp;在线客服系统</strong></h3><p style=\"text-indent: 0px; text-align: start;\">这个系统是IM客服系统的第一代系统，功能不仅包括在线聊天，聊天相关的配置用户管理都这里统一管理。</p><h3 style=\"text-indent: 0px; text-align: start;\"><strong>4.2&nbsp;章鱼一站式工作台</strong></h3><p style=\"text-indent: 0px; text-align: start;\">也就是现在客服使用的一站式工作台。因为客服聊天不仅要准确快速，还有复杂的会话切换信息缓存等等&nbsp;和配置相关放在一起会影响客服的使用，进而开发了章鱼一站式工作台，专供客服接线相关的功能使用。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>三栏布局的形式：</strong></p><p style=\"text-indent: 0px; text-align: start;\"><strong>左侧区域：</strong>&nbsp;在线、离线、留言用户列表</p><ul style=\"text-indent: 0px; text-align: start;\"><li><strong>中间聊天区域：</strong>&nbsp;会话内容，客服聊天区域，包括表情、图片视频邀评等等发送的功能</li><li><strong>右侧区域：</strong>&nbsp;用户相关的信息功能区，包括用户信息、得物先知、订单查询、<strong>创建工单</strong>(工单数据会同步在<strong>工单系统</strong>便于对工单专门处理)，商品推荐。</li></ul><h4 style=\"text-indent: 0px; text-align: start;\"><strong>4.2.1&nbsp;数据的触达双端的过程</strong></h4><p style=\"text-indent: 0px; text-align: start;\">数据主要包括了普通文本消息、富文本、图片、视频、文件等等。<strong>保证消息能准确的实时的送达到客服和客户端长链接是一个不错的选择</strong>&nbsp;<strong>，</strong>&nbsp;这些数据<strong>先到后端-后端推给</strong>&nbsp;<strong>网关</strong>&nbsp;<strong>-网关通过长链推送到</strong>&nbsp;<strong>章鱼工作台</strong>，当前长链接可用的情况下，每一次请求都只是简单的数据发送和接受。</p><p style=\"text-indent: 0px; text-align: start;\">说到这里，大家可能会有疑问，<strong>如果发送消息过程中出现了</strong>&nbsp;<strong>网络</strong>&nbsp;<strong>抖动等问题导致问题无法触达怎么办？</strong></p><p style=\"text-indent: 0px; text-align: start;\">目前客服系统用的<strong>ACK三次重连</strong>机制，在一定时间内如果没有收到网关的返回会进行重试，进行三次重连确保在有偶发的意外网络等状况时消息能够发送成功。同时为了避免持续重试，大面积重试造成网络堵塞三次尝试之后依然失败的会显示发送失败。消息不落库。</p><h4 style=\"text-indent: 0px; text-align: start;\"><strong>4.2.2</strong>&nbsp;<strong>坐席辅助能力SOP</strong></h4><p style=\"text-indent: 0px; text-align: start;\">SOP，是&nbsp;\"Standard&nbsp;Operating&nbsp;Procedure\"&nbsp;三个单词中首字母的大写&nbsp;，即标准作业程序，指将某一事件的标准操作步骤和要求以统一的格式描述出来，用于指导和规范日常的工作。</p><p style=\"text-indent: 0px; text-align: start;\">针对聊天的过程，有很多重复的问题，客服是如何更快地去解决用户的问题？早期得物沉淀和完善了很多客服须知的知识文档，其中900+个问题是需要掌握的。为了提高客服侧服务效率，继而延伸出坐席辅助工具。</p><p style=\"text-indent: 0px; text-align: start;\">根据聊天中信息内容自动匹配相应的知识内容，再由客服根据匹配内容决定否符合当前聊天场景，符合则发送给用户即可。把尽可能多的流程化、客服频繁关注的业务逻辑收纳到以sop为基础的“智能客服坐席助手”，提供一个统一的一站式查询、决策、操作入口（工具），简化客服操作提高客服接待效率。</p><h2 style=\"text-indent: 0px; text-align: start;\"><strong>5.&nbsp;结束会话</strong></h2><h3 style=\"text-indent: 0px; text-align: start;\"><strong>5.1&nbsp;会话过程有几个阶段</strong></h3><p style=\"text-indent: 0px; text-align: start;\"><br></p><h3 style=\"text-indent: 0px; text-align: start;\"><strong>5.2&nbsp;会话关闭</strong></h3><p style=\"text-indent: 0px; text-align: start;\"><strong>会话关闭有几种途径</strong></p><ul style=\"text-indent: 0px; text-align: start;\"><li>当客服回复了用户之后&nbsp;在一定的时间内没有收到用户的消息，会先进行会话结束倒计时，并且push会话会在XX之后结束的提示语。在倒计时结束之前用户没有回复，触发默认关闭会话逻辑，推送结束语，会话关闭。</li><li>在确认用户疑问已经得到解答，不再有问题咨询时，push结束语，会话结束。</li><li>用户已得到解答，不再有问题咨询主动结束会话。</li></ul><h3 style=\"text-indent: 0px; text-align: start;\"><strong>5.3&nbsp;邀评</strong></h3><p style=\"text-indent: 0px; text-align: start;\">结束会话前，客服可以发送邀评调研<strong>用户</strong>&nbsp;<strong>满意度</strong>，会话结束后如果没有进行过邀评的情况下，系统会自动推送邀评。在会话的阶段用户也可以主动发起评价对此次会话的满意度做一个反馈。<strong>为了不过度邀评，让用户</strong>&nbsp;<strong>体验</strong>&nbsp;<strong>降低，一个会话只有一次邀评机会</strong>，不管用户有没有评价都不再推送邀评信息。</p><h2 style=\"text-indent: 0px; text-align: start;\"><strong>6.&nbsp;总结</strong></h2><p style=\"text-indent: 0px; text-align: start;\">客服的演进从开始的初始的平台到现在的成熟系统，在整个得物客服组成员的共同努力下，一步步的不断完善优化才有了在巨多会话量压力下，仍然稳定好用的系统。</p><p style=\"text-indent: 0px; text-align: start;\">以上所述的是得物IM通信链路中的一些主要内容的概览，读到这里已经对客服的运作环境和流程有一个初步的了解。除了这些内容以外还有很多细节的技术性的内容，欢迎留言交流讨论。</p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31b"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c55c587a8419b5c0061465",
  "title": "Vue 3是一个错误，我们不应该再犯",
  "cover": "",
  "body": "<div class='wang-editor'><p style=\"text-indent: 2em; text-align: start;\">文本是翻译的，作者Fotis&nbsp;Adamakis，&nbsp;他是&nbsp;Vue.js雅典会议的共同组织者，文中的第一人称指的是该大佬。</p><p style=\"text-indent: 2em; text-align: start;\">从最初引入Vue&nbsp;3开始，已经过去了4年多。<a href=\"https://link.segmentfault.com/?enc=cHabYq2HAz3M1NMfbumyVQ%3D%3D.EJvgMe7DGeJlgsDFIkNBoPENwxQznFV73nhNlHidxiKhcqhfGupbJ3trwcHnn49MIvsax7ZJHDtexIMQtJ6a%2Fg%3D%3D\" target=\"_blank\">经过多次RFC</a>的讨论，以及其他现代框架（包括React和Svelte）的影响，Vue&nbsp;可能已经成为最强大和最全面的框架，能够逐步支持任何规模和架构的应用。</p><p style=\"text-indent: 2em; text-align: start;\">听起来很刺激，对吗？嗯，事实远非如此。从那时起，就发生了很多延迟和降级的情况。尽管Vue&nbsp;3最近成为了新的默认版本，但很多重要的支持库还没有准备好，甚至没有计划与两个版本兼容。这说明很多代码库还停留在Vue&nbsp;2上，迁移到版本3的路径并不容易。</p><p style=\"text-indent: 2em; text-align: start;\">请不要误解我，Vue&nbsp;3非常棒。它可能是目前最好的框架了。但事实上，从第二版开始没有简单的迁移路径，这是一个错误，我们不应该在未来重复。</p><h2 style=\"text-indent: 0px; text-align: start;\">Vue&nbsp;2的问题</h2><p style=\"text-indent: 2em; text-align: start;\">Vue一直被认为是一个进步的框架。选项API很容易理解，我们可以学习并在需要时引入更复杂的模式和库。小的学习曲线和良好的文档是大家喜欢它的原因。</p><p style=\"text-indent: 2em; text-align: start;\">另一方面，在将通用逻辑抽象为mixin时，使用继承而不是组合的体系结构缺陷造成了许多可伸缩性问题，并破坏了干净组件声明的许多原则。Vue3&nbsp;引入组合API&nbsp;作为一种解决方案。</p><p style=\"text-indent: 2em; text-align: start;\">另一个重要的问题是对typecript的支持。当然，在Vue组件中编写typescript就像在<span style=\"color: rgb(214, 51, 132);\"><code>script</code></span>标签中添加<span style=\"color: rgb(214, 51, 132);\"><code>type=\"ts\"</code></span>一样容易。但在模板和&nbsp;store&nbsp;里，支持是有问题的。</p><h2 style=\"text-indent: 0px; text-align: start;\">vue3&nbsp;解决方案</h2><p style=\"text-indent: 2em; text-align: start;\">完全重写是一个改善框架内部结构的机会。Vue3&nbsp;广泛地使用了Typescript，包括响应性机制在内的许多方面都从头开始。这使得Vue&nbsp;3在数据包大小、初始渲染、更新和内存使用方面的性能得到了明显的改善。</p><p style=\"text-align: start;\">此外，还增加了很多新的功能。</p><p style=\"text-indent: 2em;\">Composition&nbsp;API</p><p style=\"text-indent: 2em;\">语法糖&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>&lt;script&nbsp;setup&gt;</code></span></p><p style=\"text-indent: 2em;\">Fragments</p><p style=\"text-indent: 2em;\">Emits&nbsp;Component&nbsp;Option</p><p style=\"text-indent: 2em;\">来自<span style=\"color: rgb(214, 51, 132);\"><code>@vue/runtime-core</code></span>的<span style=\"color: rgb(214, 51, 132);\"><code>createRenderer</code></span>&nbsp;API可以创建自定义渲染器</p><p style=\"text-indent: 2em;\">style&nbsp;里面可以绑定变量</p><p style=\"text-indent: 2em;\">SFC的<span style=\"color: rgb(214, 51, 132);\"><code>&lt;style&nbsp;scoped&gt;</code></span>现在可以包括全局规则或只针对插槽内容的规则</p><p style=\"text-indent: 2em;\">Suspense</p><p style=\"text-indent: 2em; text-align: start;\">新功能改善了整体的开发体验，欢迎很多开发都的追捧。争论的焦点是，其中大部分功能，包括组合API、teleport、&nbsp;suspense&nbsp;等，在Vue&nbsp;2中已经都能用了，所以它们不能真正算作框架的改进。</p><p><br></p></div>",
  "hit_num": 2,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31b"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c575847a8419b5c0061647",
  "title": "大量模块壳工程本地如何快速编译？优酷 iOS 工程插件化实践",
  "cover": "http://127.0.0.1:3000/article/1657107839118.png",
  "body": "<div class='wang-editor'><p><span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255); font-size: 16px;\">随着优酷业务的快速发展，随之而来的是模块数量的爆发式增长，基本每年以大量新增模块的速度增加，到目前为止优酷已经有非常庞大的模块依赖。模块之间通信往往是相互直接依赖调用，以至于耦合十分严重且混乱，每一个库依赖都是一颗“树”，甚至于一张“网”，对日常研发造成很多困扰：</span></p><p><img src=\"https://image-static.segmentfault.com/694/163/694163613-ea5da8d9083c67cb_fix732\" alt=\"\" data-href=\"\" style=\"width: 100%;height: auto;\"/></p><h2 style=\"text-indent: 0px; text-align: start;\">插件化落地结果</h2><hr/><p style=\"text-indent: 0px; text-align: start;\">iOS模块插件化已经全面在优酷落地，沉淀出各业务线的轻量工程，大量的业务及架构插件，后续可根据不同业务需求，自由组装插件工程。以下是目前插件化工程落地后的一些收益：</p><ul style=\"text-indent: 0px; text-align: start;\"><li>直接收益业务插件工程编译效率提升&nbsp;显著，本地编译时间大幅降低，相关全部开发已使用起来；通过插件组装生成业务插件工程，插件工程支持模拟器编译调试，并支持热重载；模块工程和整包工程均使用插件作为依赖，彻底解决模块工程和整包工程依赖模块版本不一致情况，并支持依赖模块版本自动更新；业务插件工程依赖库数量大幅减少，且pod直接复用缓存，大幅提升pod成功率及速度，磁盘占用大幅减少；</li><li>间接收益可提供运行内存、app启动、功耗等插件卡口，常态化保持良好的用户体验；所有插件支持自由组装，通过配置中心，提供快速孵化极速版、国际版、Apple&nbsp;Watch、Apple&nbsp;TV等App的能力；依赖减少，swift断点调试时的module树快速生成，断点效率提升；提速打包效率，建立插件工程构建平台，测试同学使用平台动态配置生成插件组合安装包即可进行测试。</li></ul><h2 style=\"text-indent: 0px; text-align: start;\">插件是什么</h2><ul><li>插件是由一组模块聚合而成，同时也可依赖其他插件。在物理上，插件是一个文本描述文件，描述其包含的模块和插件信息；</li></ul><ul style=\"text-indent: 0px; text-align: start;\"><li>插件基于Xcode工程，可独立编译并生成App产物，支持多插件自由组合。</li></ul><p style=\"text-indent: 0px; text-align: start;\"><strong>简单插件</strong></p><p style=\"text-indent: 0px; text-align: start;\">一个简单的插件可以仅由一个模块组成</p><pre><code ># 图片库插件target 'Plugin' do       #模块A    pod '模块A','5.9.4' end</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>复杂插件</strong></p><p style=\"text-indent: 0px; text-align: start;\">一个复杂插件可以由一个或多个插件和模块组成</p><pre><code ># 插件target 'Plugin' do    # 图片库插件    plug '1.图片库插件'      #webp图片解析模块    pod '模块B','0.1.4'     #webp基础模块    pod '模块C','1.1.0.1' end</code></pre><h2 style=\"text-indent: 0px; text-align: start;\">为什么需要插件</h2><p style=\"text-indent: 0px; text-align: start;\">和多个业务团队同学沟通后，我们发现大部分的业务在功能调试时，往往只关注涉及到自己需要迭代的业务功能，对于其他业务并不关心。于是我们想到可以基于整包工程，裁剪出一个只有单业务功能的APP，这样编译速度肯定会有极大的提升。</p><p style=\"text-indent: 0px; text-align: start;\">裁剪APP需要对模块进行解耦，如果按模块颗粒度进行解耦，巨量模块进行解耦人力成本过高，而且过大的改动也会对线上稳定性有较大的影响。于是我们对解耦粒度进行了放大，从模块解耦粒度放大到以插件为粒度进行解耦，这样我们只需要解耦插件和插件之间的横向耦合关系，插件允许向下依赖其他插件，且插件内部模块也允许相互耦合，这样极大的的降低解耦的人力成本，也方便后续以插件维度进行依赖关系进行维护。</p><h2 style=\"text-indent: 0px; text-align: start;\">插件使用规范</h2><p style=\"text-indent: 0px; text-align: start;\"><strong>插件聚合原则</strong></p><ul style=\"text-indent: 0px; text-align: start;\"><li>业务插件：业务模块按业务功能维度划分边界，聚合成业务插件；</li><li>通用业务插件：通用业务模块按业务可复用最小集划分边界，聚合成通用业务插件；</li><li>架构功能插件：集团中间件模块、优酷中间件模块，按功能最小集划分边界，聚合成架构功能插件。</li></ul><p style=\"text-indent: 0px; text-align: start;\"><strong>插件依赖原则</strong></p><ul style=\"text-indent: 0px; text-align: start;\"><li>业务插件不允许横向依赖其他业务插件，允许依赖下层插件；</li><li>架构层插件不允许依赖上层插件，允许依赖下层插件及其他架构插件。</li></ul><p><img src=\"https://image-static.segmentfault.com/186/752/1867528497-5215c200b2efa35f_fix732\" alt=\"\" data-href=\"\" style=\"width: 100%;height: auto;\"/></p><p style=\"text-indent: 0px; text-align: start;\"><strong>模块归属原则</strong></p><ul style=\"text-indent: 0px; text-align: start;\"><li>一个模块仅能归属到一个插件，需要明确模块的职能；</li><li>同一个模块被多个插件依赖，需要考虑下沉该模块为插件；</li><li>一个模块可以写成一个插件。</li></ul><p style=\"text-indent: 0px; text-align: start;\"><strong>插件版本原则</strong></p><ul style=\"text-indent: 0px; text-align: start;\"><li>每个插件没有版本的概念；</li><li>一个集成区的模块和版本对应一套插件中的模块和版本；</li><li>一套插件中的模块和版本默认和线上版本的集成区一致，也可设置并同步到最新集成区或历史集成区。</li></ul><h2 style=\"text-indent: 0px; text-align: start;\">结语</h2><p style=\"text-indent: 0px; text-align: start;\">综上所述，iOS工程插件化是运用分而治之的思想，把一个复杂的App分成多个子App。通过子App可将研发聚焦于需求研发和用户体验提升上。同时，插件化的拆装特性也提高了线上可复现问题的排查效率。因此插件化对研发效率以及开发幸福感的提升都是非常有帮助的。</p></div>",
  "hit_num": 6,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31b"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c57ec74edbe75044849128",
  "title": "编程语言：类型系统的本质",
  "cover": "",
  "body": "<div class='wang-editor'><h2 style=\"text-indent: 0px; text-align: start;\">0.&nbsp;引子</h2><p style=\"text-indent: 0px; text-align: start;\">我一直对编写更好的代码有浓厚的兴趣。如果你能真正理解什么是抽象，什么是具象，就能理解为什么现代编程语言中，接口和函数类型为什么那么普遍存在了。在使用函数式语言进行编程后，就能够很清晰地理解为什么随着时间的推移，更主流的语言开始采用函数式语言中的一些被认为理所当然的特性。</p><p style=\"text-indent: 0px; text-align: start;\">我将多年间学习类型系统和编程语言开发的经验汇聚起来，加以提炼，并辅以现实世界的应用，撰写了这篇文章。本文脉络如下：</p><ol style=\"text-indent: 0px; text-align: start;\"><li>概述：什么是类型？为什么要引入类型的概念？</li><li>编程语言中的基本类型</li><li>类型组合</li><li>OOP与接口类型</li><li>函数类型</li><li>函子（Functor）和单子（Monad）</li></ol><h2 style=\"text-indent: 0px; text-align: start;\">1.&nbsp;概述：什么是类型？为什么要引入类型的概念？</h2><p style=\"text-indent: 0px; text-align: start;\">类型系统设计的理论与日常生产软件之间存在直接的联系。这并不是一个革命性的发现：复杂的类型系统特性之所以存在，就是为了解决现实世界的问题。</p><p style=\"text-indent: 0px; text-align: start;\">本节介绍类型和类型系统，讨论它们为什么存在以及为什么有用。我们将讨论类型系统的类型，并解释类型强度、静态类型和动态类型。</p><h3 style=\"text-indent: 0px; text-align: start;\">两个术语：类型、类型系统</h3><h4 style=\"text-indent: 0px; text-align: start;\">类型</h4><p style=\"text-indent: 0px; text-align: start;\">类型是对数据做的一种分类，定义了能够对数据执行的操作、数据的意义，以及允许数据接受的值的集合。编译器和运行时会检查类型，以确保数据的完整性，实施访问限制，以及按照开发人员的意图来解释数据。</p><h4 style=\"text-indent: 0px; text-align: start;\">类型系统</h4><p style=\"text-indent: 0px; text-align: start;\">类型系统是一组规则，为编程语言的元素分配和实施类型。这些元素可以是变量、函数和其他高级结构。类型系统通过两种方式分配类型：程序员在代码中指定类型，或者类型系统根据上下文，隐式推断出某个元素的类型。类型系统允许在类型之间进行某些转换，而阻止其他类型的转换。</p><h3 style=\"text-indent: 0px; text-align: start;\">从复杂系统的约束开始</h3><p style=\"text-indent: 0px; text-align: start;\">“系统”一词由来已久，在古希腊是指复杂事物的总体。到近代，一些科学家和哲学家常用系统一词来表示复杂的具有一定结构的整体。在宏观世界和微观世界，从基本粒子到宇宙，从细胞到人类社会，从动植物到社会组织，无一不是系统的存在方式。</p><p style=\"text-indent: 0px; text-align: start;\">控制论（维纳，1948，《控制论(或关于在动物和机器中控制和通讯的科学)》）告诉我们，负反馈就是系统稳定的机制，一个组织系统之所以能够受到干扰后能迅速排除偏差恢复恒定的能力，关键在于存在着“负反馈调节”机制：系统必须有一种装置，来测量受干扰的变量和维持有机体生存所必需的恒值之间的差别。&nbsp;例如，一个实时系统复杂性任务的约束，包括时间约束、资源约束、执行顺序约束和性能约束。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><blockquote style=\"text-indent: 0px; text-align: start;\">类型检查：类型检查确保程序遵守类型系统的规则。编译器在转换代码时进行类型检查，而运行时在执行代码时进行类型检查。编译器中负责实施类型规则的组件叫作类型检查器。如果类型检查失败，则意味着程序没有遵守类型系统的规则，此时程序将会编译失败，或者发生运行时错误。“遵守类型系统规则的程序相当于一个逻辑证明。”</blockquote><p style=\"text-indent: 0px; text-align: start;\">类型系统，就是复杂软件系统的“负反馈调节器”。通过一套类型规范，加上编译监控和测试机制，来实现软件系统的数据抽象和运行时数据处理的安全。</p><p style=\"text-indent: 0px; text-align: start;\">随着软件变得越来越复杂，我们越来越需要保证软件能够正确运行。通过监控和测试，能够说明在给定特定输入时，软件在特定时刻的行为是符合规定的。但类型为我们提供了更加一般性的证明，说明无论给定什么输入，代码都将按照规定运行。</p><p style=\"text-indent: 0px; text-align: start;\">例如，将一个值标记为&nbsp;const，或者将一个成员变量标记为&nbsp;private，类型检查将强制限制实施其他许多安全属性。</p><h3 style=\"text-indent: 0px; text-align: start;\">从&nbsp;01&nbsp;到现实世界对象模型</h3><blockquote style=\"text-indent: 0px; text-align: start;\">类型为数据赋予了意义。类型还限制了一个变量可以接受的有效值的集合。</blockquote><p style=\"text-indent: 0px; text-align: start;\">在低层的硬件和机器代码级别，程序逻辑（代码）及其操作的数据是用位来表示的。在这个级别，代码和数据没有区别，所以当系统误将代码当成数据，或者将数据当成代码时，就很容易发生错误。这些错误可能导致系统崩溃，也可能导致严重的安全漏洞，攻击者利用这些漏洞，让系统把他们的输入数据作为代码执行。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">通过对编程语言的研究，人们正在设计出越来越强大的类型系统（例如，Elm或Idris语言的类型系统）。Haskell正变得越来越受欢迎。同时，在动态类型语言中添加编译时类型检查的工作也在推进中：Python添加了对类型提示的支持，而TypeScript这种语言纯粹是为了在JavaScript中添加编译时类型检查而创建的。</p><p style=\"text-indent: 0px; text-align: start;\">显然，为代码添加类型是很有价值的，利用编程语言提供的类型系统的特性，可以编写出更好、更安全的代码。</p><h3 style=\"text-indent: 0px; text-align: start;\">编程语言中的数据类型</h3><p style=\"text-indent: 0px; text-align: start;\">类型系统是每个编程语言都会有的基本概念。</p><ol style=\"text-indent: 0px; text-align: start;\"><li>Lisp&nbsp;数据类型可分类为：</li><li>标量类型&nbsp;-&nbsp;例如，数字类型，字符，符号等。<br>-数据结构&nbsp;-&nbsp;例如，列表，向量，比特向量和字符串。</li><li>C&nbsp;语言的类型系统分为：基本类型和复合类型。基本类型又可以细分为：整型数值类型和浮点数数值类型，不同类型所占用的内存长度不相同：</li></ol><p style=\"text-indent: 0px; text-align: start;\">整型数值基本类型</p><blockquote style=\"text-indent: 0px; text-align: start;\">char&nbsp;占用一个字节<br>short&nbsp;占用两个字节<br>int&nbsp;目前基本都是4字节<br>long&nbsp;int&nbsp;(可以简写为&nbsp;long)&nbsp;(32位系统是4字节，64位系统是8字节)<br>long&nbsp;long&nbsp;int&nbsp;(&nbsp;可以简写为long&nbsp;long)&nbsp;占用8节字</blockquote><p style=\"text-indent: 0px; text-align: start;\">浮点数数值基本类型</p><blockquote style=\"text-indent: 0px; text-align: start;\">float&nbsp;占用4字节&nbsp;(单精度)<br>double&nbsp;占用8节字&nbsp;(双精度浮点数)</blockquote><p style=\"text-indent: 0px; text-align: start;\">复合类型包含如下几种</p><blockquote style=\"text-indent: 0px; text-align: start;\">struct&nbsp;结构体<br>union&nbsp;联合体<br>enum&nbsp;枚举&nbsp;(长度等同&nbsp;int&nbsp;)<br>数组<br>指针</blockquote><ol style=\"text-indent: 0px; text-align: start;\"><li>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组，切片（slice），结构体（struct），接口（interface），函数（func），map&nbsp;,&nbsp;通道（channel）等。</li><li>整型：int8&nbsp;int6&nbsp;int32&nbsp;int64；对应的无符号整型：uint8&nbsp;uint16&nbsp;uint32&nbsp;uint64。uint8&nbsp;就是我们熟知的&nbsp;byte&nbsp;型,int16对应C语言中的short型，int64&nbsp;对应C语言中&nbsp;long&nbsp;型。</li><li>浮点类型：float32和&nbsp;float64,&nbsp;浮点这两种浮点型数据格式遵循&nbsp;IEEE&nbsp;754标准。</li><li>切片：可变数组，是对数组的一种抽象。切片是引用类型。</li><li>接口：&nbsp;实现多态，面向接口编程。定义一个接口&nbsp;I&nbsp;,&nbsp;然后使用不同的结构体对接口&nbsp;I&nbsp;进行实现,然后利用接口对象作为形式参数,将不同类型的对象传入并调用相关的函数,实现多态。接口可以进行嵌套实现,通过大接口包含小接口。</li></ol><h3 style=\"text-indent: 0px; text-align: start;\">类型强度</h3><p style=\"text-indent: 0px; text-align: start;\">强类型和弱类型的区别没有权威的定义。大多数早期关于强类型和弱类型的讨论可以概括为静态类型和动态类型之间的区别。</p><p style=\"text-indent: 0px; text-align: start;\">但流行的说法是强类型倾向于不容忍隐式类型转换，而弱类型倾向于容忍隐式类型转换。这样，强类型语言通常是类型安全的，也就是说，它只能以允许的方式访问它被授权访问的内存。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">通常，动态类型语言倾向于与&nbsp;Python、Ruby、Perl&nbsp;或&nbsp;Javascript&nbsp;等解释型语言相关联，而静态类型语言倾向于编译型语言，例如&nbsp;Golang、Java&nbsp;或&nbsp;C。</p><p style=\"text-indent: 0px; text-align: start;\">我总结了一个常见编程语言类型的分类图，注意拆分的四个区域是分区，比如PHP和JS都是动态弱类型。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><h3 style=\"text-indent: 0px; text-align: start;\">静态类型与动态类型</h3><p style=\"text-indent: 0px; text-align: start;\">我们经常听到“静态与动态类型”这个问题，其实，两者的区别在于类型检查发生的时间。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><ol style=\"text-indent: 0px; text-align: start;\"><li>静态类型系统在编译时确定所有变量的类型，并在使用不正确的情况下抛出异常。静态类型系统，将运行时错误转换成编译时错误，能够使代码更容易维护、适应性更强，对于大型应用程序，尤其如此。</li><li>而在动态类型中，类型绑定到值。检查是在运行时进行的。动态类型系统在运行时确定变量类型，如果有错误则抛出异常，如果没有适当的处理，可能会导致程序崩溃。动态类型不会在编译时施加任何类型约束。日常交流中有时会将动态类型叫作“鸭子类型”（duck&nbsp;typing），这个名称来自俗语：“如果一种动物走起来像鸭子，叫起来像鸭子，那么它就是一只鸭子。”代码可按照需要自由使用一个变量，运行时将对变量应用类型。</li></ol><p style=\"text-indent: 0px; text-align: start;\">静态类型系统的早期类型错误报告保证了大规模应用程序开发的安全性，而动态类型系统的缺点是编译时没有类型检查，程序不够安全。只有大量的单元测试才能保证代码的健壮性。但是使用动态类型系统的程序，很容易编写并且不需要花费很多时间来确保类型正确。所谓“鱼和熊掌不可兼得”，这就是关于“效率”与“质量”的哲学问题了。</p><p style=\"text-indent: 0px; text-align: start;\">不过，现代类型检查器具有强大的类型推断算法，使它们能够确定变量或者函数的类型，而不需要我们显式地写出类型。</p><h3 style=\"text-indent: 0px; text-align: start;\">小结</h3><ul style=\"text-indent: 0px; text-align: start;\"><li>类型是一种数据分类，定义了可以对这类数据执行的操作、这类数据的意义以及允许取值的集合。</li><li>类型系统是一组规则，为编程语言的元素分配并实施类型。</li><li>类型限制了变量的取值范围，所以在一些情况中，运行时错误就被转换成了编译时错误。</li><li>不可变性是类型施加的一种数据属性，保证了值在不应该发生变化时不会发生变化。</li><li>可见性是另外一种类型级别的属性，决定了哪些组件能访问哪些数据。</li><li>类型标识符使得阅读代码的人更容易理解代码。</li><li>动态类型（或叫“鸭子类型”）在运行时决定类型。</li><li>静态类型在编译时检查类型，捕获到原本有可能成为运行时错误的类型错误。</li><li>类型系统的强度衡量的是该系统允许在类型之间进行多少隐式转换。</li><li>现代类型检查器具有强大的类型推断算法，使它们能够确定变量或者函数的类型，而不需要我们显式地写出类型。</li></ul><h2 style=\"text-indent: 0px; text-align: start;\">2.&nbsp;编程语言中的基本类型</h2><p style=\"text-indent: 0px; text-align: start;\">本节介绍编程语言类型系统的特性，从基本类型开始，到函数类型、OOP、泛型编程和高阶类型（如函子和单子）。</p><h3 style=\"text-indent: 0px; text-align: start;\">基本类型</h3><p style=\"text-indent: 0px; text-align: start;\">常用的基本类型包括空类型、单元类型、布尔类型、数值类型、字符串类型、数组类型和引用类型。</p><h3 style=\"text-indent: 0px; text-align: start;\">函数类型</h3><p style=\"text-indent: 0px; text-align: start;\">“函数类型是类型系统在基本类型及其组合的基础上发展的又一个阶段。”</p><p style=\"text-indent: 0px; text-align: start;\">大部分现代编程语言都支持匿名函数，也称为lambda。lambda与普通的函数类似，但是没有名称。每当我们需要使用一次性函数时，就会使用lambda。所谓一次性函数，是指我们只会引用这种函数一次，所以为其命名就成了多余的工作。</p><blockquote style=\"text-indent: 0px; text-align: start;\">lambda或匿名函数：lambda，也称为匿名函数，是没有名称的函数定义。lambda通常用于一次性的、短期存在的处理，并像数据一样被传来传去。</blockquote><p style=\"text-indent: 0px; text-align: start;\">函数能够接受其他函数作为实参，或者返回其他函数。接受一个或多个非函数实参并返回一个非函数类型的“标准”函数也称为一阶函数，或普通函数。接受一个一阶函数作为实参或者返回一个一阶函数的函数称为二阶函数。</p><p style=\"text-indent: 0px; text-align: start;\">我们可以继续往后推，称接受二阶函数作为实参或者返回二阶函数的函数为三阶函数，但是在实际运用中，我们只是简单地把所有接受或返回其他函数的函数称为高阶函数。</p><p style=\"text-indent: 0px; text-align: start;\">我们可以使用“函数类型”简化策略模式。如果一个变量是函数类型（命名函数类型），并在使用其他类型的值的地方能够使用函数，就可以简化一些常用结构的实现，并把常用算法抽象为库函数。</p><h3 style=\"text-indent: 0px; text-align: start;\">泛型编程</h3><p style=\"text-indent: 0px; text-align: start;\">泛型编程支持强大的解耦合以及代码重用。<br>泛型数据结构把数据的布局与数据本身分隔开。迭代器支持遍历这些数据结构。泛型算法（例如，最经典的&nbsp;sort&nbsp;排序算法&nbsp;）是能够在不同数据类型上重用的算法。迭代器（Iterator）用作数据结构和算法之间的接口，并且能够根据迭代器的能力启用不同的算法。</p><p style=\"text-indent: 0px; text-align: start;\">例如，&nbsp;一个泛型函数&nbsp;：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>(value:T) =&gt; T</code></pre><p style=\"text-indent: 0px; text-align: start;\">它的类型参数是T。当为T指定了实际类型时，就创建了具体函数。具体类图示例如下：</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">再例如，一个泛型二叉树。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">泛型高阶函数&nbsp;map()&nbsp;,&nbsp;filter()&nbsp;,&nbsp;reduce()&nbsp;代码和示意图如下。</p><ul style=\"text-indent: 0px; text-align: start;\"><li>map()</li></ul><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; {\n    return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\"><br></p><ul style=\"text-indent: 0px; text-align: start;\"><li>filter()public&nbsp;inline&nbsp;fun&nbsp;&lt;T&gt;&nbsp;Iterable&lt;T&gt;.filter(predicate:&nbsp;(T)&nbsp;-&gt;&nbsp;Boolean):&nbsp;List&lt;T&gt;&nbsp;{&nbsp;return&nbsp;filterTo(ArrayList&lt;T&gt;(),&nbsp;predicate)&nbsp;}</li><li>reduce()public&nbsp;inline&nbsp;fun&nbsp;&lt;S,&nbsp;T&nbsp;:&nbsp;S&gt;&nbsp;Iterable&lt;T&gt;.reduce(operation:&nbsp;(acc:&nbsp;S,&nbsp;T)&nbsp;-&gt;&nbsp;S):&nbsp;S&nbsp;{&nbsp;val&nbsp;iterator&nbsp;=&nbsp;this.iterator()&nbsp;if&nbsp;(!iterator.hasNext())&nbsp;throw&nbsp;UnsupportedOperationException(\"Empty&nbsp;collection&nbsp;can't&nbsp;be&nbsp;reduced.\")&nbsp;var&nbsp;accumulator:&nbsp;S&nbsp;=&nbsp;iterator.next()&nbsp;while&nbsp;(iterator.hasNext())&nbsp;{&nbsp;accumulator&nbsp;=&nbsp;operation(accumulator,&nbsp;iterator.next())&nbsp;}&nbsp;return&nbsp;accumulator&nbsp;}</li></ul><h4 style=\"text-indent: 0px; text-align: start;\">高阶类型</h4><p style=\"text-indent: 0px; text-align: start;\">高阶类型与高阶函数类似，代表具有另外一个类型参数的类型参数。例如，T&lt;U&gt;或Box&lt;T&lt;U&gt;&gt;有一个类型参数T，后者又有一个类型参数U。</p><p style=\"text-indent: 0px; text-align: start;\">正如高阶函数是接受其他函数作为实参的函数，高阶类型是接受其他种类作为实参的种类（参数化的类型构造函数）。</p><h4 style=\"text-indent: 0px; text-align: start;\">类型构造函数</h4><p style=\"text-indent: 0px; text-align: start;\">在类型系统中，我们可以认为类型构造函数是返回类型的一个函数。我们不需要自己实现类型构造函数，因为这是类型系统在内部看待类型的方式。</p><p style=\"text-indent: 0px; text-align: start;\">每个类型都有一个构造函数。一些构造函数很简单。例如，可以把类型number的构造函数看作不接受实参、返回number类型的一个函数，也就是()&nbsp;-&gt;&nbsp;[number&nbsp;type]。</p><p style=\"text-indent: 0px; text-align: start;\">对于泛型，情况则有了变化。泛型类型，如T[]，需要一个实际的类型参数来生成一个具体类型。其类型构造函数为(T)&nbsp;-&gt;&nbsp;[T[]&nbsp;type]。例如，当T是number时，我们得到的类型是一个数值数组number[]，而当T是string时，得到的类型是一个字符串数组string[]。这种构造函数也称为“种类”，即类型T[]的种类。</p><p style=\"text-indent: 0px; text-align: start;\">高阶类型与高阶函数一样，将抽象程度提高了一个级别。在这里，我们的类型构造函数可以接受另外一个类型构造函数作为实参。</p><h3 style=\"text-indent: 0px; text-align: start;\">空类型（nil&nbsp;/&nbsp;null&nbsp;pointer）</h3><h4 style=\"text-indent: 0px; text-align: start;\">null&nbsp;vs&nbsp;亿万美元的错误</h4><p style=\"text-indent: 0px; text-align: start;\">著名的计算机科学家、图灵奖获得者托尼·霍尔爵士称null引用是他犯下的“亿万美元错误”。他说过：<br>“1965年我发明了null引用。现在我把它叫作我犯下的亿万美元错误。当时，我在一种面向对象语言中为引用设计第一个全面的类型系统。我的目标是让编译器来自动执行检查，确保所有使用引用的地方都是绝对安全的。但是，我没能抗拒诱惑，在类型系统中添加了null引用，这只是因为实现null引用太简单了。这导致了难以计数的错误、漏洞和系统崩溃，在过去四十年中可能造成了数亿美元的损失。”<br>几十年来发生了非常多的null解引用错误，所以现在很明显，最好不要让null（即没有值）自身成为某个类型的一个有效的值。</p><p style=\"text-indent: 0px; text-align: start;\">接下来，我们介绍通过组合现有类型来创建新类型的多种方式。</p><h2 style=\"text-indent: 0px; text-align: start;\">3.&nbsp;类型组合</h2><p style=\"text-indent: 0px; text-align: start;\">本节介绍类型组合，即如何把类型组合起来，从而定义新类型的各种方式。<br>组合类型，是将类型放到一起，使结果类型的值由每个成员类型的值组成。</p><h3 style=\"text-indent: 0px; text-align: start;\">代数数据类型（Algebraic&nbsp;Data&nbsp;Type，ADT）</h3><p style=\"text-indent: 0px; text-align: start;\">ADT是在类型系统中组合类型的方式。ADT提供了两种组合类型的方式：</p><ol style=\"text-indent: 0px; text-align: start;\"><li>乘积类型</li><li>和类型</li></ol><h4 style=\"text-indent: 0px; text-align: start;\">乘积类型</h4><p style=\"text-indent: 0px; text-align: start;\">乘积类型就是本章所称的复合类型。元组和记录是乘积类型，因为它们的值是各构成类型的乘积。类型A&nbsp;=&nbsp;{a1,&nbsp;a2}（类型A的可能值为a1和a2）和B&nbsp;=&nbsp;{b1,&nbsp;b2}（类型B的可能值为b1和b2）组合成为元素类型&lt;A,&nbsp;B&gt;时，结果为A×B&nbsp;=&nbsp;{(a1,&nbsp;b1),&nbsp;(a1,&nbsp;b2),&nbsp;(a2,&nbsp;b1),&nbsp;(a2,&nbsp;b2)}。</p><p style=\"text-indent: 0px; text-align: start;\">元组和记录类型都是乘积类型的例子。另外，记录允许我们为每个成员分配有意义的名称。</p><h4 style=\"text-indent: 0px; text-align: start;\">和类型</h4><p style=\"text-indent: 0px; text-align: start;\">和类型，是将多个其他类型组合成为一个新类型，它存储任何一个构成类型的值。类型A、B和C的和类型可以写作A&nbsp;+&nbsp;B&nbsp;+&nbsp;C，它包含A的一个值，或者B的一个值，或者C的一个值。</p><p style=\"text-indent: 0px; text-align: start;\">可选类型和变体类型是“和类型”的例子。</p><h2 style=\"text-indent: 0px; text-align: start;\">4.&nbsp;OOP&nbsp;与接口类型</h2><p style=\"text-indent: 0px; text-align: start;\">本节介绍面向对象编程的关键元素，以及什么时候使用每种元素，并讨论接口、继承、组合和混入。</p><h3 style=\"text-indent: 0px; text-align: start;\">OOP:&nbsp;面向对象编程</h3><blockquote style=\"text-indent: 0px; text-align: start;\">面向对象编程（Object-Oriented&nbsp;Programming，OOP）：OOP是基于对象的概念的一种编程范式，对象可以包含数据和代码。数据是对象的状态，代码是一个或多个方法，也叫作“消息”。在面向对象系统中，通过使用其他对象的方法，对象之间可以“对话”或者发送消息。</blockquote><p style=\"text-indent: 0px; text-align: start;\">OOP的两个关键特征是封装和继承。封装允许隐藏数据和方法，而继承则使用额外的数据和代码扩展一个类型。</p><p style=\"text-indent: 0px; text-align: start;\">封装出现在多个层次，例如，服务将其API公开为接口，模块导出其接口并隐藏实现细节，类只公开公有成员，等等。与嵌套娃娃一样，代码两部分之间的关系越弱，共享的信息就越少。这样一来，组件对其内部管理的数据能够做出的保证就得到了强化，因为如果不经过该组件的接口，外部代码将无法修改这些数据。</p><p style=\"text-indent: 0px; text-align: start;\">一个“参数化表达式”的面向对象继承体系的例子。类图如下。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">这里的表达式，可以通过eval()&nbsp;方法，计算得到一个数字，二元表达式有两个操作数，加法和乘法表达式通过把操作数相加或相乘来计算结果。</p><p style=\"text-indent: 0px; text-align: start;\">我们可以把表达式建模为具有eval()方法的IExpression接口。之所以能将其建模为接口，是因为它不保存任何状态。</p><p style=\"text-indent: 0px; text-align: start;\">接下来，我们实现一个BinaryExpression抽象类，在其中存储两个操作数。但是，我们让eval()是抽象方法，从而要求派生类实现该方法。SumExpression和MulExpression都从BinaryExpression继承两个操作数，并提供它们自己的eval()实现。代码如下。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><h3 style=\"text-indent: 0px; text-align: start;\">接口类型：&nbsp;抽象类和接口</h3><p style=\"text-indent: 0px; text-align: start;\">我们使用接口来指定契约。接口可被扩展和组合。</p><p style=\"text-indent: 0px; text-align: start;\">接口或契约：接口（或契约）描述了实现该接口的任何对象都理解的一组消息。消息是方法，包括名称、实参和返回类型。接口没有任何状态。与现实世界的契约（它们是书面协议）一样，接口也相当于书面协议，规定了实现者将提供什么。</p><p style=\"text-indent: 0px; text-align: start;\">接口又称为动态数据类型，在进行接口使用的的时候,会将接口对位置的动态类型改为所指向的类型<br>会将动态值改成所指向类型的结构体。</p><h2 style=\"text-indent: 0px; text-align: start;\">5.&nbsp;函数类型</h2><p style=\"text-indent: 0px; text-align: start;\">本节介绍函数类型，以及当我们获得了创建函数变量的能力后能够做些什么，还展示实现策略模式和状态机的不同方式，并介绍基本的map()、filter()和reduce()算法。</p><h3 style=\"text-indent: 0px; text-align: start;\">什么是函数类型？</h3><h4 style=\"text-indent: 0px; text-align: start;\">函数类型或签名</h4><p style=\"text-indent: 0px; text-align: start;\">函数的实参集合加上返回类型称为函数类型（或函数签名）。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">函数类型本质上跟接口类型的范畴相同，都是一组映射规则（接口协议），不绑定具体的实现（class，struct）。</p><p style=\"text-indent: 0px; text-align: start;\">函数的实参类型和返回类型决定了函数的类型。如果两个函数接受相同的实参，并返回相同的类型，那么它们具有相同的类型。实参集合加上返回类型也称为函数的签名。</p><h4 style=\"text-indent: 0px; text-align: start;\">一等函数</h4><p style=\"text-indent: 0px; text-align: start;\">将函数赋值给变量，并像处理类型系统中的其他值一样处理它们，就得到了所谓的一等函数。这意味着语言将函数视为“一等公民”，赋予它们与其他值相同的权利：它们有类型，可被赋值给变量，可作为实参传递，可被检查是否有效，以及在兼容的情况下可被转换为其他类型。</p><p style=\"text-indent: 0px; text-align: start;\">“一等函数”编程语言，可以把函数赋值给变量、作为实参传递以及像使用其他值一样使用，这使得代码的表现力更强。</p><h3 style=\"text-indent: 0px; text-align: start;\">一个简单的策略模式</h3><h4 style=\"text-indent: 0px; text-align: start;\">策略设计模式</h4><p style=\"text-indent: 0px; text-align: start;\">策略模式是最常用的设计模式之一。策略设计模式是一种行为软件设计模式，允许在运行时从一组算法中选择某个算法。它把算法与使用算法的组件解耦，从而提高了整个系统的灵活性。下图展示了这种模式。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">策略模式由IStrategy接口、ConcreteStrategy1和ConcreteStrategy2实现以及通过IStrategy接口使用算法的Context构成。代码如下：</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><h4 style=\"text-indent: 0px; text-align: start;\">函数式策略</h4><p style=\"text-indent: 0px; text-align: start;\">我们可以把WashingStrategy定义为一个类型，代表接受Car作为实参并返回void的一个函数。然后，我们可以把两种洗车服务实现为两个函数，standardWash()和premiumWash()，它们都接受Car作为实参，并返回void。CarWash可以选择其中一个函数应用到一辆给定的汽车，如下图。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">策略模式由Context构成，它使用两个函数之一：concreteStrategy1()或concreteStrategy2()&nbsp;。代码如下：</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><h3 style=\"text-indent: 0px; text-align: start;\">一个简单的装饰器模式</h3><p style=\"text-indent: 0px; text-align: start;\">装饰器模式是一个简单的行为软件设计模式，可扩展对象的行为，而不必修改对象的类。装饰的对象可以执行其原始实现没有提供的功能。装饰器模式如图所示。<br></p><blockquote style=\"text-indent: 0px; text-align: start;\">图说明：装饰器模式，一个IComponent接口，一个具体实现，即ConcreteComponent，以及使用额外行为来增强IComponent的Decorator。</blockquote><h4 style=\"text-indent: 0px; text-align: start;\">一个单例逻辑的装饰器</h4><p style=\"text-indent: 0px; text-align: start;\">一个单例逻辑的装饰器代码实例如下。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><h4 style=\"text-indent: 0px; text-align: start;\">用函数装饰器来实现</h4><p style=\"text-indent: 0px; text-align: start;\">下面我们来使用函数类型实现装饰器模式。<br>首先，删除IWidgetFactory接口，改为使用一个函数类型。该类型的函数不接受实参，返回一个Widget:()&nbsp;=&gt;&nbsp;Widget。</p><p style=\"text-indent: 0px; text-align: start;\">在之前使用IWidgetFactory并传入WidgetFactor实例的地方，现在需要使用()&nbsp;=&gt;&nbsp;Widget类型的函数，并传入makeWidget()，代码如下。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">我们使用了一种类似于上面的策略模式的技术：将函数作为实参，在需要的时候进行调用。但是，上面的&nbsp;use10Widgets()&nbsp;每次调用都会构造生成一个新的&nbsp;Widget&nbsp;实例。</p><p style=\"text-indent: 0px; text-align: start;\">接下来看如何添加单例行为。我们提供一个新函数singletonDecorator()，它接受一个WidgetFactory类型的函数，并返回另外一个WidgetFactory类型的函数。代码如下。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">现在，use10Widgets()不会构造10个Widget对象，而是会调用lambda，为所有调用重用相同的Widget实例。</p><h4 style=\"text-indent: 0px; text-align: start;\">小结</h4><p style=\"text-indent: 0px; text-align: start;\">与策略模式一样，面向对象方法和函数式方法实现了相同的装饰器模式。</p><p style=\"text-indent: 0px; text-align: start;\">面向对象版本需要声明一个接口（IWidgetFactory），该接口的至少一个实现（WidgetFactory），以及处理附加行为的一个装饰器类。</p><p style=\"text-indent: 0px; text-align: start;\">与之相对，函数式实现只是声明了工厂函数的类型（()&nbsp;=&gt;&nbsp;Widget），并使用两个函数：一个工厂函数（makeWidget()）和一个装饰器函数（singletonDecorator()）。</p><h2 style=\"text-indent: 0px; text-align: start;\">6.&nbsp;函子和单子(Functor&nbsp;and&nbsp;Monad)</h2><h3 style=\"text-indent: 0px; text-align: start;\">概述</h3><p style=\"text-indent: 0px; text-align: start;\">函子和单子的概念来自范畴论。范畴论是数学的一个分支，研究的是由对象及这些对象之间的箭头组成的结构。有了这些小构造块，我们就可以建立函子和单子这样的结构。我们不会深入讨论细节，只是简单说明一下。许多领域（如集合论，甚至类型系统）都可以用范畴论来表达。</p><h4 style=\"text-indent: 0px; text-align: start;\">函子(Functor)</h4><p style=\"text-indent: 0px; text-align: start;\">\"Talk&nbsp;is&nbsp;cheap,&nbsp;show&nbsp;me&nbsp;the&nbsp;code\".</p><p style=\"text-indent: 0px; text-align: start;\">函子，就是数据类型&nbsp;Functor，它有一个属性值value和一个map方法。map方法可以处理value，并生成新的Functor实例。函子的代码如下：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>class Functor&lt;T&gt; {\n    private value:T;\n\n    constructor(val:T){\n        this.value = val\n    }\n\n    public map&lt;U&gt;(fn:(val:T)=&gt;U){\n        let rst = fn(this.value)\n        return new Functor(rst)\n    }\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">验证一下Functor的应用实例，是否符合我们想要的数据类型？</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>new Functor(3)\n    .map(d=&gt;add(d))\n    .map(d=&gt;double(d.value))\n    .map(d=&gt;square(d.value)) // Functor { value: 256 }</code></pre><p style=\"text-indent: 0px; text-align: start;\">这就是函子，一种受规则约束，含有值(value)和值的变形关系(函数map)的数据类型(容器)。&nbsp;它是一种新的函数组合方式，可以链式调用，可以用于约束传输的数据结构，可以映射适配函数的输出值与下一个函数输入值，可以一定程度上避免函数执行的副作用。</p><p style=\"text-indent: 0px; text-align: start;\">函子的用途是什么呢？这个问题需要从前面讲过的函数组合(Function&nbsp;Composition)讲起。</p><p style=\"text-indent: 0px; text-align: start;\">函数组合是一种把多个函数组合成新函数的方式，它解决了函数嵌套调用的问题，还提供了函数拆分组合的方式。</p><h4 style=\"text-indent: 0px; text-align: start;\">函数的函子</h4><p style=\"text-indent: 0px; text-align: start;\">除了函子外，需要知道的是，还有函数的函子。给定一个有任意数量的实参且返回类型T的值的一个函数。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><h3 style=\"text-indent: 0px; text-align: start;\">函子在数学与函数式编程中</h3><p style=\"text-indent: 0px; text-align: start;\">在数学中，特别是范畴论，函子是范畴之间的映射（范畴间的同态）。由一范畴映射至其自身的函子称之为“自函子”。</p><p style=\"text-indent: 0px; text-align: start;\">在函数式编程里，函子是最重要的数据类型，也是基本的运算单位和功能单位。Functor&nbsp;是实现了&nbsp;map()&nbsp;函数并遵守一些特定规则的容器类型。</p><p style=\"text-indent: 0px; text-align: start;\">我们有一个泛型类型H，它包含某个类型T的0个、1个或更多个值，还有一个从T到U的函数。在本例中，T是一个空心圆，U是一个实心圆。map()函子从H&lt;T&gt;实例中拆包出T，应用函数，然后把结果放回到一个H&lt;U&gt;中。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">其实，上面的&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>map(transform:&nbsp;(T)&nbsp;-&gt;&nbsp;R):&nbsp;List&lt;R&gt;</code></span>&nbsp;高阶函数就是一个<span style=\"color: rgb(214, 51, 132);\"><code>函子</code></span>。</p><blockquote style=\"text-indent: 0px; text-align: start;\">函子：函子是执行映射操作的函数的推广。对于任何泛型类型，以Box&lt;T&gt;为例，如果map()操作接受一个Box&lt;T&gt;和一个从T到U的函数作为实参，并得到一个Box&lt;U&gt;，那么该map()就是一个函子。</blockquote><h5 style=\"text-indent: 0px; text-align: start;\">函子定义（Functor&nbsp;Laws&nbsp;）</h5><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>恒等定律：fmap id = id\n组合定律： fmap (g . h) = (fmap g) . (fmap h)</code></pre><p style=\"text-indent: 0px; text-align: start;\">函子很强大，但是大部分主流语言都没有很好的方式来表达函子，因为函子的常规定义依赖于高阶类型（不是“高阶函数”，是“高阶类型”）的概念。</p><h5 style=\"text-indent: 0px; text-align: start;\">Functor&nbsp;函子的代码实现示例</h5><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>class Functor {\n  // 构造函数，创建函子对象的时候接收任意类型的值，并把值赋给它的私有属性 _value\n  constructor(value) { \n    this._value = value\n  }\n \n  // 接收一个函数，处理值的变形并返回一个新的函子对象\n  map (fn) {\n    return new Functor(fn(this._value))\n  }\n}\n\nlet num1 = new Functor(3).map(val =&gt; val + 2)\n\n// 输出：Functor { _value: 5 }\nconsole.log(num1)\n\nlet num2 = new Functor(3).map(val =&gt; val + 2).map(val =&gt; val * 2)\n\n// 输出：Functor { _value: 10 }\nconsole.log(num2)\n\n// 改变了值类型\nlet num3 = new Functor('webpack').map(val =&gt; `${val}-cli`).map(val =&gt; val.length)\n\n// 输出：Functor { _value: 11 }\nconsole.log(num3)</code></pre><h4 style=\"text-indent: 0px; text-align: start;\">单子&nbsp;（Monad&nbsp;Functor）</h4><p style=\"text-indent: 0px; text-align: start;\">函子的value支持任何数据类型，当然也可以是函子。但是这样会造成函子嵌套的问题。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>Maybe.of(3).map(n =&gt; Maybe.of(n + 2)) // Maybe { value: Maybe { value: 5 } }</code></pre><p style=\"text-indent: 0px; text-align: start;\">单子（Monad&nbsp;函子）就是解决这个问题的。</p><p style=\"text-indent: 0px; text-align: start;\">Monad&nbsp;Functor&nbsp;总是返回一个单层的函子，避免出现嵌套的情况。因为它有一个&nbsp;flatMap&nbsp;方法，如果生成了一个嵌套函子，它会取出后者的value，保证返回的是一个单层函子，避免出现嵌套的情况。<br>代码如下。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>class Monad&lt;T&gt; exteds Functor&lt;T&gt;{\n    static of&lt;T&gt;(val:T){\n        return new Monad(val)\n    }\n\n    isNothing() {\n        return this.value === null || this.value === undefined\n    }\n\n    public map&lt;U&gt;(fn:(val:T)=&gt;U){\n        if (this.isNothing()) return Monad.of(null)\n        let rst = fn(this.value)\n        return Monad.of(rst)\n    }\n\n    public join(){\n        return this.value\n    }\n\n    public flatMap&lt;U&gt;(fn:(val:T)=&gt;U){\n        return this.map(fn).join()\n    }\n}\n\nMonad.of(3).flatMap(val =&gt; Monad.of(val + 2)) // Monad { value: 5 }</code></pre><p style=\"text-indent: 0px; text-align: start;\">通常讲，Monad函子就是实现flatMap方法的Pointed函子。</p><p style=\"text-indent: 0px; text-align: start;\">Monad&nbsp;由以下三个部分组成：</p><ol style=\"text-indent: 0px; text-align: start;\"><li>一个类型构造函数（M），可以构建出一元类型&nbsp;M&lt;T&gt;。</li><li>一个类型转换函数（return&nbsp;or&nbsp;unit），能够把一个原始值装进&nbsp;M&nbsp;中。unit(x)&nbsp;:&nbsp;T&nbsp;-&gt;&nbsp;M&nbsp;T</li><li>一个组合函数&nbsp;bind，能够把&nbsp;M&nbsp;实例中的值取出来，放入一个函数&nbsp;fn:&nbsp;T-&gt;&nbsp;M&lt;U&gt;&nbsp;中去执行，最终得到一个新的&nbsp;M&nbsp;实例。bind:&nbsp;执行&nbsp;fn:&nbsp;T&nbsp;-&gt;&nbsp;M&lt;U&gt;</li></ol><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">除此之外，它还遵守一些规则：</p><ul style=\"text-indent: 0px; text-align: start;\"><li>单位元规则，通常由&nbsp;unit&nbsp;函数去实现。</li><li>结合律规则，通常由&nbsp;bind&nbsp;函数去实现。</li></ul><p style=\"text-indent: 0px; text-align: start;\">代码实例：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>class Monad {\n  value = \"\";\n  // 构造函数\n  constructor(value) {\n    this.value = value;\n  }\n  // unit，把值装入 Monad 构造函数中\n  unit(value) {\n    this.value = value;\n  }\n  // bind，把值转换成一个新的 Monad\n  bind(fn) {\n    return fn(this.value);\n  }\n}\n\n// 满足 x-&gt; M(x) 格式的函数\nfunction add1(x) {\n  return new Monad(x + 1);\n}\n// 满足 x-&gt; M(x) 格式的函数\nfunction square(x) {\n  return new Monad(x * x);\n}\n\n// 接下来，我们就能进行链式调用了\nconst a = new Monad(2)\n     .bind(square)\n     .bind(add1);\n     //...\n\nconsole.log(a.value === 5); // true\n</code></pre><p style=\"text-indent: 0px; text-align: start;\">上述代码就是一个最基本的&nbsp;Monad，它将程序的多个步骤抽离成线性的流，通过&nbsp;bind&nbsp;方法对数据流进行加工处理，最终得到我们想要的结果。</p><h3 style=\"text-indent: 0px; text-align: start;\">范畴论中的函子</h3><p style=\"text-indent: 0px; text-align: start;\">Warning：下文的内容偏数学理论，不感兴趣的同学跳过即可。</p><blockquote style=\"text-indent: 0px; text-align: start;\">原文：<em>A&nbsp;monad&nbsp;is&nbsp;a&nbsp;monoid&nbsp;in&nbsp;the&nbsp;category&nbsp;of&nbsp;endofunctors</em>&nbsp;（Philip&nbsp;Wadler）。<br>翻译：Monad&nbsp;是一个&nbsp;<strong>自函子</strong>&nbsp;<strong>范畴</strong>&nbsp;上的&nbsp;<strong>幺半群</strong>”&nbsp;。</blockquote><p style=\"text-indent: 0px; text-align: start;\">这里标注了&nbsp;3&nbsp;个重要的概念：自函子、范畴、幺半群，这些都是数学知识，我们分开理解一下。</p><h5 style=\"text-indent: 0px; text-align: start;\">什么是范畴？</h5><p style=\"text-indent: 0px; text-align: start;\">任何事物都是对象，大量的对象结合起来就形成了集合，对象和对象之间存在一个或多个联系，任何一个联系就叫做态射。</p><p style=\"text-indent: 0px; text-align: start;\">一堆对象，以及对象之间的所有态射所构成的一种代数结构，便称之为&nbsp;<strong>范畴</strong>。</p><h5 style=\"text-indent: 0px; text-align: start;\">什么是函子？</h5><p style=\"text-indent: 0px; text-align: start;\">我们将范畴与范畴之间的映射称之为&nbsp;<strong>函子</strong>。映射是一种特殊的态射，所以函子也是一种态射。</p><h5 style=\"text-indent: 0px; text-align: start;\">什么是自函子？</h5><p style=\"text-indent: 0px; text-align: start;\"><strong>自函子</strong>就是一个将范畴映射到自身的函子。</p><h5 style=\"text-indent: 0px; text-align: start;\">什么是幺半群&nbsp;Monoid？</h5><p style=\"text-indent: 0px; text-align: start;\">幺半群是一个存在&nbsp;单位元&nbsp;的半群。</p><h5 style=\"text-indent: 0px; text-align: start;\">什么是半群？</h5><p style=\"text-indent: 0px; text-align: start;\">如果一个集合，满足结合律，那么就是一个<strong>半群</strong>。</p><h5 style=\"text-indent: 0px; text-align: start;\">什么是单位元？</h5><p style=\"text-indent: 0px; text-align: start;\"><strong>单位元</strong>是集合里的一种特别的元素，与该集合里的二元运算有关。当单位元和其他元素结合时，并不会改变那些元素。如：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>任何一个数 + 0 = 这个数本身。 那么 0 就是单位元（加法单位元）\n任何一个数 * 1 = 这个数本身。那么 1 就是单位元（乘法单位元）</code></pre><p style=\"text-indent: 0px; text-align: start;\">Ok，我们已经了解了所有应该掌握的专业术语，那就简单串解一下这段解释吧：</p><p style=\"text-indent: 0px; text-align: start;\">一个&nbsp;<strong>自函子</strong>&nbsp;<strong>范畴</strong>&nbsp;上的&nbsp;<strong>幺半群</strong>&nbsp;，可以理解为：</p><blockquote style=\"text-indent: 0px; text-align: start;\">在一个满足结合律和单位元规则的集合中，存在一个映射关系，这个映射关系可以把集合中的元素映射成当前集合自身的元素。</blockquote><h3 style=\"text-indent: 0px; text-align: start;\">小结</h3><p style=\"text-indent: 0px; text-align: start;\">在不涉及范畴论的情况下，针对函子和单子，做一个简单的小结。</p><p style=\"text-indent: 0px; text-align: start;\">Functor&nbsp;和&nbsp;monad&nbsp;都为包装输入提供了一些工具，返回包装后的输出。</p><p style=\"text-indent: 0px; text-align: start;\">Functor&nbsp;=&nbsp;unit&nbsp;+&nbsp;map（即工具）</p><p style=\"text-indent: 0px; text-align: start;\">在哪里，</p><p style=\"text-indent: 0px; text-align: start;\">unit=&nbsp;接受原始输入并将其包装在一个小上下文中的东西。</p><p style=\"text-indent: 0px; text-align: start;\">map=&nbsp;将函数作为输入的工具，将其应用于包装器中的原始值，并返回包装后的结果。</p><p style=\"text-indent: 0px; text-align: start;\">示例：让我们定义一个将整数加倍的函数</p><p style=\"text-indent: 0px; text-align: start;\">//&nbsp;doubleMe&nbsp;::&nbsp;Int&nbsp;a&nbsp;-&gt;&nbsp;Int&nbsp;b<br>const&nbsp;doubleMe&nbsp;=&nbsp;a&nbsp;=&gt;&nbsp;2&nbsp;*&nbsp;a;<br>Maybe(2).map(doubleMe)&nbsp;//&nbsp;Maybe(4)<br>Monad&nbsp;=&nbsp;unit&nbsp;+&nbsp;flatMap&nbsp;（或绑定或链）</p><p style=\"text-indent: 0px; text-align: start;\">flatMapmap=顾名思义，就是将&nbsp;扁平化的工具。</p><hr/><h2 style=\"text-indent: 0px; text-align: start;\">番外篇：自组织理论与复杂软件系统</h2><p style=\"text-indent: 0px; text-align: start;\">自组织理论是20世纪60年代末期开始建立并发展起来的一种系统理论。它的研究对象主要是复杂自组织系统（生命系统、社会系统）的形成和发展机制问题，即在一定条件下，系统是如何自动地由无序走向有序，由低级有序走向高级有序的。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">自组织是现代非线性科学和非平衡态热力学的最令人惊异的发现之一。基于对物种起源、生物进化和社会发展等过程的深入观察和研究，一些新兴的横断学科从不同的角度对自组织的概念给予了界说。</p><p style=\"text-indent: 0px; text-align: start;\">从系统论的观点来说，自组织是指一个系统在内在机制的驱动下，自行从简单向复杂、从粗糙向细致方向发展，不断地提高自身的复杂度和精细度的过程；</p><p style=\"text-indent: 0px; text-align: start;\">从热力学的观点来说，自组织是指一个系统通过与外界交换物质、能量和信息，而不断地降低自身的熵含量，提高其有序度的过程；</p><p style=\"text-indent: 0px; text-align: start;\">从统计力学的观点来说，自组织是指一个系统自发地从最可几状态向几率较低的方向迁移的过程；</p><p style=\"text-indent: 0px; text-align: start;\">从进化论的观点来说，自组织是指一个系统在遗传、变异和优胜劣汰机制的作用下，其组织结构和运行模式不断地自我完善，从而不断提高其对于环境的适应能力的过程。C.&nbsp;R.&nbsp;Darwin的生物进化论的最大功绩就是排除了外因的主宰作用，首次从内在机制上、从一个自组织的发展过程中来解释物种的起源和生物的进化。</p><h3 style=\"text-indent: 0px; text-align: start;\">什么是复杂？</h3><blockquote style=\"text-indent: 0px; text-align: start;\">“复杂”&nbsp;(&nbsp;Complexity&nbsp;)定义为由于组件之间的依赖关系、关系和交互，而难以对其行为建模的任何系统。更通俗地说，复杂系统的“整体”大于“部分”之和。也就是说，如果不查看单个组件以及它们如何相互作用，就无法理解其整体行为的系统，同时也无法通过仅查看单个组件而忽略系统影响来理解系统的整体行为。</blockquote><p style=\"text-indent: 0px; text-align: start;\">随着软件系统的扩展，它变得足够大，以至于工作部件的数量，加上对其进行更改的工作程序员的数量，使得系统的行为非常难以推理。</p><p style=\"text-indent: 0px; text-align: start;\">这种复杂性因许多组织向微服务架构的转变而加剧，例如所谓的“死星”架构，其中圆圈圆周上的每个点代表一个微服务，服务之间的线代表它们的交互。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31c"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c57efb4edbe7504484913a",
  "title": "Ajax 怎么取消？要不要取消？",
  "cover": "",
  "body": "<div class='wang-editor'><h2 style=\"text-indent: 0px; text-align: start;\">Ajax&nbsp;cancel</h2><p style=\"text-indent: 0px; text-align: start;\">假如你熟悉&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>xhr</code></span>，会知道&nbsp;Ajax&nbsp;其实可以前端主动取消，使用的是&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>XMLHttpRequest.abort()</code></span>。当然现在也不是刀耕火种的时代，除了面试，可能基本不会手写&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>xhr</code></span>，在无人不知的&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>axios</code></span>&nbsp;中有两种取消方法：</p><p style=\"text-indent: 0px; text-align: start;\">首先是老式&nbsp;cancelToken：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>const CancelToken = axios.CancelToken\nconst source = CancelToken.source()\n\naxios\n  .get('/user/12345', {\n    cancelToken: source.token,\n  })\n  .catch(function (thrown) {\n    if (axios.isCancel(thrown)) {\n      console.log('Request canceled', thrown.message)\n    } else {\n      // handle error\n    }\n  })\n\naxios.post(\n  '/user/12345',\n  {\n    name: 'new name',\n  },\n  {\n    cancelToken: source.token,\n  }\n)\n\n// cancel the request (the message parameter is optional)\nsource.cancel('Operation canceled by the user.')</code></pre><p style=\"text-indent: 0px; text-align: start;\">然后是新玩意（其实也不新）AbortController：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>const controller = new AbortController()\n\naxios\n  .get('/foo/bar', {\n    signal: controller.signal,\n  })\n  .then(function (response) {\n    //...\n  })\n// cancel the request\ncontroller.abort()</code></pre><p style=\"text-indent: 0px; text-align: start;\">cancelToken&nbsp;和&nbsp;signal&nbsp;传到&nbsp;axios&nbsp;之后，都会以某种机制调用&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>XMLHttpRequest.abort()</code></span>。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>onCanceled = (cancel) =&gt; {\n  if (!request) {\n    return\n  }\n  reject(\n    !cancel || cancel.type ? new CanceledError(null, config, request) : cancel\n  )\n  request.abort()\n  request = null\n}\n\nconfig.cancelToken &amp;&amp; config.cancelToken.subscribe(onCanceled)\nif (config.signal) {\n  config.signal.aborted\n    ? onCanceled()\n    : config.signal.addEventListener('abort', onCanceled)\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">cancelToken&nbsp;是利用发布订阅模式通知&nbsp;axios&nbsp;取消请求，虽然这部分是&nbsp;axios&nbsp;自己实现的，但是源自于一个&nbsp;tc39&nbsp;提案&nbsp;<a href=\"https://link.segmentfault.com/?enc=%2BWHgw5PDQmJPwRirAgfiQg%3D%3D.On42CHSDatoCgKgpTyzzjLvRz1CbK8ey7HhbSZaOl4J1DYolaljqcOjqXuL8G7%2B6lHrjrfxfj6q1hBMCBlj%2FcA%3D%3D\" target=\"_blank\">cancelable&nbsp;promises&nbsp;proposal</a>，不过这个提案被废弃了。</p><p style=\"text-indent: 0px; text-align: start;\">而&nbsp;AbortController&nbsp;是已经可以在浏览器使用的接口，顾名思义，这就是一个专门用于中止行为的控制器。<a href=\"https://link.segmentfault.com/?enc=TF1tlkMin3exNscogv3uYQ%3D%3D.Av7xfhDyWVwcuEgFXTt2%2FqbhEqbcZj5N%2ByzsaG7D8ocRZiumySuTsD9j3FAQ46L1Iouvu6ufovk5Kh50SXcO3DM1pAK7eAb7tu5gLBFsDzI%3D\" target=\"_blank\">mdn</a>&nbsp;的举例用的也是&nbsp;Ajax&nbsp;请求，不过是至潮至&nbsp;in&nbsp;的&nbsp;fetch，从中可见&nbsp;axios&nbsp;跟&nbsp;fetch&nbsp;的实践是一致的：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>function fetchVideo() {\n  controller = new AbortController() // 新建一个 controller\n  const signal = controller.signal\n  fetch(url, { signal }) // 在 fetch 方法传入 signal\n    .then(function (response) {\n      console.log('Download complete', response)\n    })\n    .catch(function (e) {\n      console.log('Download error: ' + e.message)\n    })\n}\n\nabortBtn.addEventListener('click', function () {\n  if (controller) controller.abort() // 调用 controller.abort 取消 fetch\n  console.log('Download aborted')\n})</code></pre><h2 style=\"text-indent: 0px; text-align: start;\">AbortController&nbsp;的其他用途</h2><p style=\"text-indent: 0px; text-align: start;\">当然&nbsp;AbortController&nbsp;不只有中止&nbsp;Ajax&nbsp;一个功能，通过查看&nbsp;<a href=\"https://link.segmentfault.com/?enc=pquEODTSfWU29aOXIHvDVA%3D%3D.TL2t1jewsCVcIxVetK5koHDl1Ni8L3GKZbvsQtXvO4I%3D\" target=\"_blank\">dom&nbsp;规范文档</a>还能看到两个使用示例：</p><p style=\"text-indent: 0px; text-align: start;\">一个比较实用的例子是用&nbsp;AbortController&nbsp;取消事件监听：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>dictionary AddEventListenerOptions : EventListenerOptions {\n  boolean passive = false;\n  boolean once = false;\n  AbortSignal signal;\n};</code></pre><p style=\"text-indent: 0px; text-align: start;\">通过向&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>AddEventListener</code></span>&nbsp;传入&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>signal</code></span>，运行&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>abort()</code></span>&nbsp;即可<strong>取消事件监听</strong>，这个方法对<strong>匿名</strong>回调函数尤其有用。</p><p style=\"text-indent: 0px; text-align: start;\">另一个例子是用于<strong>中止&nbsp;promise</strong>。这是一个比较简洁且自文档的方法……不过其实实现这个功能也不是非要&nbsp;AbortController&nbsp;才能做到，只要想办法拿到&nbsp;promise&nbsp;的&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>reject</code></span>&nbsp;就好了。我觉得这个例子的重点偏向于学会使用&nbsp;signal&nbsp;的&nbsp;onabort：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>const controller = new AbortController();\nconst signal = controller.signal;\n\nstartSpinner();\n\ndoAmazingness({ ..., signal })\n  .then(result =&gt; ...)\n  .catch(err =&gt; {\n    if (err.name == 'AbortError') return;\n    showUserErrorMessage();\n  })\n  .then(() =&gt; stopSpinner());\n\n// …\n\ncontroller.abort();\n\nfunction doAmazingness({signal}) {\n  return new Promise((resolve, reject) =&gt; {\n    signal.throwIfAborted();\n\n    // Begin doing amazingness, and call resolve(result) when done.\n    // But also, watch for signals:\n    signal.addEventListener('abort', () =&gt; {\n      // Stop doing amazingness, and:\n      reject(signal.reason);\n    });\n  });\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">总之，signal&nbsp;就是个简易发信器，而且功能偏向于取消某操作。如果在某种情况下不想自己实现一个&nbsp;pubsub&nbsp;对象的话，用这个就完事了。</p><p style=\"text-indent: 0px; text-align: start;\">AbortController&nbsp;的介绍就到此为止吧，不知道大家有没有逐渐忘记标题……最后是想讨论一下，取消&nbsp;Ajax&nbsp;到底有没有用？</p><h2 style=\"text-indent: 0px; text-align: start;\">取消还是不取消，这是个问题</h2><p style=\"text-indent: 0px; text-align: start;\">事实上，这个&nbsp;Ajax&nbsp;取消只是前端自说自话，后端并不知道要中止，发过去的请求还是要执行的，后端没有特殊处理的话&nbsp;10s&nbsp;的请求你取消了后端也仍然在费劲地跑。</p><p style=\"text-indent: 0px; text-align: start;\">那么在一些文章中看到的“优化”，所谓“取消请求，只保留最后一个”是否真的有意义呢？</p><p style=\"text-indent: 0px; text-align: start;\">分情况讨论，对于&nbsp;POST&nbsp;等修改数据的请求，每次发送即使返回慢，服务器也已经在处理了，取消上一个&nbsp;POST&nbsp;再重复发一个无疑是弱智行为。</p><p style=\"text-indent: 0px; text-align: start;\">对于&nbsp;GET，且仅针对某些极限操作，或许有一点效果，例如：获取一个超长&nbsp;table，结果没拿到，然后用户就用搜索快速返回少量数据并且渲染了，等到超长&nbsp;table&nbsp;真正返回就会覆盖掉搜索的数据，这个情况&nbsp;cancel&nbsp;是真的有效的。另外还有下载上传的取消，不过估计也很少会用到。</p><p style=\"text-indent: 0px; text-align: start;\">最后再说一个有道理但是事实上也是没什么用的好处：cancel&nbsp;之后能<strong>省一个请求位置</strong>，毕竟浏览器一个域名的同时请求数量是有限制的，更多情况下，比&nbsp;cancel&nbsp;更常见的&nbsp;timeout&nbsp;更实用。嗯……除非同时排着五六个超慢请求，否则轮转还是比较快的……</p><p style=\"text-indent: 0px; text-align: start;\">个人建议是，说到底这个所谓“取消”都是极特殊情况的特殊处理，知道这回事就好了，没有必要没事就在拦截器里整个取消操作。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31c"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c57fe74edbe7504484914c",
  "title": "从第三次技术革命看企业应用三大开发趋势",
  "cover": "",
  "body": "<div class='wang-editor'><p style=\"text-indent: 0px; text-align: start;\">有史以来的三次技术革命都无比波澜壮阔，不仅改变了人类文明的发展历程，也改变了我们每一个人的生活。</p><p style=\"text-indent: 0px; text-align: start;\">纺织革命是第一次工业革命的起点，以蒸汽机的发明与使用为标志，如马克思所言，\"蒸汽大王在前一世纪中，翻转了整个世界\"&nbsp;；紧接着，电机的问世和电力的使用将世界推入了\"电气时代\"；随着电力器械的发展，计算机的问世无疑将科技推上了新的高峰，生产力的几何增长，人类生活方式的根本性转变，都与计算机紧密相连，当前，第三次科技革命（又称第三次工业革命）正在向更深、更高层次发展。</p><p style=\"text-indent: 0px; text-align: start;\">那么，我们不禁要问，第四次科技革命会在何时开始？实际上，不少业内人士认为，第四次科技革命同时已悄然发轫兴起，它以互联网产业化、工业智能化等为标志，将带来更为深远的意义和影响。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">（图片来自网络）</p><p style=\"text-indent: 0px; text-align: start;\">而这场变革中，企业应用必定占有一席之地。在这里颠覆性的技术不断涌现，基于新技术的跨界竞争正引发行业巨变。</p><p style=\"text-indent: 0px; text-align: start;\">总的来说，这一过程中有三处趋势值得我们关注：</p><h2 style=\"text-indent: 0px; text-align: start;\">一、产业互联网的增速发展</h2><p style=\"text-indent: 0px; text-align: start;\">当前，无论是新零售、新金融，还是新制造，其本质都是互联网与传统产业的融合越来越深入，形成产业互联网。产业互联网基于互联网、大数据、人工智能、区块链等技术，对各个垂直产业的产业链和内部的价值链进行重塑和改造，从而形成互联网生态和形态，使传统产业朝着数字化的方向进化。随着&nbsp;5G&nbsp;的建设，产业互联网必将迎来一个增速发展的新阶段。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">（图片来自网络）</p><h2 style=\"text-indent: 0px; text-align: start;\">二、低代码技术的应用日趋广泛</h2><p style=\"text-indent: 0px; text-align: start;\">低代码开发是高级语言开发发展到一定阶段的必然产物，相较于高级语言开发，它有效解决了两个问题：一是随着软件技术的广泛应用出现的专业开发人员数量不足问题；二是“懂需求的人不懂开发，懂开发的人不懂需求”的现实困境。</p><p style=\"text-indent: 0px; text-align: start;\">低代码开发的应用前景非常广阔，根据国外相关媒体的报道，2018&nbsp;年全球低代码开发平台市场价值为&nbsp;56&nbsp;亿美元，预计到&nbsp;2024&nbsp;年将达到&nbsp;523&nbsp;亿美元，在预测期内的复合年增长率达到&nbsp;45.2%。</p><h2 style=\"text-indent: 0px; text-align: start;\">三、商业智能和数据分析技术的普及</h2><p style=\"text-indent: 0px; text-align: start;\">经过二十多年的发展，基于专业系统、主要面向大型企业、由专业人员使用的传统商业智能模式正在发生变化。随着环境的迅速变化和企业决策过程的加快，越来越多的企业决策者希望在业务系统中直接进行数据分析，并且能自主进行分析，提升决策效率。中小企业的信息化和数字化进程，加速了商业智能和数据分析技术的普及。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">(图片来源于网络)</p><h2 style=\"text-indent: 0px; text-align: start;\">总结</h2><p style=\"text-indent: 0px; text-align: start;\">随着软件技术的不断进步，我们可以发现上述几方面正以势如破竹之势不断发展。</p><p style=\"text-indent: 0px; text-align: start;\">开发者是技术发展的核心力量。开发者对于技术变革的重要不言而喻，我们也一直坚守“赋能开发者”的使命，不断为广大开发者提供更加便捷的工具、优质的服务。</p><p style=\"text-indent: 0px; text-align: start;\">而对于文内所提到的数据分析、商业智能、低代码等技术的具体落地实践项目，我们在这里为大家准备了免费的案例集——《企业数智化实践案例集》，感兴趣的同学搜索公主号“葡萄城社区”，回复关键词：案例集，并附上您的收件地址，我们将会为您送出印刷版案例集一本。</p><p style=\"text-indent: 0px; text-align: start;\">数量有限，先到先得！</p><p style=\"text-indent: 0px; text-align: start;\"><br></p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31c"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c5806b4edbe7504484915e",
  "title": "20个稀奇古怪的 JavaScript 表达式，你要挑战回答一下嘛",
  "cover": "",
  "body": "<div class='wang-editor'><p style=\"text-indent: 0px; text-align: start;\">JavaScript是一种非常容错的编程语言，许多在其他编程语言中不合法的表达式在JavaScript中都能正常工作。</p><p style=\"text-indent: 0px; text-align: start;\">这导致了很多奇怪的代码。你想挑战它吗？</p><h2 style=\"text-indent: 0px; text-align: start;\">挑战</h2><p style=\"text-indent: 0px; text-align: start;\">在这个挑战中，你将看到20个古怪表达式，并要猜出其输出结果。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>1.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>true + false</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>2.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>**1.**</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>3.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>[1, 2, 3] + [4, 5, 6]</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>4.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>0.2 + 0.1 === 0.3</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>5.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>10,2</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>6.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>!!\"\"</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>7.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>+!![]</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>8.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>true == \"true\"</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>9.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>010 - 03</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>10.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>\"\" - - \"\"</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>11.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>null + 0</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>12.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>0/0</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>13.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>1/0 === 10 ** 1000</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>14.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>true++</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>15.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>\"\" - 1</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>16.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>(null - 1) - \"1\"</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>17.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>38 * 4343 * 2342+ (“true” — 0)</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>18.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>5 + !5 + !!5</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>19.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>[] + [1] + 2</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>20.</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>1 + 2 + \"3\"</code></pre><h2 style=\"text-indent: 0px; text-align: start;\">结果和分析</h2><p style=\"text-indent: 0px; text-align: start;\"><strong>true&nbsp;+&nbsp;false</strong></p><p style=\"text-indent: 0px; text-align: start;\">试图在两个布尔值之间使用加法运算符（+）时，它们会被转换为数字。</p><p style=\"text-indent: 0px; text-align: start;\">而且我们都知道<span style=\"color: rgb(214, 51, 132);\"><code>true</code></span>应该被转换为<span style=\"color: rgb(214, 51, 132);\"><code>1</code></span>，<span style=\"color: rgb(214, 51, 132);\"><code>false</code></span>应该被转换为<span style=\"color: rgb(214, 51, 132);\"><code>0</code></span>。所以<span style=\"color: rgb(214, 51, 132);\"><code>true+false</code></span>返回<span style=\"color: rgb(214, 51, 132);\"><code>1</code></span>。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>[,,,].length</strong></p><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>[,,,]</code></span>&nbsp;输出一个有三个空槽的数组。最后一个逗号是尾部的逗号。</p><p style=\"text-indent: 0px; text-align: start;\">你可以这么想。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>[,]     ==&gt; [empty,]\n[,,]    ==&gt; [empty, empty,]\n[,,,]   ==&gt; [empty, empty, empty,]</code></pre><p style=\"text-indent: 0px; text-align: start;\">所以&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>[,,,].length</code></span>&nbsp;返回3。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>[1,&nbsp;2,&nbsp;3]&nbsp;+&nbsp;[4,&nbsp;5,&nbsp;6]</strong></p><p style=\"text-indent: 0px; text-align: start;\">当你试图在数组之间使用加法运算符（+）时，它们会被转换为字符串。</p><p style=\"text-indent: 0px; text-align: start;\">将一个数组转换为字符串时，数组的&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>toString()</code></span>&nbsp;方法被调用。<span style=\"color: rgb(214, 51, 132);\"><code>toString()</code></span>方法是JavaScript&nbsp;内部使用的，当一个数组需要显示为文本时，它将用逗号连接其元素。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>[1, 2, 3].toString() ==&gt; '1, 2, 3'\n[4, 5, 6].toString() ==&gt; '4, 5, 6'</code></pre><p style=\"text-indent: 0px; text-align: start;\">所以</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>[1, 2, 3] + [4, 5, 6] ==&gt; '1, 2, 3' + '4, 5, 6' ==&gt; \"1,2,34,5,6\"</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>0.2&nbsp;+&nbsp;0.1&nbsp;===&nbsp;0.3</strong></p><p style=\"text-indent: 0px; text-align: start;\">由于浮点数很难在计算机中准确表示，数学上的<span style=\"color: rgb(214, 51, 132);\"><code>0.1</code></span>和<span style=\"color: rgb(214, 51, 132);\"><code>0.2</code></span>在计算机中只能用近似的数字表示。</p><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>0.1+0.2</code></span>的结果不完全是<span style=\"color: rgb(214, 51, 132);\"><code>0.3</code></span>。不仅仅是JavaScript，其他编程语言也有同样的问题。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>10,&nbsp;2</strong></p><p style=\"text-indent: 0px; text-align: start;\">逗号（<span style=\"color: rgb(214, 51, 132);\"><code>,</code></span>）在JavaScript中也是一个合法的操作符，它评估每个操作数（从左到右），并返回最后一个操作数的值。</p><p style=\"text-indent: 0px; text-align: start;\">因此，10，2返回2</p><p style=\"text-indent: 0px; text-align: start;\"><strong>!!\"\"</strong></p><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>\"\"</code></span>是一个空字符串，它是一个虚值。</p><blockquote style=\"text-indent: 0px; text-align: start;\">注意：0、空字符串\"\"、null&nbsp;和undefined都是虚值。</blockquote><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>!</code></span>&nbsp;是逻辑上的&nbsp;\"非&nbsp;\"运算符，把&nbsp;true&nbsp;变成&nbsp;false，反之亦然。</p><p style=\"text-indent: 0px; text-align: start;\">如果我们使用两次<span style=\"color: rgb(214, 51, 132);\"><code>!</code></span>，也就是<span style=\"color: rgb(214, 51, 132);\"><code>!!</code></span>，它将把一个正常的值转换成一个布尔值。所以<span style=\"color: rgb(214, 51, 132);\"><code>!\"\"</code></span>返回&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>false</code></span>。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>+!![]</strong></p><p style=\"text-indent: 0px; text-align: start;\">数组都是真值，甚至是空数组。所以<span style=\"color: rgb(214, 51, 132);\"><code>!![]</code></span>将返回<span style=\"color: rgb(214, 51, 132);\"><code>true</code></span>。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>!![]; // -&gt; true</code></pre><p style=\"text-indent: 0px; text-align: start;\">而<span style=\"color: rgb(214, 51, 132);\"><code>+</code></span>号会将真值转换为其数字表示:&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>1</code></span>，所以&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>+!![]</code></span>&nbsp;返回&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>1</code></span>。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>true&nbsp;==&nbsp;\"true\"</strong></p><p style=\"text-indent: 0px; text-align: start;\">双等运算符（==）检查其两个操作数是否相等，并返回一个布尔值结果。</p><p style=\"text-indent: 0px; text-align: start;\">根据抽象的双等比较规则，这两个值在比较时都被转换为数字。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>true == \"true\" ==&gt; Number(true) == Number(\"true\") ==&gt; 1 == NaN</code></pre><p style=\"text-indent: 0px; text-align: start;\">所以，<span style=\"color: rgb(214, 51, 132);\"><code>ture&nbsp;==\"true\"&nbsp;</code></span>返回false。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>010&nbsp;-&nbsp;03</strong></p><p style=\"text-indent: 0px; text-align: start;\">这里有一个小小的技巧：如果一个数字以<span style=\"color: rgb(214, 51, 132);\"><code>0</code></span>开头，那么在JavaScript中它就被当作一个八进制数字。所以：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>010 - 03 ==&gt; 8 - 3 ==&gt; 5</code></pre><p style=\"text-indent: 0px; text-align: start;\">另外：</p><ul style=\"text-indent: 0px; text-align: start;\"><li>如果一个数字以0b开头，那么它在JavaScript中被视为二进制数字。</li><li>如果一个数字以0x开头，它在JavaScript中被当作一个十六进制数字。</li></ul><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\"><strong>\"\"--\"\"</strong></p><p style=\"text-indent: 0px; text-align: start;\">这看起来是一个错误的语法，但它确实工作正常。</p><p style=\"text-indent: 0px; text-align: start;\">空字符串可以被转换为布尔值false或数字值0。所以&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>-\"\"</code></span>&nbsp;为&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>0</code></span></p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\"><strong>null&nbsp;+&nbsp;0</strong></p><p style=\"text-indent: 0px; text-align: start;\">正如我们之前所说，<span style=\"color: rgb(214, 51, 132);\"><code>null</code></span>是一个虚值。它将被转换为布尔值<span style=\"color: rgb(214, 51, 132);\"><code>false</code></span>或数字值<span style=\"color: rgb(214, 51, 132);\"><code>0</code></span>。所以结果返回&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>0</code></span>。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>0/0</strong></p><p style=\"text-indent: 0px; text-align: start;\">这是一个非法的数学表达式。方程0/0没有任何有意义的数字答案，输出的结果只是<span style=\"color: rgb(214, 51, 132);\"><code>NaN</code></span>。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>1/0&nbsp;===&nbsp;10&nbsp;</strong>1000**</p><p style=\"text-indent: 0px; text-align: start;\">虽然<span style=\"color: rgb(214, 51, 132);\"><code>1/0</code></span>和之前一样也是一个非法的数学表达式。但是当除数不是<span style=\"color: rgb(214, 51, 132);\"><code>0</code></span>时，JavaScript认为这个表达式的结果是<span style=\"color: rgb(214, 51, 132);\"><code>Infinity</code></span>。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">而<span style=\"color: rgb(214, 51, 132);\"><code>10**1000</code></span>是一个很大数字，JS&nbsp;无法正确表示这个数字。(JavaScript中最高的整数值是<span style=\"color: rgb(214, 51, 132);\"><code>2^53-1</code></span>)。所以<span style=\"color: rgb(214, 51, 132);\"><code>10&nbsp;*&nbsp;1000</code></span>也被当作无限大(Infinity)。</p><p style=\"text-indent: 0px; text-align: start;\">无穷大总是等于另一个无穷大，所以<span style=\"color: rgb(214, 51, 132);\"><code>1/0&nbsp;===&nbsp;10&nbsp;**&nbsp;1000</code></span>返回&nbsp;true。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>true++</strong></p><p style=\"text-indent: 0px; text-align: start;\">这没有什么特别的，这只是一个语法错误。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\"><strong>\"\"-&nbsp;1</strong></p><p style=\"text-indent: 0px; text-align: start;\">虽然加法运算符（+）同时用于数字和字符串，但减法运算符（-）对字符串没有用处，所以JavaScript将其解释为数字之间的操作。一个空的字符串会被类型强制为0。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>\"\" - 1 ==&gt; Number(\"\") - 1 ==&gt; 0 - 1 ==&gt; -1</code></pre><p style=\"text-indent: 0px; text-align: start;\">所以&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>\"\"&nbsp;—&nbsp;1</code></span>&nbsp;返回&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>-1</code></span></p><p style=\"text-indent: 0px; text-align: start;\"><strong>(null&nbsp;-&nbsp;1)&nbsp;-&nbsp;\"1\"</strong></p><p style=\"text-indent: 0px; text-align: start;\">正如上面所说。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>null ==&gt;  0\n(null - 1) ==&gt; -1\n\"1\" ==&gt; 1</code></pre><p style=\"text-indent: 0px; text-align: start;\">所以&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>(null&nbsp;—&nbsp;1)&nbsp;—&nbsp;“1”</code></span>&nbsp;返回&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>-2</code></span></p><p style=\"text-indent: 0px; text-align: start;\"><em><strong>38&nbsp;4343&nbsp;2342+&nbsp;(\"true\"&nbsp;-&nbsp;0)</strong></em></p><p style=\"text-indent: 0px; text-align: start;\">你可能会怀疑JS是如此疯狂，以至于它将字符串&nbsp;\"true\"&nbsp;转换为布尔值&nbsp;true&nbsp;的数字表示。然而，它并没有那么疯狂。实际发生的情况是，它试图将字符串转换为数字，但失败了。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>Number(\"true\"); // -&gt; NaN</code></pre><p style=\"text-indent: 0px; text-align: start;\">在JavaScript的数字运算中，只要有一个值是NaN，运算的最终结果就一定是NaN。<span style=\"color: rgb(214, 51, 132);\"><code>38&nbsp;*&nbsp;4343&nbsp;*&nbsp;2342</code></span>只是一个烟雾弹。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>5&nbsp;+&nbsp;!5&nbsp;+&nbsp;!!5</strong></p><p style=\"text-indent: 0px; text-align: start;\">正如上面所说。</p><ul style=\"text-indent: 0px; text-align: start;\"><li>0、空字符串\"\"、null和undefined都是虚值。</li><li>非零的数字是真值。</li></ul><p style=\"text-indent: 0px; text-align: start;\">所以：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>!5 ==&gt; 0\n!!5 ==&gt; 1</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>[]&nbsp;+&nbsp;[1]&nbsp;+&nbsp;2</strong></p><p style=\"text-indent: 0px; text-align: start;\">试图在数组之间使用加法运算符（+）时，它们会被转换为字符串。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>[] ==&gt; ''\n[1] ==&gt; '1'\n[] + [1] ==&gt; '1'\n'1' + 2 ==&gt; '12'</code></pre><p style=\"text-indent: 0px; text-align: start;\">所以结果是'12'。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\"><strong>1&nbsp;+&nbsp;2&nbsp;+&nbsp;\"3\"</strong></p><p style=\"text-indent: 0px; text-align: start;\">JavaScript&nbsp;从左到右执行这些操作。当数字3与字符串3相加时，字符串连接将优先进行。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>1 + 2; // -&gt; 3\n3 + \"3\"; // -&gt; \"33\"</code></pre><h2 style=\"text-indent: 0px; text-align: start;\">总结</h2><p style=\"text-indent: 0px; text-align: start;\">坦率地说，这些挑战并没有为我胶们编码技能提供任何价值，所以不应该在实际项目中写这种代码</p><p style=\"text-indent: 0px; text-align: start;\">但是，把这些技巧作为朋友和同事之间的一些装13，不是一件非常有趣的事情吗？</p><p style=\"text-indent: 0px; text-align: start;\">作者：Marina&nbsp;Mosti&nbsp;译者：前端小智&nbsp;来源：medium</p><p style=\"text-indent: 0px; text-align: start;\">原文：<a href=\"https://link.segmentfault.com/?enc=yCJhNIgtXgLmy2DlFz64fg%3D%3D.BhHoZjLQ75%2FomlE%2BrTr%2BQGx%2Bg4rbbbHeEerkfM8M5KTPWEv6rSC5XM3ahK1pQ13CqIG9WZjo4ATcO8X%2Fk8lw1BqSHgn8RiD%2BTbXFq18SAPeTqXX4LAWmc8xa1iM0qJ8s1VXjid%2BKUtlWp%2FIwZcERjQ%3D%3D\" target=\"_blank\">https://medium.com/frontend-c...</a></p><p style=\"text-indent: 0px; text-align: start;\"><br></p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31c"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c5809d4edbe75044849170",
  "title": "Vue基础点梳理",
  "cover": "",
  "body": "<div class='wang-editor'><p style=\"text-indent: 0px; text-align: start;\">1、vue指令-v-model修饰符</p><p style=\"text-indent: 0px; text-align: start;\">语法:</p><p style=\"text-indent: 0px; text-align: start;\">v-model.修饰符=\"vue数据变量\"</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>.number   以parseFloat转成数字类型\n.trim     去除首尾空白字符\n.lazy     在失去焦点时触发更改而非inupt时</code></pre><p style=\"text-indent: 0px; text-align: start;\">2、计算属性</p><p style=\"text-indent: 0px; text-align: start;\">计算属性有缓存，提高渲染性能。</p><p style=\"text-indent: 0px; text-align: start;\">如果在页面上需要用到&nbsp;对现有的数据进行加工得到新数据，则时要使用计算属性。</p><p style=\"text-indent: 0px; text-align: start;\">写法：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>computed: {\n    \"属性名\": {\n        set(值){\n            \n        },\n        get() {\n            return \"值\"\n        }\n    }\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">3、vue监听器</p><p style=\"text-indent: 0px; text-align: start;\">可以监听数据（data/computed等）的值的改变。数据的值有类型：基本数据类型，引用数据类型</p><p style=\"text-indent: 0px; text-align: start;\">深度监听</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>watch: {\n    \"要监听的属性名\": {\n        immediate: true, // 立即执行\n        deep: true, // 深度监听复杂类型内变化\n        handler (newVal, oldVal) {\n            \n        }\n    }\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">4、scoped实现组件的私有样式</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>&lt;stype scoped&gt;\n  h2 {} // 样式只会在当前组件内生效\n&lt;/style&gt;</code></pre><p style=\"text-indent: 0px; text-align: start;\">5、父传子</p><p style=\"text-indent: 0px; text-align: start;\">父组件</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;child :users=\"user\"&gt;&lt;/child&gt; &lt;!-- 子组件绑定users变量--&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n \n&lt;script&gt;\nimport { child } from \"./child\";\nexport default {\n  components: { child },\n  data() {\n    return {\n      user: '张三'\n    };\n  }\n};\n&lt;/script&gt;</code></pre><p style=\"text-indent: 0px; text-align: start;\">子组件</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>&lt;template&gt;\n  &lt;div&gt;{{ users }}&lt;/div&gt;\n&lt;/template&gt;\n \n&lt;script&gt;\nexport default {\n  props: [\"users\"] //接收user值\n};\n&lt;/script&gt;</code></pre><p style=\"text-indent: 0px; text-align: start;\">6、子传父</p><p style=\"text-indent: 0px; text-align: start;\">子组件</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click=\"datas\"&gt;&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n \n&lt;script&gt;\nexport default {\n  methods: {\n    datas() {\n      this.$emit(\"info\", value); //$emit 的第一个参数是父组件自定义事件的方法名，后边的 “value” 是子组件要给父组件传递的数据 \n    }\n  }\n};\n&lt;/script&gt;</code></pre><p style=\"text-indent: 0px; text-align: start;\">父组件</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;child @info=\"getInfo\"&gt;&lt;/child&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n \n&lt;script&gt;\nimport { child } from \"./child\";\nexport default {\n  components: { child },\n  methods: {\n    getInfo(value) {\n      // value 就是子组件传递过来的数据\n    }\n  }\n};\n&lt;/script&gt;</code></pre><p style=\"text-indent: 0px; text-align: start;\">7、组件进阶&nbsp;-&nbsp;props校验</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>props: {\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\n    propA: Number,\n    // 多个可能的类型\n    propB: [String, Number],\n    // 必填的字符串\n    propC: {\n      type: String,\n      required: true\n    },\n    // 带有默认值的数字\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // 带有默认值的对象\n    propE: {\n      type: Object,\n      // 对象或数组默认值必须从一个工厂函数获取\n      default: function () {\n        return { message: 'hello' }\n      }\n    },\n    // 自定义验证函数\n    propF: {\n      validator: function (value) {\n        // 这个值必须匹配下列字符串中的一个\n        return ['success', 'warning', 'danger'].indexOf(value) !== -1\n      }\n    }\n  }</code></pre><p style=\"text-indent: 0px; text-align: start;\">8、组件进阶&nbsp;-&nbsp;动态组件</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>&lt;component :is=\"comName\"&gt;&lt;/component&gt; //comName是变量,值为需要切换的几个组件名</code></pre><p style=\"text-indent: 0px; text-align: start;\">9、组件进阶&nbsp;-&nbsp;keep-alive组件</p><p style=\"text-indent: 0px; text-align: start;\">用keep-alive内置的vue组件,&nbsp;让动态组件缓存而不是销毁</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>&lt;keep-alive&gt;\n    &lt;!-- vue内置的组件component, 可以动态显示组件 --&gt;\n    &lt;component :is=\"comName\"&gt;&lt;/component&gt;\n&lt;/keep-alive&gt;</code></pre><p style=\"text-indent: 0px; text-align: start;\">组件进阶-keep-alive组件-指定缓存</p><p style=\"text-indent: 0px; text-align: start;\">语法</p><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>include=\"组件名1,组件名2...\"</code></span><br><span style=\"color: rgb(214, 51, 132);\"><code>:include=\"['组件名1'，&nbsp;'组件名2']\"</code></span></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>&lt;keep-alive include=\"name1,name2\"&gt;\n    &lt;!-- vue内置的组件component, 可以动态显示组件 --&gt;\n    &lt;component :is=\"comName\"&gt;&lt;/component&gt;\n&lt;/keep-alive&gt;</code></pre><p style=\"text-indent: 0px; text-align: start;\">10、组件进阶&nbsp;-&nbsp;具名插槽</p><p style=\"text-indent: 0px; text-align: start;\">格式</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>定义：&lt;slot name=\"xxx\"&gt;\n\n使用：\n\n&lt;template #xxx&gt;&lt;/template&gt;;\n&lt;template v-slot:xxx&gt;&lt;/template&gt;</code></pre><p style=\"text-indent: 0px; text-align: start;\">11、自定义指令&nbsp;-&nbsp;基本使用</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>{\n  data(){},\n  methods: {},\n  directives: {\n    focus: { // 自定义指令名\n        inserted(el){ // 固定配置项 - 当指令插入到标签自动触发此函数\n            el.focus()\n        }\n    },\n  },\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">12、自定义指令&nbsp;-&nbsp;传值和更新</p><p style=\"text-indent: 0px; text-align: start;\">目标:&nbsp;使用自定义指令,&nbsp;传入一个值</p><p style=\"text-indent: 0px; text-align: start;\">需求:&nbsp;定义color指令-传入一个颜色,&nbsp;给标签设置文字颜色</p><p style=\"text-indent: 0px; text-align: start;\">main.js定义处修改一下</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>directives: {\n  \"color\":{\n    inserted(el, binding){ // 插入时触发此函数\n      el.style.color = binding.value;\n    },\n    update(el, binding){ // 更新绑定的变量时触发此函数=》手动更新\n      el.style.color = binding.value;\n    }\n  }\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">Direct.vue处更改一下</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>&lt;p v-color=\"theColor\" @click=\"changeColor\"&gt;使用v-color指令控制颜色, 点击变蓝&lt;/p&gt;\n\n&lt;script&gt;\n  data() {\n    return {\n      theColor: \"red\",\n    };\n  },\n  methods: {\n    changeColor() {\n      this.theColor = 'blue';\n    },\n  },\n&lt;/script&gt;</code></pre><p style=\"text-indent: 0px; text-align: start;\">总结:&nbsp;v-xxx,&nbsp;自定义指令,&nbsp;获取原生DOM,&nbsp;自定义操作</p><p style=\"text-indent: 0px; text-align: start;\">13、axios请求</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code> async loadData(){\n     const res= await axios.get(\"http://.......\")\n    // console.log(data);\n },\n created(){\n    this.loadData()\n }</code></pre><p><br></p></div>",
  "hit_num": 4,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31c"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c582904edbe750448491a7",
  "title": "react-router-middleware-plus开源啦 | 基于react-router v6的零成本式路由权限解决方案",
  "cover": "",
  "body": "<div class='wang-editor'><h2 style=\"text-indent: 0px; text-align: start;\">一、你的苦恼~~</h2><p style=\"text-indent: 0px; text-align: start;\">你还在为<span style=\"color: rgb(214, 51, 132);\"><code>react-router</code></span>的路由权限控制而烦恼吗？</p><p style=\"text-indent: 0px; text-align: start;\">你还在翻遍了社区react路由权限相关文章发现都是V4、V5版本的而烦恼吗？</p><p style=\"text-indent: 0px; text-align: start;\">你还在为自行适配react-router&nbsp;v6版本的权限步骤繁杂，多重鉴权逻辑嵌套而烦恼吗？</p><p style=\"text-indent: 0px; text-align: start;\">他来了！他来了！他带着礼物走来了！<a href=\"https://link.segmentfault.com/?enc=0U%2BJJ4zauVfwgFitmO2BHg%3D%3D.q57LkCmyOpr%2Baw%2F%2FPnF%2BibH%2B26ZSy%2BapoHDxZvy4YFJtmJzXbadv2E%2BZaZVOZZshf5L6JtM8uUrReSzvtC833A%3D%3D\" target=\"_blank\"><span style=\"color: inherit;\"><code>react-router-middleware-plus</code></span></a>专为解决你的烦恼而生！</p><h2 style=\"text-indent: 0px; text-align: start;\">二、<a href=\"https://link.segmentfault.com/?enc=BPGKAj23qVGIiAmRQsVElg%3D%3D.v8pXACDctydBzz0ZnOZgTcp5b7c%2BYmIVHldJw4iWp1DV%2FotTCmZxIOmBKXCPAwIATRX239Vbr8ZrCthCwsW%2FcQ%3D%3D\" target=\"_blank\">react-router-middleware-plus</a></h2><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>react-router-middleware-plus</code></span>是基于react-router&nbsp;v6的路由权限配置化解决方案，引入中间件<span style=\"color: rgb(214, 51, 132);\"><code>middleware</code></span>的概念，零成本式路由权限解决方案。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>路由组件声明：</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>/**\n * @method checkLogin\n * @description 鉴权-登录\n*/\nconst checkLogin = () =&gt; {\n  // 获取登录信息\n  const isLogin = !!localStorage.getItem('username')\n\n  if (!isLogin) {\n    navigate('/login', {\n      replace: true\n    })\n    // 未通过鉴权，返回false\n    return false;\n  }\n  \n  // 通过鉴权，返回true\n  return true\n}\n\n/**\n * @method checkRole\n * @description 鉴权-用户角色\n*/\nconst checkRole = () =&gt; {\n  // 根据自己的页面，判断处理，async/await异步拉取用户数据即可。\n  const isAdmin = localStorage.getItem('role') === 'admin';\n\n  if (!isAdmin) {\n    navigate('/', {\n      replace: true\n    })\n    // 未通过鉴权，返回false\n    return false;\n  }\n  \n  // 通过鉴权，返回true\n  return true\n}\n\n/**\n * @description 路由配置\n * \n*/\nconst routesConfig = [\n  {\n    path: '/',\n    key: 'index',\n    element: &lt;App&gt;&lt;/App&gt;,\n    children: [\n      {\n        index: true,\n        key: 'home',\n        element: &lt;Home&gt;&lt;/Home&gt;\n      },\n      {\n        path: 'admin',\n        key: 'admin',\n        // 中间件，允许配置一个或多个\n        middleware: [\n          checkLogin,\n          checkLogin,\n          // auth3\n          // ...\n        ],\n        element: &lt;Admin&gt;&lt;/Admin&gt;\n      }\n    ]\n  },\n  {\n    path: '/login',\n    key: 'login',\n    element: &lt;Login&gt;&lt;/Login&gt;\n  },\n]</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>middleware：</strong></p><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>midleware</code></span>定义为中间件的概念，是包含了一个或多个用户自定义的<span style=\"color: rgb(214, 51, 132);\"><code>auth&nbsp;callback</code></span>的数组，在页面路由加载时，会依次执行中间件中的<span style=\"color: rgb(214, 51, 132);\"><code>auth&nbsp;callback</code></span>。如果你想拦截路由在<span style=\"color: rgb(214, 51, 132);\"><code>auth&nbsp;callback</code></span>中直接返回false即可，如果允许通过返回true即可。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>middleware处理流程图：</strong></p><h2 style=\"text-indent: 0px; text-align: start;\">四、Props介绍</h2><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>react-router-middleware-plus</code></span>在使用时和react-router-dom中的<span style=\"color: rgb(214, 51, 132);\"><code>useRoutes</code></span>是一致的。</p><table style=\"width: auto; text-align: start;\"><tbody><tr><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: -webkit-match-parent;\">属性</th><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: -webkit-match-parent;\">类型</th><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: -webkit-match-parent;\">描述</th><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: -webkit-match-parent;\">是否可选</th></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">routes</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">RoutesMiddlewareObject[]</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">路由配置，在RoutesObject类型上扩展了<span style=\"color: rgb(214, 51, 132);\"><code>middleware</code></span>属性</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">否</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">locationArg</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Partial\\&lt;Location\\&gt;&nbsp;\\</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">string</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">用户传入的location对象</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">可选</td></tr></tbody></table><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>// 1. Component 渲染\n// return &lt;ReactRouterMiddleware routes={routes}&gt;&lt;/ReactRouterMiddleware&gt;;\n\n// 2. Hook渲染\nreturn useMiddlewareRoutes(routes);</code></pre><h2 style=\"text-indent: 0px; text-align: start;\">五、middleware&nbsp;callback介绍</h2><p style=\"text-indent: 0px; text-align: start;\">这里提供下类型声明，<span style=\"color: rgb(214, 51, 132);\"><code>MiddlewareFunction</code></span>和<span style=\"color: rgb(214, 51, 132);\"><code>RoutesMiddlewareObject</code></span>。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>export interface MiddlewareFunction {\n  (): boolean\n}\n\nexport interface RoutesMiddlewareObject extends RouteObject  {\n  /**\n   * @description 权限处理的middleware callback[]\n   * \n  */\n  middleware?: MiddlewareFunction[];\n  /**\n   * @description 子路由\n   * \n  */\n  children?: RoutesMiddlewareObject[];\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">再次强调一下，如果拦截路由就在<span style=\"color: rgb(214, 51, 132);\"><code>MiddlewareFunction</code></span>中返回<span style=\"color: rgb(214, 51, 132);\"><code>false</code></span>,如果通过就是返回<span style=\"color: rgb(214, 51, 132);\"><code>true</code></span>。</p><h2 style=\"text-indent: 0px; text-align: start;\">六、求Star</h2><p style=\"text-indent: 0px; text-align: start;\">如果你通过使用<span style=\"color: rgb(214, 51, 132);\"><code>react-router-middleware-plus</code></span>解决了路由配置鉴权问题，欢迎你点个<span style=\"color: rgb(214, 51, 132);\"><code>Star</code></span>。</p><p style=\"text-indent: 0px; text-align: start;\"><a href=\"https://link.segmentfault.com/?enc=hZOaBPlosDX3yLyU5%2BXnUA%3D%3D.6h%2FW4chPqajQn0T0vDNIXQV2jFvYAdTPB92HKSMwAvFi1oYtTyXwKldStB46%2Fe89XynuTlaqBDu4bonfS7LWpA%3D%3D\" target=\"_blank\">GitHub仓库地址</a></p><p style=\"text-indent: 0px; text-align: start;\"><a href=\"https://link.segmentfault.com/?enc=rjRYN0aP7zZAuDSnvHD%2B9g%3D%3D.atHlWpOxpzw6E%2BTfwZQxNY30T%2FIeer9Dz8dSYAR5JdzSjszhKxdNJXPkUl3%2BMOs6ERUUsmpZCaObsaaOMKGp4Q%3D%3D\" target=\"_blank\">NPM包地址</a></p><p style=\"text-indent: 0px; text-align: start;\">同时非常欢迎小伙伴们提<span style=\"color: rgb(214, 51, 132);\"><code>Issues</code></span>和<span style=\"color: rgb(214, 51, 132);\"><code>PR</code></span>。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31d"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c582c54edbe750448491b9",
  "title": "构建基于React18的电子表格程序",
  "cover": "",
  "body": "<div class='wang-editor'><h2 style=\"text-indent: 0px; text-align: start;\">背景</h2><p style=\"text-indent: 0px; text-align: start;\">2022年3月29日，React正式发布18.0.0。本次升级内容包括开箱即用的改进，如自动批处理、新的API（如startTransition）和支持Suspense&nbsp;的流式服务器端渲染。关于此次发布新增的功能可以参考<strong>官方文档</strong>。</p><p style=\"text-indent: 0px; text-align: start;\">作为一个构建用户界面的JavaScript&nbsp;库，React一直被认为是一个严谨而优秀的前端框架，随着新版本的发行，使用热度也是越来越高。一个热知识，在大部分使用React开发的业务系统中，基本对表格都有需求。大部分情况下，我们使用react集成antd就可以完成一些常规的表格需求。但是在普通的表格中，如果要做一些公式函数的计算，或者在表格内部使用一些图表等功能时，这种常规的行列表就很难满足需求了。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">除此之外，虽然React中使用了虚拟DOM及DOM&nbsp;DIFF算法，但如果表格中数据量大且需要经常性修改更新时，浏览器性能并不会太好。</p><p style=\"text-indent: 0px; text-align: start;\">因此，为了更好地满足业务系统中复杂的表格需求，本文将为大家介绍如何基于React18，构建一个功能更加强大的前端电子表格系统。</p><h2 style=\"text-indent: 0px; text-align: start;\">实战</h2><p style=\"text-indent: 0px; text-align: start;\">首先，我们需要创建一个react项目，可以使用<strong>create-react-app</strong>或者<strong>Vite</strong>来创建。但由于Vite&nbsp;使用&nbsp;<strong>esbuild</strong>&nbsp;<strong>预构建依赖</strong>，esbuild&nbsp;使用Go&nbsp;编写，相比较于JavaScript&nbsp;编写的打包器预构建依赖快10-100&nbsp;倍，整体上来说，使用效率要高于cra。因此本文使用Vite来创建React项目。需要注意的是，使用Vite需要Node的版本高于12，如果Node的版本过低，注意升级Node哦。</p><p style=\"text-indent: 0px; text-align: start;\">进入想要创建项目的目标文件夹之后，根据自己用的工具，执行以下命令的一种，即可创建一个最简单的React项目：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code># npm 6.x \nnpm create vite@latest vite-react --template react\n\n# npm 7+, extra double-dash is needed:\nnpm create vite@latest vite-react --template react\n\n# yarn\nyarn create vite vite-react --template react\n\n# pnpm\npnpm create vite vite-react -- --template react\n</code></pre><p style=\"text-indent: 0px; text-align: start;\">上述命令中vite-react表示创建的工程名称，--template表示创建项目时使用的模板，react模板默认使用js，如果要使用ts，需要将--template&nbsp;react&nbsp;替换为--template&nbsp;react-ts。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">创建完成之后，进入到项目目录，执行npm&nbsp;install，依赖资源安装完成之后，执行npm&nbsp;run&nbsp;dev，项目即可启动。</p><p style=\"text-indent: 0px; text-align: start;\">当然，这些命令在创建项目完成之后，终端都会有提示，如上图所示。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">打开package.json，可以看到React的版本为18.0.0的最新版，在创建项目时，默认都会使用最新版本的React，如上图。</p><p style=\"text-indent: 0px; text-align: start;\">项目启动之后，app.jsx中会有很多不需要的内容，大家可以自行删掉，构建一个最简洁的项目。接下来我们引入前端表格组件，在package.json中添加以下代码（紫色内容），之后执行npm&nbsp;install，安装新增的依赖资源：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>\"dependencies\": {\n    \"react\": \"^18.0.0\",\n    \"react-dom\": \"^18.0.0\",\n    \"@grapecity/spread-sheets\": \"15.0.7\",\n    \"@grapecity/spread-sheets-react\": \"15.0.7\",\n    \"@grapecity/spread-excelio\": \"15.0.7\",\n    \"@grapecity/spread-sheets-charts\": \"15.0.7\",\n    \"@grapecity/spread-sheets-print\": \"15.0.7\",\n    \"@grapecity/spread-sheets-pdf\": \"15.0.7\",\n    \"@grapecity/spread-sheets-barcode\": \"15.0.7\",\n    \"@grapecity/spread-sheets-shapes\": \"15.0.7\",\n    \"@grapecity/spread-sheets-resources-ko\": \"15.0.7\",\n    \"@grapecity/spread-sheets-resources-ja\": \"15.0.7\",\n    \"@grapecity/spread-sheets-resources-zh\": \"15.0.7\",\n    \"@grapecity/spread-sheets-languagepackages\": \"15.0.7\",\n    \"@grapecity/spread-sheets-pivot-addon\": \"15.0.7\",\n    \"@grapecity/spread-sheets-designer\": \"15.0.7\",\n    \"@grapecity/spread-sheets-designer-resources-cn\": \"15.0.7\",\n    \"@grapecity/spread-sheets-designer-react\": \"15.0.7\",\n    \"@grapecity/spread-sheets-tablesheet\": \"15.0.7\"\n  },\n</code></pre><p style=\"text-indent: 0px; text-align: start;\">依赖安装之后，我们需要创建两个jsx文件，用来引入SpreadJS的不同部分，OnlineSpread表示当前组件为SpreadJS运行时组件，实现该组件的核心代码如下所示：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>import {Component} from 'react'\nimport GC from '@grapecity/spread-sheets';\nimport '@grapecity/spread-sheets-resources-zh';\nGC.Spread.Common.CultureManager.culture(\"h-zcn\");\nimport { SpreadSheets, Worksheet, Column } from '@grapecity/spread-sheets-react';\n\n\nexport default class OnlineSpread extends Component {\n    constructor(props) {\n        super(props);\n        this.spread = null;\n    }\n    initSpread(spread) {\n        this.spread = spread;\n         //设置当前spread中工作表的数量\n        this.spread.setSheetCount(2)\n        //获取第一个工作表\n        let sheet = spread.getSheet(0)   //or let sheet = spread.getSheetFromName('Sheet1')\n        //设置列宽\n        sheet.setColumnWidth(0,150)    //第一个参数为列索引，第二个参数为列宽\n\n\n        //单个单元格设置值\n        sheet.setValue(0,0,'Hello Grapecity')   //参数依次表示行索引、列索引、内容\n\n\n        //设置单元格公式\n        sheet.setFormula(0,1,'=SUM(A2:A5)')      //参数依次为行索引、列索引、公式\n\n\n        //设置区域内容\n        //表示从行索引为2，列索引为0的单元格开始,设置2行3列的数据\n        sheet.setArray(2,0,[[1,'hello','grapecity'],[2,'hello','javascript']])  \n\n\n        //设置文字颜色\n        sheet.getCell(2,1).foreColor('#f00')\n    }\n\n\n    render(){\n        return(\n            &lt;SpreadSheets workbookInitialized={spread=&gt;this.initSpread(spread)}&gt;\n                &lt;Worksheet&gt;\n                &lt;/Worksheet&gt;\n            &lt;/SpreadSheets&gt;\n        )\n    }\n   \n}\n\n</code></pre><p style=\"text-indent: 0px; text-align: start;\">在app.jsx中引入OnlineSpread，页面展示效果如下：</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">接下来，我们需要引入包含工具栏的部分，新建一个OnlineDesigner.jsx，核心代码如下：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>import { Component, PropsWithChildren, ReactNode } from 'react'\nimport '@grapecity/spread-sheets-designer-resources-cn';\nimport \"@grapecity/spread-sheets/styles/gc.spread.sheets.excel2013white.css\"\nimport '@grapecity/spread-sheets-designer/styles/gc.spread.sheets.designer.min.css'\nimport \"@grapecity/spread-sheets-tablesheet\";\nimport \"@grapecity/spread-sheets-barcode\";\nimport \"@grapecity/spread-sheets-charts\";\nimport \"@grapecity/spread-sheets-shapes\";\nimport \"@grapecity/spread-sheets-languagepackages\";\nimport \"@grapecity/spread-sheets-print\";\nimport \"@grapecity/spread-sheets-pdf\";\nimport \"@grapecity/spread-sheets-pivot-addon\";\nimport \"@grapecity/spread-sheets-resources-zh\";\nimport \"@grapecity/spread-sheets-designer-resources-cn\";\nimport * as GCDesigner from '@grapecity/spread-sheets-designer';\nimport \"@grapecity/spread-sheets-resources-zh\"\nimport GC from \"@grapecity/spread-sheets\"\nimport { Designer } from '@grapecity/spread-sheets-designer-react';\nGC.Spread.Common.CultureManager.culture('zh-cn')\n\n\n\n\nexport default class OnlineDesigner extends Component{\n  constructor(props){\n    super(props)\n    this.designer = null\n  }\n\n\n  designerInitialized = (designer) =&gt; {\n    this.designer = designer\n    console.log(designer)\n    // 获取与designer相关联的工作簿(Spread)\n    let spread = this.designer.getWorkbook()\n    let sheet = spread.getActiveSheet()\n    //设置数值\n    sheet.setValue(0,0,'Hello Grapecity')\n    //设置行高\n    sheet.setColumnWidth(0,120)\n    //设置区域内容\n    sheet.setArray(1,0,[[2,3,5]])\n    //设置公式\n    sheet.setFormula(3,0,'=sum(A2:C2)')\n\n\n  }\n\n\n  render(){\n      return(\n          &lt;Designer\n            spreadOptions={{sheetCount: 3}}\n            styleInfo={{height: '98vh'}}\n            designerInitialized = {this.designerInitialized}\n          /&gt;\n      )\n  }\n}\n\n</code></pre><p style=\"text-indent: 0px; text-align: start;\">在app.jsx中引入OnlineDesigner,页面中显示如下：</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">到这里我们就正式完成基于React18构件纯前端表格，在该表格上，我们可以继续设置大量数据、公式，也可以实现报表设计，报表设计操作形式与Excel类似。</p><p style=\"text-indent: 0px; text-align: start;\">Demo下载地址：<strong>https://github.com/GrapeCityXA/SpreadJS\\_vite\\_react18</strong></p><p style=\"text-indent: 0px; text-align: start;\">更多demo体验：</p><p style=\"text-indent: 0px; text-align: start;\"><a href=\"https://link.segmentfault.com/?enc=SCrK5d5gLMwnkcKPjLce%2BA%3D%3D.AQG4IaPT%2B8VpO1oJHPii6M1sML2SCawcZKVb9xy8pgfetePVa4Za1y3B58UI%2BuYc47zWMtgjc5oBeg3JIDeUN%2FrZnLaUUb%2BZK2NMml1v1fs%3D\" target=\"_blank\">https://demo.grapecity.com.cn...</a></p><p style=\"text-indent: 0px; text-align: start;\"><br></p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31d"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c5833c4edbe750448491cb",
  "title": "JS自动生成24小时时间区间，时间跨度为60或30分钟",
  "cover": "",
  "body": "<div class='wang-editor'><h3 style=\"text-indent: 0px; text-align: start;\">1、时间跨度为60分钟</h3><h4 style=\"text-indent: 0px; text-align: start;\">（1）时间区间为字符串</h4><p style=\"text-indent: 0px; text-align: start;\">有时候可能需要用到24小时的时间区间，跨度为60分钟，比如下面这样的：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>['00:00 - 01:00', '01:00 - 02:00', '02:00 - 03:00', '03:00 - 04:00', '04:00 - 05:00', '05:00 - 06:00', '06:00 - 07:00', '07:00 - 08:00', '08:00 - 09:00', '09:00 - 10:00', '10:00 - 11:00', '11:00 - 12:00', '12:00 - 13:00', '13:00 - 14:00', '14:00 - 15:00', '15:00 - 16:00', '16:00 - 17:00', '17:00 - 18:00', '18:00 - 19:00', '19:00 - 20:00', '20:00 - 21:00', '21:00 - 22:00', '22:00 - 23:00', '23:00 - 24:00']</code></pre><p style=\"text-indent: 0px; text-align: start;\">如果手动去写，则有点麻烦，这个时候可以使用一个简单的&nbsp;JS&nbsp;函数去自动生成，示例代码如下：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>function generateTimes() {\n    let timeArrays = new Array(24).fill(\"\");\n\n    timeArrays.forEach((item, index) =&gt; timeArrays[index] = (index &lt; 10 ? '0' + index : index) + ':00' + ' - ' + ((index + 1) &lt; 10 ? '0' + (index + 1) : (index + 1)) + ':00');\n\n    return timeArrays;\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">当然，上面的方法，也可以简写成下面这样的，只需要一行代码即可</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>let timeArrays = new Array(24).fill('').map((item, index) =&gt; (index &lt; 10 ? '0' + index : index) + ':00' + ' - ' + ((index + 1) &lt; 10 ? '0' + (index + 1) : (index + 1)) + ':00');</code></pre><h4 style=\"text-indent: 0px; text-align: start;\">（2）时间区间为数组</h4><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>let timeArrays = new Array(24).fill(['', '']).map((item, index) =&gt; [(index &lt; 10 ? '0' + index : index) + ':00', ((index + 1) &lt; 10 ? '0' + (index + 1) : (index + 1)) + ':00']);\nconsole.log(JSON.stringify(timeArrays));</code></pre><p style=\"text-indent: 0px; text-align: start;\">生成的时间区间如下：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>[[\"00:00\",\"01:00\"],[\"01:00\",\"02:00\"],[\"02:00\",\"03:00\"],[\"03:00\",\"04:00\"],[\"04:00\",\"05:00\"],[\"05:00\",\"06:00\"],[\"06:00\",\"07:00\"],[\"07:00\",\"08:00\"],[\"08:00\",\"09:00\"],[\"09:00\",\"10:00\"],[\"10:00\",\"11:00\"],[\"11:00\",\"12:00\"],[\"12:00\",\"13:00\"],[\"13:00\",\"14:00\"],[\"14:00\",\"15:00\"],[\"15:00\",\"16:00\"],[\"16:00\",\"17:00\"],[\"17:00\",\"18:00\"],[\"18:00\",\"19:00\"],[\"19:00\",\"20:00\"],[\"20:00\",\"21:00\"],[\"21:00\",\"22:00\"],[\"22:00\",\"23:00\"],[\"23:00\",\"24:00\"]]</code></pre><h4 style=\"text-indent: 0px; text-align: start;\">（3）时间区间为对象</h4><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>let timeArrays = new Array(24).fill({}).map((item, index) =&gt; {\n    return {\n        start: (index &lt; 10 ? '0' + index : index) + ':00',\n        end: ((index + 1) &lt; 10 ? '0' + (index + 1) : (index + 1)) + ':00'\n    }\n});\nconsole.log(JSON.stringify(timeArrays));</code></pre><p style=\"text-indent: 0px; text-align: start;\">生成的时间区间如下：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>[{\"start\":\"00:00\",\"end\":\"01:00\"},{\"start\":\"01:00\",\"end\":\"02:00\"},{\"start\":\"02:00\",\"end\":\"03:00\"},{\"start\":\"03:00\",\"end\":\"04:00\"},{\"start\":\"04:00\",\"end\":\"05:00\"},{\"start\":\"05:00\",\"end\":\"06:00\"},{\"start\":\"06:00\",\"end\":\"07:00\"},{\"start\":\"07:00\",\"end\":\"08:00\"},{\"start\":\"08:00\",\"end\":\"09:00\"},{\"start\":\"09:00\",\"end\":\"10:00\"},{\"start\":\"10:00\",\"end\":\"11:00\"},{\"start\":\"11:00\",\"end\":\"12:00\"},{\"start\":\"12:00\",\"end\":\"13:00\"},{\"start\":\"13:00\",\"end\":\"14:00\"},{\"start\":\"14:00\",\"end\":\"15:00\"},{\"start\":\"15:00\",\"end\":\"16:00\"},{\"start\":\"16:00\",\"end\":\"17:00\"},{\"start\":\"17:00\",\"end\":\"18:00\"},{\"start\":\"18:00\",\"end\":\"19:00\"},{\"start\":\"19:00\",\"end\":\"20:00\"},{\"start\":\"20:00\",\"end\":\"21:00\"},{\"start\":\"21:00\",\"end\":\"22:00\"},{\"start\":\"22:00\",\"end\":\"23:00\"},{\"start\":\"23:00\",\"end\":\"24:00\"}]</code></pre><h3 style=\"text-indent: 0px; text-align: start;\">2、时间跨度为30分钟</h3><p style=\"text-indent: 0px; text-align: start;\">如果时间跨度为30分钟，也就是说1天24小时，需要分成48个时间区间。</p><h4 style=\"text-indent: 0px; text-align: start;\">（1）时间区间为字符串</h4><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>let timeArrays = new Array(48).fill('').map((item, index) =&gt; {\n    let startVal = index * 30;\n    let endVal = (index + 1) * 30;\n    let startHour = Math.floor((startVal / 60));\n    let startMinute = (startVal % 60);\n    let endHour = Math.floor((endVal / 60));\n    let endMinute = (endVal % 60);\n    let startTime = ((startHour &lt; 10) ? ('0' + startHour) : startHour) + ':' + (startMinute === 0 ? '00' : startMinute);\n    let endTime = ((endHour &lt; 10) ? ('0' + endHour) : endHour) + ':' + (endMinute === 0 ? '00' : endMinute);\n    \n    return startTime + ' - ' + endTime;\n});\nconsole.log(timeArrays);</code></pre><p style=\"text-indent: 0px; text-align: start;\">生成的时间区间如下：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>['00:00 - 00:30', '00:30 - 01:00', '01:00 - 01:30', '01:30 - 02:00', '02:00 - 02:30', '02:30 - 03:00', '03:00 - 03:30', '03:30 - 04:00', '04:00 - 04:30', '04:30 - 05:00', '05:00 - 05:30', '05:30 - 06:00', '06:00 - 06:30', '06:30 - 07:00', '07:00 - 07:30', '07:30 - 08:00', '08:00 - 08:30', '08:30 - 09:00', '09:00 - 09:30', '09:30 - 10:00', '10:00 - 10:30', '10:30 - 11:00', '11:00 - 11:30', '11:30 - 12:00', '12:00 - 12:30', '12:30 - 13:00', '13:00 - 13:30', '13:30 - 14:00', '14:00 - 14:30', '14:30 - 15:00', '15:00 - 15:30', '15:30 - 16:00', '16:00 - 16:30', '16:30 - 17:00', '17:00 - 17:30', '17:30 - 18:00', '18:00 - 18:30', '18:30 - 19:00', '19:00 - 19:30', '19:30 - 20:00', '20:00 - 20:30', '20:30 - 21:00', '21:00 - 21:30', '21:30 - 22:00', '22:00 - 22:30', '22:30 - 23:00', '23:00 - 23:30', '23:30 - 24:00']</code></pre><h4 style=\"text-indent: 0px; text-align: start;\">（2）时间区间为数组</h4><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>let timeArrays = new Array(48).fill(['', '']).map((item, index) =&gt; {\n    let startVal = index * 30;\n    let endVal = (index + 1) * 30;\n    let startHour = Math.floor((startVal / 60));\n    let startMinute = (startVal % 60);\n    let endHour = Math.floor((endVal / 60));\n    let endMinute = (endVal % 60);\n    let startTime = ((startHour &lt; 10) ? ('0' + startHour) : startHour) + ':' + (startMinute === 0 ? '00' : startMinute);\n    let endTime = ((endHour &lt; 10) ? ('0' + endHour) : endHour) + ':' + (endMinute === 0 ? '00' : endMinute);\n    \n    return [startTime, endTime];\n});\nconsole.log(JSON.stringify(timeArrays));</code></pre><p style=\"text-indent: 0px; text-align: start;\">生成的时间区间如下：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>[[\"00:00\",\"00:30\"],[\"00:30\",\"01:00\"],[\"01:00\",\"01:30\"],[\"01:30\",\"02:00\"],[\"02:00\",\"02:30\"],[\"02:30\",\"03:00\"],[\"03:00\",\"03:30\"],[\"03:30\",\"04:00\"],[\"04:00\",\"04:30\"],[\"04:30\",\"05:00\"],[\"05:00\",\"05:30\"],[\"05:30\",\"06:00\"],[\"06:00\",\"06:30\"],[\"06:30\",\"07:00\"],[\"07:00\",\"07:30\"],[\"07:30\",\"08:00\"],[\"08:00\",\"08:30\"],[\"08:30\",\"09:00\"],[\"09:00\",\"09:30\"],[\"09:30\",\"10:00\"],[\"10:00\",\"10:30\"],[\"10:30\",\"11:00\"],[\"11:00\",\"11:30\"],[\"11:30\",\"12:00\"],[\"12:00\",\"12:30\"],[\"12:30\",\"13:00\"],[\"13:00\",\"13:30\"],[\"13:30\",\"14:00\"],[\"14:00\",\"14:30\"],[\"14:30\",\"15:00\"],[\"15:00\",\"15:30\"],[\"15:30\",\"16:00\"],[\"16:00\",\"16:30\"],[\"16:30\",\"17:00\"],[\"17:00\",\"17:30\"],[\"17:30\",\"18:00\"],[\"18:00\",\"18:30\"],[\"18:30\",\"19:00\"],[\"19:00\",\"19:30\"],[\"19:30\",\"20:00\"],[\"20:00\",\"20:30\"],[\"20:30\",\"21:00\"],[\"21:00\",\"21:30\"],[\"21:30\",\"22:00\"],[\"22:00\",\"22:30\"],[\"22:30\",\"23:00\"],[\"23:00\",\"23:30\"],[\"23:30\",\"24:00\"]]</code></pre><h4 style=\"text-indent: 0px; text-align: start;\">（3）时间区间为对象</h4><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>let timeArrays = new Array(48).fill(['', '']).map((item, index) =&gt; {\n    let startVal = index * 30;\n    let endVal = (index + 1) * 30;\n    let startHour = Math.floor((startVal / 60));\n    let startMinute = (startVal % 60);\n    let endHour = Math.floor((endVal / 60));\n    let endMinute = (endVal % 60);\n    let startTime = ((startHour &lt; 10) ? ('0' + startHour) : startHour) + ':' + (startMinute === 0 ? '00' : startMinute);\n    let endTime = ((endHour &lt; 10) ? ('0' + endHour) : endHour) + ':' + (endMinute === 0 ? '00' : endMinute);\n    \n    return {\n        start: startTime,\n        end: endTime\n    };\n});\nconsole.log(JSON.stringify(timeArrays));</code></pre><p style=\"text-indent: 0px; text-align: start;\">生成的时间区间如下：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>[{\"start\":\"00:00\",\"end\":\"00:30\"},{\"start\":\"00:30\",\"end\":\"01:00\"},{\"start\":\"01:00\",\"end\":\"01:30\"},{\"start\":\"01:30\",\"end\":\"02:00\"},{\"start\":\"02:00\",\"end\":\"02:30\"},{\"start\":\"02:30\",\"end\":\"03:00\"},{\"start\":\"03:00\",\"end\":\"03:30\"},{\"start\":\"03:30\",\"end\":\"04:00\"},{\"start\":\"04:00\",\"end\":\"04:30\"},{\"start\":\"04:30\",\"end\":\"05:00\"},{\"start\":\"05:00\",\"end\":\"05:30\"},{\"start\":\"05:30\",\"end\":\"06:00\"},{\"start\":\"06:00\",\"end\":\"06:30\"},{\"start\":\"06:30\",\"end\":\"07:00\"},{\"start\":\"07:00\",\"end\":\"07:30\"},{\"start\":\"07:30\",\"end\":\"08:00\"},{\"start\":\"08:00\",\"end\":\"08:30\"},{\"start\":\"08:30\",\"end\":\"09:00\"},{\"start\":\"09:00\",\"end\":\"09:30\"},{\"start\":\"09:30\",\"end\":\"10:00\"},{\"start\":\"10:00\",\"end\":\"10:30\"},{\"start\":\"10:30\",\"end\":\"11:00\"},{\"start\":\"11:00\",\"end\":\"11:30\"},{\"start\":\"11:30\",\"end\":\"12:00\"},{\"start\":\"12:00\",\"end\":\"12:30\"},{\"start\":\"12:30\",\"end\":\"13:00\"},{\"start\":\"13:00\",\"end\":\"13:30\"},{\"start\":\"13:30\",\"end\":\"14:00\"},{\"start\":\"14:00\",\"end\":\"14:30\"},{\"start\":\"14:30\",\"end\":\"15:00\"},{\"start\":\"15:00\",\"end\":\"15:30\"},{\"start\":\"15:30\",\"end\":\"16:00\"},{\"start\":\"16:00\",\"end\":\"16:30\"},{\"start\":\"16:30\",\"end\":\"17:00\"},{\"start\":\"17:00\",\"end\":\"17:30\"},{\"start\":\"17:30\",\"end\":\"18:00\"},{\"start\":\"18:00\",\"end\":\"18:30\"},{\"start\":\"18:30\",\"end\":\"19:00\"},{\"start\":\"19:00\",\"end\":\"19:30\"},{\"start\":\"19:30\",\"end\":\"20:00\"},{\"start\":\"20:00\",\"end\":\"20:30\"},{\"start\":\"20:30\",\"end\":\"21:00\"},{\"start\":\"21:00\",\"end\":\"21:30\"},{\"start\":\"21:30\",\"end\":\"22:00\"},{\"start\":\"22:00\",\"end\":\"22:30\"},{\"start\":\"22:30\",\"end\":\"23:00\"},{\"start\":\"23:00\",\"end\":\"23:30\"},{\"start\":\"23:30\",\"end\":\"24:00\"}]</code></pre><h3 style=\"text-indent: 0px; text-align: start;\">3、时间跨度任意指定</h3><p style=\"text-indent: 0px; text-align: start;\">除了常见的时间跨度为60分钟或者30分钟，有的时候还可能需要其他的时间跨度，那么是否可能写一个相对通用的方法，参数为时间跨度（以分钟为单位），当然是可以的，具体实现代码如下（这里仅生成时间区间为字符串的，其他格式参考上面）：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>function generateTimes(step) {\n    let size = Math.floor(24 * 60 / step);\n    let timeArrays = new Array(size).fill('').map((item, index) =&gt; {\n        let startVal = index * step;\n        let endVal = (index + 1) * step;\n        let startHour = Math.floor((startVal / 60));\n        let startMinute = (startVal % 60);\n        let endHour = Math.floor((endVal / 60));\n        let endMinute = (endVal % 60);\n        let startTime = ((startHour &lt; 10) ? ('0' + startHour) : startHour) + ':' + (startMinute === 0 ? '00' : startMinute);\n        let endTime = ((endHour &lt; 10) ? ('0' + endHour) : endHour) + ':' + (endMinute === 0 ? '00' : endMinute);\n    \n        return startTime + ' - ' + endTime;\n    });\n\n    return timeArrays;\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">比如想要生成时间跨度为120分钟的时间区间，可以直接传入120即可</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>console.log(generateTimes(120));</code></pre><p style=\"text-indent: 0px; text-align: start;\">生成的时间区间如下：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>['00:00 - 02:00', '02:00 - 04:00', '04:00 - 06:00', '06:00 - 08:00', '08:00 - 10:00', '10:00 - 12:00', '12:00 - 14:00', '14:00 - 16:00', '16:00 - 18:00', '18:00 - 20:00', '20:00 - 22:00', '22:00 - 24:00']</code></pre><blockquote style=\"text-indent: 0px; text-align: start;\"><strong>需要注意的是，如果时间跨度无法被整除，那么生成的时间区间可能无法完全覆盖24小时。</strong></blockquote><p><br></p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31d"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c583ad4edbe750448491dd",
  "title": "React新文档：不要滥用effect哦",
  "cover": "",
  "body": "<div class='wang-editor'><p style=\"text-indent: 0px; text-align: start;\">大家好，我卡颂。</p><p style=\"text-indent: 0px; text-align: start;\">你或你的同事在使用<span style=\"color: rgb(214, 51, 132);\"><code>useEffect</code></span>时有没有发生过以下场景：</p><p style=\"text-indent: 0px; text-align: start;\">当你希望<span style=\"color: rgb(214, 51, 132);\"><code>状态a</code></span>变化后<strong>发起请求</strong>，于是你使用了<span style=\"color: rgb(214, 51, 132);\"><code>useEffect</code></span>：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>useEffect(() =&gt; {\n  fetch(xxx);\n}, [a])</code></pre><p style=\"text-indent: 0px; text-align: start;\">这段代码运行符合预期，上线后也没问题。</p><p style=\"text-indent: 0px; text-align: start;\">随着需求不断迭代，其他地方也会修改<span style=\"color: rgb(214, 51, 132);\"><code>状态a</code></span>。但是在那个需求中，并不需要<span style=\"color: rgb(214, 51, 132);\"><code>状态a</code></span>改变后发起请求。</p><p style=\"text-indent: 0px; text-align: start;\">你不想动之前的代码，又得修复这个<span style=\"color: rgb(214, 51, 132);\"><code>bug</code></span>，于是你增加了判断条件：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>useEffect(() =&gt; {\n  if (xxxx) {\n    fetch(xxx);\n  }\n}, [a])</code></pre><p style=\"text-indent: 0px; text-align: start;\">某一天，需求又变化了！现在请求还需要<span style=\"color: rgb(214, 51, 132);\"><code>b</code></span>字段。</p><p style=\"text-indent: 0px; text-align: start;\">这很简单，你顺手就将<span style=\"color: rgb(214, 51, 132);\"><code>b</code></span>作为<span style=\"color: rgb(214, 51, 132);\"><code>useEffect</code></span>的依赖加了进去：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>useEffect(() =&gt; {\n  if (xxxx) {\n    fetch(xxx);\n  }\n}, [a, b])</code></pre><p style=\"text-indent: 0px; text-align: start;\">随着时间推移，你逐渐发现：</p><ul style=\"text-indent: 0px; text-align: start;\"><li><strong>是否发送请求</strong>与<strong>if条件</strong>相关</li><li><strong>是否发送请求</strong>还与<strong>a、b等依赖项</strong>相关</li><li><strong>a、b等依赖项</strong>又与<strong>很多需求</strong>相关</li></ul><p style=\"text-indent: 0px; text-align: start;\">根本分不清到底什么时候会发送请求，真是头大...</p><p style=\"text-indent: 0px; text-align: start;\">如果以上场景似曾相识，那么<span style=\"color: rgb(214, 51, 132);\"><code>React</code></span>新文档里已经明确提供了解决办法。</p><p style=\"text-indent: 0px; text-align: start;\">欢迎加入<a href=\"https://link.segmentfault.com/?enc=XSI9pTFVJBxh%2Fa%2BPYQ4LkQ%3D%3D.gDh%2BTZ8sb9LyHpJ4DYIYehY8w0kLl2kuFLKWxELqrN2pEP5SYVo5Yy4rzzGI0yxD\" target=\"_blank\">人类高质量前端框架群</a>，带飞</p><h2 style=\"text-indent: 0px; text-align: start;\">一些理论知识</h2><p style=\"text-indent: 0px; text-align: start;\">新文档中这一节名为<a href=\"https://link.segmentfault.com/?enc=yNmjEuvoealF%2Fw1PH4Hxhg%3D%3D.%2BtiFWOCJ6WdKjdqjYNQUgs4Xv4TTExYkDm76rMbnF2mrsOuASXPj8rR0rUvo1K4IrFyL4b2DoEzz0KWcKhHyz36mFdWQuUMllwnZcXLp2sqdAVgyrvAH%2Bn3lZeVWiCkO\" target=\"_blank\">Synchronizing&nbsp;with&nbsp;Effects</a>，当前还处于草稿状态。</p><p style=\"text-indent: 0px; text-align: start;\">但是其中提到的一些概念，所有<span style=\"color: rgb(214, 51, 132);\"><code>React</code></span>开发者都应该清楚。</p><p style=\"text-indent: 0px; text-align: start;\">首先，<span style=\"color: rgb(214, 51, 132);\"><code>effect</code></span>这一节隶属于<a href=\"https://link.segmentfault.com/?enc=TECgNTIdt27WGEZNWLxMAA%3D%3D.3jfyM4NZHIQRnsF2XYFh5QaSyVzmJkPDrVUBhTETjMC6zqSGnRuks5q4Ft%2FVT6OwXNKMvDuLE8fdGo0NRj%2B8pXhOgzQp0fLQdCDtz8HV0McfTygdbiBDCsRDePKoYY58\" target=\"_blank\">Escape&nbsp;Hatches</a>（逃生舱）这一章。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">从命名就能看出，开发者并不一定需要使用<span style=\"color: rgb(214, 51, 132);\"><code>effect</code></span>，这仅仅是特殊情况下的逃生舱。</p><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>React</code></span>中有两个重要的概念：</p><ul style=\"text-indent: 0px; text-align: start;\"><li><span style=\"color: rgb(214, 51, 132);\"><code>Rendering&nbsp;code</code></span>（渲染代码）</li><li><span style=\"color: rgb(214, 51, 132);\"><code>Event&nbsp;handlers</code></span>（事件处理器）</li></ul><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>Rendering&nbsp;code</code></span>指<strong>开发者编写的组件渲染逻辑</strong>，最终会返回一段<span style=\"color: rgb(214, 51, 132);\"><code>JSX</code></span>。</p><p style=\"text-indent: 0px; text-align: start;\">比如，如下组件内部就是<span style=\"color: rgb(214, 51, 132);\"><code>Rendering&nbsp;code</code></span>：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>function App() {\n  const [name, update] = useState('KaSong');\n  \n  return &lt;div&gt;Hello {name}&lt;/div&gt;;\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>Rendering&nbsp;code</code></span>的特点是：他应该是<strong>不带副作用的纯函数</strong>。</p><p style=\"text-indent: 0px; text-align: start;\">如下<span style=\"color: rgb(214, 51, 132);\"><code>Rendering&nbsp;code</code></span>包含副作用（<span style=\"color: rgb(214, 51, 132);\"><code>count</code></span>变化），就是不推荐的写法：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>let count = 0;\n\nfunction App() {\n  count++;\n  const [name, update] = useState('KaSong');\n  \n  return &lt;div&gt;Hello {name}&lt;/div&gt;;\n}</code></pre><h3 style=\"text-indent: 0px; text-align: start;\">处理副作用</h3><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>Event&nbsp;handlers</code></span>是<strong>组件内部包含的函数</strong>，用于执行用户操作，可以包含<span style=\"color: rgb(214, 51, 132);\"><code>副作用</code></span>。</p><p style=\"text-indent: 0px; text-align: start;\">下面这些操作都属于<span style=\"color: rgb(214, 51, 132);\"><code>Event&nbsp;handlers</code></span>：</p><ul style=\"text-indent: 0px; text-align: start;\"><li>更新<span style=\"color: rgb(214, 51, 132);\"><code>input</code></span>输入框</li><li>提交表单</li><li>导航到其他页面</li></ul><p style=\"text-indent: 0px; text-align: start;\">如下例子中组件内部的<span style=\"color: rgb(214, 51, 132);\"><code>changeName</code></span>方法就属于<span style=\"color: rgb(214, 51, 132);\"><code>Event&nbsp;handlers</code></span>：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>function App() {\n  const [name, update] = useState('KaSong');\n  \n  const changeName = () =&gt; {\n    update('KaKaSong');\n  }\n  \n  return &lt;div onClick={changeName}&gt;Hello {name}&lt;/div&gt;;\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">但是，并不是所有副作用都能在<span style=\"color: rgb(214, 51, 132);\"><code>Event&nbsp;handlers</code></span>中解决。</p><p style=\"text-indent: 0px; text-align: start;\">比如，在一个聊天室中，<strong>发送消息</strong>是用户触发的，应该交给<span style=\"color: rgb(214, 51, 132);\"><code>Event&nbsp;handlers</code></span>处理。</p><p style=\"text-indent: 0px; text-align: start;\">除此之外，聊天室需要随时保持和服务端的长连接，<strong>保持长连接</strong>的行为属于副作用，但并不是用户行为触发的。</p><p style=\"text-indent: 0px; text-align: start;\">对于这种：在视图渲染后触发的副作用，就属于<span style=\"color: rgb(214, 51, 132);\"><code>effect</code></span>，应该交给<span style=\"color: rgb(214, 51, 132);\"><code>useEffect</code></span>处理。</p><p style=\"text-indent: 0px; text-align: start;\">回到开篇的例子：</p><p style=\"text-indent: 0px; text-align: start;\">当你希望<span style=\"color: rgb(214, 51, 132);\"><code>状态a</code></span>变化后<strong>发起请求</strong>，首先应该明确，你的需求是：</p><p style=\"text-indent: 0px; text-align: start;\"><strong>状态a变化，接下来需要发起请求</strong></p><p style=\"text-indent: 0px; text-align: start;\">还是</p><p style=\"text-indent: 0px; text-align: start;\"><strong>某个用户行为需要发起请求，请求依赖状态a作为参数</strong>？</p><p style=\"text-indent: 0px; text-align: start;\">如果是后者，这是用户行为触发的副作用，那么相关逻辑应该放在<span style=\"color: rgb(214, 51, 132);\"><code>Event&nbsp;handlers</code></span>中。</p><p style=\"text-indent: 0px; text-align: start;\">假设之前的代码逻辑是：</p><ol style=\"text-indent: 0px; text-align: start;\"><li>点击按钮，触发<span style=\"color: rgb(214, 51, 132);\"><code>状态a</code></span>变化</li><li><span style=\"color: rgb(214, 51, 132);\"><code>useEffect</code></span>执行，发送请求</li></ol><p style=\"text-indent: 0px; text-align: start;\">应该修改为：</p><ol style=\"text-indent: 0px; text-align: start;\"><li>点击按钮，在事件回调中获取<span style=\"color: rgb(214, 51, 132);\"><code>状态a</code></span>的值</li><li>在事件回调中发送请求</li></ol><p style=\"text-indent: 0px; text-align: start;\">经过这样修改，<strong>状态a变化</strong>与<strong>发送请求</strong>之间不再有因果关系，后续对<span style=\"color: rgb(214, 51, 132);\"><code>状态a</code></span>的修改不会再有<strong>无意间触发请求</strong>的顾虑。</p><h2 style=\"text-indent: 0px; text-align: start;\">总结</h2><p style=\"text-indent: 0px; text-align: start;\">当我们编写组件时，应该尽量将组件编写为纯函数。</p><p style=\"text-indent: 0px; text-align: start;\">对于组件中的副作用，首先应该明确：</p><p style=\"text-indent: 0px; text-align: start;\">是<strong>用户行为触发的</strong>还是<strong>视图渲染后主动触发的</strong>？</p><p style=\"text-indent: 0px; text-align: start;\">对于前者，将逻辑放在<span style=\"color: rgb(214, 51, 132);\"><code>Event&nbsp;handlers</code></span>中处理。</p><p style=\"text-indent: 0px; text-align: start;\">对于后者，使用<span style=\"color: rgb(214, 51, 132);\"><code>useEffect</code></span>处理。</p><p style=\"text-indent: 0px; text-align: start;\">这也是为什么<span style=\"color: rgb(214, 51, 132);\"><code>useEffect</code></span>所在章节在新文档中叫做<span style=\"color: rgb(214, 51, 132);\"><code>Escape&nbsp;Hatches</code></span>&nbsp;——&nbsp;大部分情况下，你不会用到<span style=\"color: rgb(214, 51, 132);\"><code>useEffect</code></span>，这只是其他情况都不适应时的逃生舱。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31d"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c584244edbe750448491ef",
  "title": "JavaScript精度丢失原因以及解决方案",
  "cover": "",
  "body": "<div class='wang-editor'><h2 style=\"text-indent: 0px; text-align: start;\">浮点数精度丢失的原因</h2><p style=\"text-indent: 0px; text-align: start;\">由于计算机的底层是由二进制实现的，有些运算的数字无法全部显示出来。就像一些无理数不能完全显示出来一样，如圆周率&nbsp;3.1415926...，0.3333...&nbsp;等。JavaScript遵循IEEE754规范，采用双精度存储（double&nbsp;precision），占用64bit。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">1位用来表示符号位，11位用来表示指数，52位表示尾数。</p><p style=\"text-indent: 0px; text-align: start;\">因为在计算机最底层，数值的运算和操作都是采用二进制实现的，所以计算机没有办法精确表示浮点数，而只能用二进制近似相等的去表示浮点数的小数部分。</p><h2 style=\"text-indent: 0px; text-align: start;\">数字精度丢失的一些典型场景</h2><p style=\"text-indent: 0px; text-align: start;\">//加法<br>0.1&nbsp;+&nbsp;0.2&nbsp;=&nbsp;0.30000000000000004<br>0.7&nbsp;+&nbsp;0.1&nbsp;=&nbsp;0.7999999999999999</p><p style=\"text-indent: 0px; text-align: start;\">//减法<br>1.5&nbsp;-&nbsp;1.2&nbsp;=&nbsp;0.30000000000000004<br>0.3&nbsp;-&nbsp;0.2&nbsp;=&nbsp;0.09999999999999998</p><p style=\"text-indent: 0px; text-align: start;\">//乘法<br>1.1&nbsp;*&nbsp;100&nbsp;=&nbsp;110.00000000000001<br>0.8&nbsp;*&nbsp;3&nbsp;=&nbsp;2.4000000000000004</p><p style=\"text-indent: 0px; text-align: start;\">//除法<br>0.3&nbsp;/&nbsp;0.1&nbsp;=&nbsp;2.9999999999999996<br>0.69&nbsp;/&nbsp;10&nbsp;=&nbsp;0.06899999999999999</p><h2 style=\"text-indent: 0px; text-align: start;\">解决方案</h2><h3 style=\"text-indent: 0px; text-align: start;\">第三方库：</h3><p style=\"text-indent: 0px; text-align: start;\">Decimal.js<br>bignumber.js<br>big.js</p><h3 style=\"text-indent: 0px; text-align: start;\">手写代码：</h3><p style=\"text-indent: 0px; text-align: start;\">//加法</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>function plus(num1, num2) {\n    let r1, r2, m;\n    try {\n        r1 = num1.toString().split(\".\")[1].length\n    } catch (e) {\n        r1 = 0\n    }\n    try {\n        r2 = num2.toString().split(\".\")[1].length\n    } catch (e) {\n        r2 = 0\n    }\n    m = Math.pow(10, Math.max(r1, r2))\n    return (num1 * m + num2 * m) / m\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">//减法</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>function subtract(num1, num2) {\n    let r1, r2, m, n;\n    try {\n        r1 = num1.toString().split(\".\")[1].length\n    } catch (e) {\n        r1 = 0\n    }\n    try {\n        r2 = num2.toString().split(\".\")[1].length\n    } catch (e) {\n        r2 = 0\n    }\n    m = Math.pow(10, Math.max(r1, r2));\n    n = (r1 &gt;= r2) ? r1 : r2;\n    return ((num1 * m - num2 * m) / m).toFixed(n);\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">//乘法</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code> function multiply(num1, num2) {\n    let m = 0,\n        s1 = num1.toString(),\n        s2 = num2.toString();\n    try {\n        m += s1.split(\".\")[1].length\n    } catch (e) {}\n    try {\n        m += s2.split(\".\")[1].length\n    } catch (e) {}\n    return Number(s1.replace(\".\", \"\")) * Number(s2.replace(\".\", \"\")) / Math.pow(10, m)\n }\n</code></pre><p style=\"text-indent: 0px; text-align: start;\">//除法</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>function divide(num1, num2) {\n    let t1 = 0,\n        t2 = 0,\n        r1, r2;\n    try {\n        t1 = num1.toString().split(\".\")[1].length\n    } catch (e) {}\n    try {\n        t2 = num2.toString().split(\".\")[1].length\n    } catch (e) {}\n    with(Math) {\n        r1 = Number(num1.toString().replace(\".\", \"\"))\n        r2 = Number(num2.toString().replace(\".\", \"\"))\n        return multiply((r1 / r2), pow(10, t2 - t1));// multiply乘法配合一起使用\n    }\n}\n\n</code></pre><p style=\"text-indent: 0px; text-align: start;\">看了N篇关于精度丢失的文章后，本文参考了很多篇其它博主的文章才写出来的。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31d"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c586a64edbe75044849280",
  "title": "浅析 2D 组态与 2.5D 组态的区别 | 空调装配生产线与化工安全流程",
  "cover": "",
  "body": "<div class='wang-editor'><h3 style=\"text-indent: 0px; text-align: start;\"><strong>前言</strong></h3><p style=\"text-indent: 0px; text-align: start;\">为了更有效辨别&nbsp;2D&nbsp;与&nbsp;2.5D&nbsp;之间的区别，图扑软件选用&nbsp;2D&nbsp;空调装配生产线与&nbsp;2.5D&nbsp;化工厂安全流程作比较。通过自主研发的&nbsp;HT&nbsp;产品，采用&nbsp;B/S&nbsp;架构快速搭建零代码拖拽式&nbsp;Web&nbsp;组态可视化场景，以真实的场景化、图形化、动态化的效果，反映二者运行状态、工艺流程、动态效果之间的不同。</p><h3 style=\"text-indent: 0px; text-align: start;\"><strong>系统分析</strong></h3><h4 style=\"text-indent: 0px; text-align: start;\"><strong>2D&nbsp;空调装配生产线</strong></h4><p style=\"text-indent: 0px; text-align: start;\">空调装备整个装配过程包括机械的组装和小规模电气组装，需要经过多道工序，生产工程相较复杂。</p><p style=\"text-indent: 0px; text-align: start;\">以二维组态图方式搭建的空调装配生产线，界面中可对用户所关注的产能信息、设备运行关键指标进行监测展示。通过对接后台实时数据进行实时更新，展示对运维管控数据展示所做出的贡献统计。<br><img src=\"https://segmentfault.com/img/bVcZ6YY\" alt=\"\" data-href=\"\" style=\"width: 100%;\"></p><p style=\"text-indent: 0px; text-align: start;\">系统将自动化装配工作站、输送系统、传感器控制等系统集合形成一套完整的装配系统，不同的自动化装配专机完成不同的特定装配工序，如氦检、喂料对接、封箱、喷码等，通过图扑软件&nbsp;HT&nbsp;引擎技术，实现组态图元流畅的动态效果开发。</p><p style=\"text-indent: 0px; text-align: start;\">既能够对子系统进行集中管理，准确、全面地反映各子系统运行状态，又能大幅度提升部门间协作能力，达到综合监控集中控制的目的。</p><p style=\"text-indent: 0px; text-align: start;\">上图传统的&nbsp;2D&nbsp;设计风格只能看到场景的一个面，而&nbsp;2.5D&nbsp;从通俗意义上来讲，是⼀种结合了&nbsp;3D&nbsp;与&nbsp;2D&nbsp;的图形技术，带有&nbsp;3D&nbsp;平行透视角度的&nbsp;2D&nbsp;风格画面，一般具有平行视角、无透视、立体感等特点。</p><h4 style=\"text-indent: 0px; text-align: start;\"><strong>2.5D&nbsp;化工厂安全流程</strong></h4><p style=\"text-indent: 0px; text-align: start;\">数字时代下的化工业必须以满足网格化、多元化、智能化的需求来提升材料开发生产效率。</p><p style=\"text-indent: 0px; text-align: start;\">监控平台对集成重点作业区域、装置位置分布及投入产出、产品产量、装置平稳率、装置负荷率等，搭载的智能感知设备，实时采集温度、压力、液位、有毒有害监测等关键参数。同时&nbsp;2.5D&nbsp;组态界面能清晰辨别工艺的流程的分布以及各个子流程的工艺走向，用户可根据设备甚至零部件的位置、颜色变化及时发现问题。实现对化工设备和生产装置运作状态多层面的可视化监控。</p><p style=\"text-indent: 0px; text-align: start;\"><img src=\"https://segmentfault.com/img/bVcZ6Y2\" alt=\"\" data-href=\"\" style=\"width: 100%;\"></p><p style=\"text-indent: 0px; text-align: start;\">应用科学的“望、闻、问、切”技术手段对化工安全流程展开问题发现、问题分析、问题定位，可针对阀门、管道、设备、法兰等关键部件部位的跑、冒、滴、漏等异常状态时将主动定位同时上报危险源头，辅助管理者及时处置安全隐患。可通过界面下发指令，实现远程遥控设备启停。赋能化工厂安全生产工艺、重大危险源、设备运作流程远程遥控监测能力。<br></p><p style=\"text-indent: 0px; text-align: start;\">图扑软件&nbsp;2.5D&nbsp;可以兼容多种风格需求，卡通风、科技风、写实风等都有涉及，在保证性能的同时也使用户具有更高的视觉体验。</p><h3 style=\"text-indent: 0px; text-align: start;\"><strong>总结</strong></h3><p style=\"text-indent: 0px; text-align: start;\">图扑软件先进的组态界面非常适用于实时监控系统的界面呈现，相较于&nbsp;InTouch/IFix/WinCC&nbsp;这些传统组态软件，图扑基于&nbsp;Web&nbsp;的平台更适合&nbsp;C/S&nbsp;向&nbsp;B/S&nbsp;转型的大趋势，多元素丰富的可视化组件和支持快捷的数据绑定方式，可帮助各行业实现快速创建和部署，效果美观、操作编辑、快速上手、屏幕自适应。采用&nbsp;B/S&nbsp;架构模式，对接测点数据实现&nbsp;Web&nbsp;化跨平台多端访问，无论是&nbsp;PC、PAD&nbsp;或是智能手机打开浏览器，界面均可同步显示。</p><p style=\"text-indent: 0px; text-align: start;\">Hightopo&nbsp;通过灵活的二维组态和三维组态形式，为用户提供快速构建工业自动控制系统监控功能、通用层次的软件工具。已被广泛应用于机械、汽车、石油、化工以及工业自动化（HMI/SCADA/MMI）等诸多领域。</p><p style=\"text-indent: 0px; text-align: start;\">更多行业应用实例可以参考图扑软件官网案例链接：<a href=\"https://link.segmentfault.com/?enc=wDqR1ZLcCkZKsVMEytchsg%3D%3D.24vdmaqmf%2BAC3PwFidXfZkja3bOk1ynYnsSrGWERUrgIai0lXeKrCkEdA5H0xlwN\" target=\"_blank\">https://www.hightopo.com/demo...</a></p><p style=\"text-indent: 0px; text-align: start;\"><br></p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31e"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c586df4edbe75044849292",
  "title": "传统与现代可视化 PK：再生水厂二维工艺组态系统",
  "cover": "",
  "body": "<div class='wang-editor'><h3 style=\"text-indent: 0px; text-align: start;\"><strong>前言</strong></h3><p style=\"text-indent: 0px; text-align: start;\">随着可视化技术的进步与发展，传统再生水厂组态系统所展示的组态页面已逐渐无法满足当前现阶段多样化的展示手段。使得系统对污泥处理处置及生产运行成本方面的监控、分析方面较为薄弱，急需对信息化应用成果和各项信息资源进行多元化的展示并支持多元化终端的便捷访问。</p><p style=\"text-indent: 0px; text-align: start;\">图扑软件&nbsp;HT&nbsp;可视化技术采用&nbsp;B/S&nbsp;架构，通过对传统二维的水厂组态图进行重构设计，对接测点数据实现&nbsp;Web&nbsp;化跨平台多端访问，无论是&nbsp;PC、PAD&nbsp;或是智能手机打开浏览器，即可随时访问监控场景。并支持集成至&nbsp;B/S&nbsp;端，与其他主流前端框架如&nbsp;Angular、React&nbsp;和&nbsp;Vue&nbsp;等无缝融合，打破了以往用户在控制室内控制场景的局限性，通过数据驱动形式让新型组态得以使用&nbsp;2D/2.5D&nbsp;等不同形式实现多样化展示。</p><h3 style=\"text-indent: 0px; text-align: start;\"><strong>效果展示</strong></h3><p style=\"text-indent: 0px; text-align: start;\">本期案例介绍的是对再生水厂厂区内的主要工艺流程进行&nbsp;2D/2.5D&nbsp;可视化设计，根据业务单元“消化池系统”、“絮凝剂系统”、“外来污泥接收系统”进行分类设计，结合接入测点后监测到的实时数据，直观呈现工艺流程和工艺设备的运行状态。</p><h4 style=\"text-indent: 0px; text-align: start;\"><strong>消化池系统</strong></h4><p style=\"text-indent: 0px; text-align: start;\">什么是污泥的消化？厌氧消化是利用厌氧微生物经过水解、酸化、产甲烷等过程，将污泥中的大部分固体有机物水解、液化后并最终分解掉的过程。产甲烷菌最终将污泥有机物中的碳转变成甲烷并从污泥中释放出来，实现污泥的稳定化。<br></p><p style=\"text-indent: 0px; text-align: start;\">图扑软件&nbsp;HT&nbsp;可视化界面中，消化池系统分为&nbsp;2D&nbsp;与&nbsp;2.5D&nbsp;两种模式。2D&nbsp;组态模式中，主要展示了消化池、换热器、阻火器、主要阀门、多级管道等。其中消化池通过绑定池内液位、温度，搅拌机电流、轴温、频率来监测生产数据。另外，可通过界面下发指令，实现远程控制搅拌机模式切换的目的；整体组态系统中的各类阀门，可通过后端传输的接口，展示出流量、流速、压强等数据，同时可切换手动与自动模式；关键管路上还可监控&nbsp;PH&nbsp;值、水温、实时流速等数据。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>2D&nbsp;效果展示</strong></p><p style=\"text-indent: 0px; text-align: start;\"><strong>2.5D&nbsp;效果展示</strong></p><p style=\"text-indent: 0px; text-align: start;\">2.5D&nbsp;组态界面采用了较为科幻的风格设计，通过立体的效果展示整个消化池系统的工艺流程与运行监测。</p><h3 style=\"text-indent: 0px; text-align: start;\"><strong>絮凝剂制备系统</strong></h3><p style=\"text-indent: 0px; text-align: start;\">絮凝沉降进行固液分离的方法是目前水处理技术中重要的分离方法之一，采用水溶液高聚物为絮凝剂来处理工业废水、生活废水、工业给水、循环冷却水、民用水时，具有促进水质澄清，加快沉降污泥的过滤速度，减少泥渣数量和滤饼便于处置等优点。</p><p style=\"text-indent: 0px; text-align: start;\">全新的&nbsp;2D&nbsp;组态界面中，通过图扑软件&nbsp;HT&nbsp;引擎技术，实现组态图元流畅的动态效果开发。本系统中展示了&nbsp;3&nbsp;条絮凝剂制备产线流程，采用固定面板的方式展示制备系统的液体浓度、制备次数、搅拌模式设定、系统运行状态等实时数据；以及关键设备制备罐、储备罐液位，主要阀门数据等。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>2D&nbsp;效果展示</strong></p><p style=\"text-indent: 0px; text-align: start;\"><strong>2.5D&nbsp;效果展示</strong></p><p style=\"text-indent: 0px; text-align: start;\">2.5D&nbsp;效果更具空间立体感，实现与现实场景中相符的空间分布效果。</p><h4 style=\"text-indent: 0px; text-align: start;\"><strong>外来污泥接收系统</strong></h4><p style=\"text-indent: 0px; text-align: start;\">污泥处理处置应遵循源头削减和全过程控制原则，加强对有毒有害物质的源头控制，根据污泥最终安全处置要求和污泥特性，选择适宜的污水和污泥处理工艺。</p><p style=\"text-indent: 0px; text-align: start;\">污泥处理处置的目标是实现污泥的减量化、稳定化和无害化；鼓励回收和利用污泥中的能源和资源。坚持在安全、环保和经济的前提下实现污泥的处理处置和综合利用，达到节能减排和发展循环经济的目的。</p><p style=\"text-indent: 0px; text-align: start;\">外来污泥接收系统主要展示了污泥存储、脱水、外运流程，关键节点数据包括仓料位、斗料位、稀释泥单元液位、稀释水单元液位，以及关键管路上的流量、压强数据；主要阀门支持切换手动与自动模式。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>2D&nbsp;效果展示</strong></p><p style=\"text-indent: 0px; text-align: start;\"><strong>2.5D&nbsp;效果展示</strong></p><p style=\"text-indent: 0px; text-align: start;\">使用&nbsp;2.5D&nbsp;组态界面，可以更直观地看到整个工艺的流程分布以及各个子流程的工艺走向。</p><h3 style=\"text-indent: 0px; text-align: start;\"><strong>实现价值</strong></h3><p style=\"text-indent: 0px; text-align: start;\">以上图扑案例体现的再生水厂工艺流程监控系统，仅仅是整个体系的冰山一角。实现全新的、全套的水厂&nbsp;2D/2.5D&nbsp;组态工艺的最终目的，是为了满足集团决策以及管理人员对其所属业务单元实施运营、管理、指挥、调度等多维度综合应用，帮助企业快速落地配水、净水、输水以及工艺、设施的精细化管理全流程，高效规避城市供水出现的二次污染问题，为集团生产运营管理调度建立可信的可视化决策平台。</p><p style=\"text-indent: 0px; text-align: start;\">图扑软件还支持采用&nbsp;3D&nbsp;轻量化建模形式搭建水务监管平台，依托&nbsp;GIS、BIM、视频融合等技术，合力构建数字底板，实现全面感知排供管网运营状况，加强对水务建设全生命周期管理。</p><h3 style=\"text-indent: 0px; text-align: start;\"><strong>总结</strong></h3><p style=\"text-indent: 0px; text-align: start;\">在“十四五”时期，规划明确了要构建智慧水利体系，以流域为单元提升水情测报和智能调度能力。在此背景下，全国各地都在如火如荼地推进智慧水务建设进程，以降低漏损率提高管理效率为目的，加速实现水务信息数字化、设备控制自动化、决策分析智能化发展。</p><p style=\"text-indent: 0px; text-align: start;\">相较于&nbsp;InTouch/IFix/WinCC&nbsp;这些传统组态软件，图扑基于&nbsp;Web&nbsp;的平台更适合&nbsp;C/S&nbsp;向&nbsp;B/S&nbsp;转型的大趋势，多元素丰富的可视化组件和支持快捷的数据绑定方式，可用于快速创建和部署。为各类工业场景提供&nbsp;2D、2.5D、3D&nbsp;多种清晰美观的可视化服务模式。</p><p style=\"text-indent: 0px; text-align: start;\">同传统界面相比，图扑满足工业物联网现代化的、高性能的、跨平台（桌面&nbsp;Mouse&nbsp;/移动&nbsp;Touch&nbsp;/虚拟现实&nbsp;VR）的图形展示效果及交互体验。轻松打开移动端与终端需求界面，是&nbsp;C&nbsp;端平台所不具备的优势，并实现触屏设备的单指旋转、双指缩放、三指平移操作，无需再为跨平台的不同交互模式所烦恼。同时还支持结合&nbsp;VR/AR&nbsp;进行展示，让用户能够沉浸在虚拟环境中进行体验，尤其对工厂、车间、生产线等大型场景更具有优势。</p><p style=\"text-indent: 0px; text-align: start;\">图扑软件先进的组态界面非常适用于实时监控系统的界面呈现，多年来已广泛应用于电信网络拓扑和设备管理，以及工业生产、城市园区、轨道交通、电力能源、仓储物流、化工冶金等工业自动化（HMI/SCADA/MMI）领域，业务涵盖数据展示、态势感知、科学决策等全生命周期监控。将目光锁定在诸多产业链瓶颈环节，以数字技术与各领域融合应用为导向，推动行业跨界创新，致力成为我国工业互联网领域的国产化担当和图形组态领域的领导性品牌。</p><p style=\"text-indent: 0px; text-align: start;\">更多行业应用实例可以参考图扑软件官网案例链接：<a href=\"https://link.segmentfault.com/?enc=KSfHmK4byPh2vtPN4UMLQw%3D%3D.2pbPegl62I0xiOP4ClzBD4mc4kOrQ1SneV6TK5J5Mg8la3iQTArykxIXhM8vpbeP\" target=\"_blank\">https://www.hightopo.com/demo...</a></p><p style=\"text-indent: 0px; text-align: start;\"><br></p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31e"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c587124edbe750448492a4",
  "title": "11个常用JS小小技巧",
  "cover": "",
  "body": "<div class='wang-editor'><p style=\"text-indent: 0px; text-align: start;\">在我们的日常开发过程中，我们经常会遇到数字与字符串转换，检查对象中是否存在对应值，条件性操作对象数据，过滤数组中的错误值，等等这类处理。</p><p style=\"text-indent: 0px; text-align: start;\">在这里，整理出了一些常用的小技巧，这些技巧是我比较喜欢的❤️，可以使我们的代码更精简、更干净，且非常实用。</p><ol style=\"text-indent: 0px; text-align: start;\"><li>通过条件判断向对象添加属性</li></ol><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>const isValid = false;\nconst age = 18;\n\n// 我们可以通过展开运算符向对象添加属性\nconst person = {\n    id: 'ak001',\n    name: 'ak47',\n    ...(isValid &amp;&amp; {isActive: true}),\n    ...((age &gt; 18 || isValid) &amp;&amp; {cart: 0})\n}\n\nconsole.log('person', person)</code></pre><ol style=\"text-indent: 0px; text-align: start;\"><li>检查对象中是否存在某个属性</li></ol><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>const person = {\n    id: 'ak001',\n    name: 'ak47'\n}\n\nconsole.log('name' in person); // true\nconsole.log('isActive' in person); // false</code></pre><ol style=\"text-indent: 0px; text-align: start;\"><li>解构赋值</li></ol><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>const product = {\n  id: 'ak001',\n  name: 'ak47'\n}\n\nconst { name: weaponName } = product;\n\nconsole.log('weaponName:', weaponName); // weaponName: ak47\n\n// 通过动态key进行解构赋值\nconst extractKey = 'name';\nconst { [extractKey]: data } = product;\n\nconsole.log('data:', data); // data: ak47</code></pre><ol style=\"text-indent: 0px; text-align: start;\"><li>循环遍历一个对象的key和value</li></ol><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>const product = {\n  id: 'ak001',\n  name: 'ak47',\n  isSale: false\n}\n\nObject.entries(product).forEach(([key, value]) =&gt; {\n  if(['id', 'name'].includes(key)) {\n    console.log('key:',key, 'value:',value)\n  }\n})\n\n// key: id value: ak001\n// key: name value: ak47</code></pre><ol style=\"text-indent: 0px; text-align: start;\"><li>使用可选链(Optionalchaining)避免访问对象属性报错</li></ol><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>const product = {\n  id: 'ak001',\n  name: 'ak47'\n}\n\nconsole.log(product.sale.isSale); // throw error\n\nconsole.log(product?.sale?.isSale); // undefined</code></pre><p style=\"text-indent: 0px; text-align: start;\">注意⚠️:&nbsp;在实际使用场景中，有些场景对于我们要获取的属性是非必需的，我们可以通过上面这种方式去避免报错出现；但是有些场景下一些属性是必须的，不然就会影响我们的实际功能，这个时候还是尽量给出清晰的报错提示来解决这种错误的出现。</p><p style=\"text-indent: 0px; text-align: start;\">6.检查数组中falsy的值</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>const fruitList = ['apple', null, 'banana', undefined];\n\n// 过滤掉falsy的值\nconst filterFruitList = fruitList.filter(Boolean);\nconsole.log('filterFruitList:', filterFruitList); \n// filterFruitList:['apple', 'banana']\n// 检查数组中是否有truthy的值\nconst isAnyFruit = fruitList.some(Boolean);\nconsole.log('isAnyFruit:', isAnyFruit); // isAnyFruit: true</code></pre><p style=\"text-indent: 0px; text-align: start;\">7.数组去重</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>const fruitList = ['apple', 'mango', 'banana', 'apple'];\n\nconst uniqList = [...new Set(fruitList)]\nconsole.log('uniqList:', uniqList); // uniqList: ['apple', 'mango', 'banana']</code></pre><ol style=\"text-indent: 0px; text-align: start;\"><li>检查是否为数组类型</li></ol><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>const fruitList = ['apple', 'mango'];\n\nconsole.log(typeof fruitList); // object\nconsole.log(Array.isArray(fruiltList)); // true</code></pre><p style=\"text-indent: 0px; text-align: start;\">9.数字&amp;字符串类型转换</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>const personId = '007';\nconsole.log('personId:', +personId, 'type:', typeof +personId); \n// personId: 7 type: number\n\nconst personId = 119;\nconsole.log('personId:', personId + '', 'type:', typeof (personId + '')); \n// personId: 119 type: string</code></pre><ol style=\"text-indent: 0px; text-align: start;\"><li>巧用空值合并(??)</li></ol><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>let data = undefined ?? 'noData;\nconsole.log('data:', data); // data: noData\n\ndata = null ?? 'noData';\nconsole.log('data:', data); // data: noData\n\ndata = 0 ?? null ?? 'noData';\nconsole.log('data:', data); // data: 0\n\n// 当我们根据变量自身判断时\ndata ??= 'noData';\nconsole.log('data:', data); // data: noData</code></pre><blockquote style=\"text-indent: 0px; text-align: start;\">和或（||）&nbsp;运算符的区别？\\<br>或运算符针对的是falsy类的值&nbsp;(0,’&nbsp;’,&nbsp;null,&nbsp;undefined,&nbsp;false,&nbsp;NaN)，而空值合并仅针对null和undefined生效；</blockquote><ol style=\"text-indent: 0px; text-align: start;\"><li>通过!!进行布尔转换</li></ol><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>console.log('this is not empty:', !!'')\n// this is not empty: false\n\nconsole.log('this is not empty:', !!'Data')\n// this is not empty: true</code></pre><p style=\"text-indent: 0px; text-align: start;\">最后，希望这些小小技巧能够帮助到大家的日常开发，如果大家有更好的方法也欢迎留言分享</p><p style=\"text-indent: 0px; text-align: start;\"><br></p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31e"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c5879a4edbe750448492b6",
  "title": "精读《web reflow》",
  "cover": "",
  "body": "<div class='wang-editor'><p style=\"text-indent: 0px; text-align: start;\">网页重排（回流）是阻碍流畅性的重要原因之一，结合&nbsp;<a href=\"https://gist.github.com/paulirish/5d52fb081b3570c81e3a\" target=\"_blank\">What&nbsp;forces&nbsp;layout&nbsp;/&nbsp;reflow</a>&nbsp;这篇文章与引用，整理一下回流的起因与优化思考。</p><p style=\"text-indent: 0px; text-align: start;\">借用这张经典图：</p><p style=\"text-indent: 0px; text-align: start;\"><img src=\"https://segmentfault.com/img/remote/1460000041913826\" alt=\"\" data-href=\"\" style=\"width: 100%;\"></p><p style=\"text-indent: 0px; text-align: start;\">网页渲染会经历&nbsp;DOM&nbsp;-&gt;&nbsp;CSSOM&nbsp;-&gt;&nbsp;Layout(重排&nbsp;or&nbsp;reflow)&nbsp;-&gt;&nbsp;Paint(重绘)&nbsp;-&gt;&nbsp;Composite(合成)，其中&nbsp;Composite&nbsp;在&nbsp;<a href=\"https://link.segmentfault.com/?enc=JCjso6QTSqN2AVJ%2BXsdkEQ%3D%3D.uhdeurA4hLUm4wKeaCueL%2Fp127Dm3jkRATF9ClJRFnoTue%2FzbIiTWmS4IIbypEj47KUIbL0%2FhdQxMyQCUKhFF%2BVHCP59vRc0v5LWFV2wnZ7bLxGQzHIiyjnd7i7tuC%2BvJRI8MTH0%2BA2YmJpZAaQrGtfLX%2F0Gh34HueF%2F6a6W8sxeBTeI3Q4%2FK1aGTCBgj7jDAy9aWebpqnP5rO%2B%2FIO8Ciarm7BLFGOm9391%2FhSR%2Bt4G8UCwdE5wMBI8q5cUu4gCy%2BgyFtbTMx2bl7%2F5yqlaf2oPE74awkaAxARy7gQwj8vk%3D\" target=\"_blank\">精读《深入了解现代浏览器四》</a>&nbsp;详细介绍过，是在&nbsp;GPU&nbsp;进行光栅化。</p><p style=\"text-indent: 0px; text-align: start;\">那么排除&nbsp;JS、DOM、CSSOM、Composite&nbsp;可能导致的性能问题外，剩下的就是我们这次关注的重点，reflow&nbsp;了。从顺序上可以看出来，重排后一定重绘，而重绘不一定触发重排。</p><h2 style=\"text-indent: 0px; text-align: start;\">概述</h2><p style=\"text-indent: 0px; text-align: start;\">什么时候会触发&nbsp;Layout(reflow)&nbsp;呢？一般来说，当元素位置发生变化时就会。但也不尽然，因为浏览器会自动合并更改，在达到某个数量或时间后，会合并为一次&nbsp;reflow，而&nbsp;reflow&nbsp;是渲染页面的重要一步，打开浏览器就一定会至少&nbsp;reflow&nbsp;一次，所以我们不可能避免&nbsp;reflow。</p><p style=\"text-indent: 0px; text-align: start;\">那为什么要注意&nbsp;reflow&nbsp;导致的性能问题呢？这是因为某些代码可能导致浏览器优化失效，即明明能合并&nbsp;reflow&nbsp;时没有合并，这一般出现在我们用&nbsp;js&nbsp;API&nbsp;访问某个元素尺寸时，为了保证拿到的是精确值，不得不提前触发一次&nbsp;reflow，即便写在&nbsp;for&nbsp;循环里。</p><p style=\"text-indent: 0px; text-align: start;\">当然也不是每次访问元素位置都会触发&nbsp;reflow，在浏览器触发&nbsp;reflow&nbsp;后，所有已有元素位置都会记录快照，只要不再触发位置等变化，第二次开始访问位置就不会触发&nbsp;reflow，关于这一点会在后面详细展开。现在要解释的是，这个&nbsp;”触发位置等变化“，到底有哪些？</p><p style=\"text-indent: 0px; text-align: start;\">根据&nbsp;<a href=\"https://gist.github.com/paulirish/5d52fb081b3570c81e3a\" target=\"_blank\">What&nbsp;forces&nbsp;layout&nbsp;/&nbsp;reflow</a>&nbsp;文档的总结，一共有这么几类：</p><h3 style=\"text-indent: 0px; text-align: start;\">获得盒子模型信息</h3><ul style=\"text-indent: 0px; text-align: start;\"><li><span style=\"color: rgb(214, 51, 132);\"><code>elem.offsetLeft</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>elem.offsetTop</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>elem.offsetWidth</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>elem.offsetHeight</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>elem.offsetParent</code></span></li><li><span style=\"color: rgb(214, 51, 132);\"><code>elem.clientLeft</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>elem.clientTop</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>elem.clientWidth</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>elem.clientHeight</code></span></li><li><span style=\"color: rgb(214, 51, 132);\"><code>elem.getClientRects()</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>elem.getBoundingClientRect()</code></span></li></ul><p style=\"text-indent: 0px; text-align: start;\">获取元素位置、宽高的一些手段都会导致&nbsp;reflow，不存在绕过一说，因为只要获取这些信息，都必须&nbsp;reflow&nbsp;才能给出准确的值。</p><h3 style=\"text-indent: 0px; text-align: start;\">滚动</h3><ul style=\"text-indent: 0px; text-align: start;\"><li><span style=\"color: rgb(214, 51, 132);\"><code>elem.scrollBy()</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>elem.scrollTo()</code></span></li><li><span style=\"color: rgb(214, 51, 132);\"><code>elem.scrollIntoView()</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>elem.scrollIntoViewIfNeeded()</code></span></li><li><span style=\"color: rgb(214, 51, 132);\"><code>elem.scrollWidth</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>elem.scrollHeight</code></span></li><li><span style=\"color: rgb(214, 51, 132);\"><code>elem.scrollLeft</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>elem.scrollTop</code></span>&nbsp;访问及赋值</li></ul><p style=\"text-indent: 0px; text-align: start;\">对&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>scrollLeft</code></span>&nbsp;赋值等价于触发&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>scrollTo</code></span>，所有导致滚动产生的行为都会触发&nbsp;reflow，笔者查了一些资料，目前主要推测是滚动条出现会导致可视区域变窄，所以需要&nbsp;reflow。</p><h3 style=\"text-indent: 0px; text-align: start;\">focus()</h3><ul style=\"text-indent: 0px; text-align: start;\"><li><span style=\"color: rgb(214, 51, 132);\"><code>elem.focus()</code></span>&nbsp;(<a href=\"https://link.segmentfault.com/?enc=SM02ayTnO8oLvGi%2B3KCRMw%3D%3D.GelFMzHPvvaypYS1OGkPWpcn8iardThLMH5YhveYowbA%2FIGVpmyJwAOy9T611jDyCLSYJO3Bo2WZOdvbfmC5TN3%2BsRQ7Gv5ywOH1w6kVhugHkIyMsgSTqciCYyVMrLTUyGyxdnMviyGy7g1n%2BPuJgMXTnPVdu3mZnriivCGHiVawczWoirOTrhJ%2BsKZoIgEPkAZB2YaYxIcNg1Rjdh4%2FHnSmepqR411r0RqW4LYjf2U%3D\" target=\"_blank\">源码</a>)</li></ul><p style=\"text-indent: 0px; text-align: start;\">可以根据源码看一下注释，主要是这一段：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>// Ensure we have clean style (including forced display locks).\nGetDocument().UpdateStyleAndLayoutTreeForNode(this)</code></pre><p style=\"text-indent: 0px; text-align: start;\">即在聚焦元素时，虽然没有拿元素位置信息的诉求，但指不定要被聚焦的元素被隐藏或者移除了，此时必须调用&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>UpdateStyleAndLayoutTreeForNode</code></span>&nbsp;重排重绘函数，确保元素状态更新后才能继续操作。</p><p style=\"text-indent: 0px; text-align: start;\">还有一些其他&nbsp;element&nbsp;API：</p><ul style=\"text-indent: 0px; text-align: start;\"><li><span style=\"color: rgb(214, 51, 132);\"><code>elem.computedRole</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>elem.computedName</code></span></li><li><span style=\"color: rgb(214, 51, 132);\"><code>elem.innerText</code></span>&nbsp;(<a href=\"https://link.segmentfault.com/?enc=OdizXPAONzPc3tUxSMzpZA%3D%3D.7Zj4kO%2BzD%2BjxSrkoDAOTpXmYEQNtTaPK%2FL9lUMSZXVELE3QRXUblrGAZJT0zP%2FkJCamKqaIsncjYgjUgf8LsAb2LejEp%2BsdZkLE2ZOFoDyOOMhrbskgs4VIlReoxXYUfBl3bZrZZ%2BXBARV45COPov3tnKFdeo51ipI5i0ivdGxevfrXVvbWxg9oV3zprJYka%2B0uGR6ancFI%2BOp6Ernwxke9xHP8FpXJr1YNcIdbTWlw%3D\" target=\"_blank\">源码</a>)</li></ul><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>innerText</code></span>&nbsp;也需要重排后才能拿到正确内容。</p><h3 style=\"text-indent: 0px; text-align: start;\">获取&nbsp;window&nbsp;信息</h3><ul style=\"text-indent: 0px; text-align: start;\"><li><span style=\"color: rgb(214, 51, 132);\"><code>window.scrollX</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>window.scrollY</code></span></li><li><span style=\"color: rgb(214, 51, 132);\"><code>window.innerHeight</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>window.innerWidth</code></span></li><li><span style=\"color: rgb(214, 51, 132);\"><code>window.visualViewport.height</code></span>&nbsp;/&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>width</code></span>&nbsp;/&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>offsetTop</code></span>&nbsp;/&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>offsetLeft</code></span>&nbsp;(<a href=\"https://link.segmentfault.com/?enc=y96uyHaKVtXlIQ%2FRbJVtAw%3D%3D.5Im072YGGQw3Vcpm4z6%2Bhbg39X89u9ZTUmSvvRAgKhbwSqiirra0T5KZoGBO%2F0XcWBb2rMT878PaHloOlrh9J4DkE8WX5Tb7DRxiFgFHXRjDD8axu0va1DlCl%2BehRi%2Byh6rPdWOOCJerA0nt4eOFT%2F%2FDiF2W%2Bra3RuwsCXEa6MUzwlpJuovsKstdQfgUy9AI9pb8fXsldJvahn4c50%2Fc7wH8%2B2%2B8Sy%2BnWcSkcweUhm4Fc9%2BDYqCrEgSirGndgeoseT4IwNg%2F90xOiOpJ62ORMzJ%2FPnO2VuAKDlBoVWy8XyY%3D\" target=\"_blank\">源码</a>)</li></ul><p style=\"text-indent: 0px; text-align: start;\">和元素级别一样，为了拿到正确宽高和位置信息，必须重排。</p><h3 style=\"text-indent: 0px; text-align: start;\">document&nbsp;相关</h3><ul style=\"text-indent: 0px; text-align: start;\"><li><span style=\"color: rgb(214, 51, 132);\"><code>document.scrollingElement</code></span>&nbsp;仅重绘</li><li><span style=\"color: rgb(214, 51, 132);\"><code>document.elementFromPoint</code></span></li></ul><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>elementFromPoint</code></span>&nbsp;因为要拿到精确位置的元素，必须重排。</p><h3 style=\"text-indent: 0px; text-align: start;\">Form&nbsp;相关</h3><ul style=\"text-indent: 0px; text-align: start;\"><li><span style=\"color: rgb(214, 51, 132);\"><code>inputElem.focus()</code></span></li><li><span style=\"color: rgb(214, 51, 132);\"><code>inputElem.select()</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>textareaElem.select()</code></span></li></ul><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>focus</code></span>、<span style=\"color: rgb(214, 51, 132);\"><code>select</code></span>&nbsp;触发重排的原因和&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>elem.focus</code></span>&nbsp;类似。</p><h3 style=\"text-indent: 0px; text-align: start;\">鼠标事件相关</h3><ul style=\"text-indent: 0px; text-align: start;\"><li><span style=\"color: rgb(214, 51, 132);\"><code>mouseEvt.layerX</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>mouseEvt.layerY</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>mouseEvt.offsetX</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>mouseEvt.offsetY</code></span>&nbsp;(<a href=\"https://link.segmentfault.com/?enc=F6qfuW1qqUnteAel5PVzeg%3D%3D.3%2B15R0RZeWgbrkAowuTCYuGxn7Uv8je0xmuhUAplo592WgZllawkw4qF4C1db5o260ZhyWOKWTWPzPBLiAUbz%2FmSPodY9Yi6o82LbCal3cnong6rEtWUOujjQ1%2F58VrL1CCM%2BDEsGTZ7wkC5HQyBcgREguZAbAlwM7RU9ebzSmtf6WCtGPZRbvQ6nOFG4sNOSA0boUQnzDDHHLlaWCWR0O3axnyrSfDfxH3Co%2FECh3M%3D\" target=\"_blank\">源码</a>)</li></ul><p style=\"text-indent: 0px; text-align: start;\">鼠标相关位置计算，必须依赖一个正确的排布，所以必须触发&nbsp;reflow。</p><h3 style=\"text-indent: 0px; text-align: start;\">getComputedStyle</h3><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>getComputedStyle</code></span>&nbsp;通常会导致重排和重绘，是否触发重排取决于是否访问了位置相关的&nbsp;key&nbsp;等因素。</p><h3 style=\"text-indent: 0px; text-align: start;\">Range&nbsp;相关</h3><ul style=\"text-indent: 0px; text-align: start;\"><li><span style=\"color: rgb(214, 51, 132);\"><code>range.getClientRects()</code></span>,&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>range.getBoundingClientRect()</code></span></li></ul><p style=\"text-indent: 0px; text-align: start;\">获取选中区域的大小，必须&nbsp;reflow&nbsp;才能保障精确性。</p><h3 style=\"text-indent: 0px; text-align: start;\">SVG</h3><p style=\"text-indent: 0px; text-align: start;\">大量&nbsp;SVG&nbsp;方法会引发重排，就不一一枚举了，总之使用&nbsp;SVG&nbsp;操作时也要像操作&nbsp;dom&nbsp;一样谨慎。</p><h3 style=\"text-indent: 0px; text-align: start;\">contenteditable</h3><p style=\"text-indent: 0px; text-align: start;\">被设置为&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>contenteditable</code></span>&nbsp;的元素内，包括将图像复制到剪贴板在内，大量操作都会导致重排。(<a href=\"https://link.segmentfault.com/?enc=LnD64CLFqrdX4JthMNaLyA%3D%3D.wEk78V6R57ID3wjqWwjGzNOLz64rNPFoYWgKNiQPW4IJwjaZ4TNthk8h74UY05vsNys51bcJ7j1jATk8cgGujjff4iWDKphTgBF%2Bu3eT78s5ptwrY2oMnc8%2FpViIJHdkdBRPSQ%2BerkBwj3Ee6Ov1cCTn8jkVqRPtnxERacruXj%2FY62mPCNhnZUm3ICy2d2a9BUioo3%2FbQpQLv4A1zuVA%2Fg%3D%3D\" target=\"_blank\">源码</a>)</p><h2 style=\"text-indent: 0px; text-align: start;\">精读</h2><p style=\"text-indent: 0px; text-align: start;\"><a href=\"https://gist.github.com/paulirish/5d52fb081b3570c81e3a\" target=\"_blank\">What&nbsp;forces&nbsp;layout&nbsp;/&nbsp;reflow</a>&nbsp;下面引用了几篇关于&nbsp;reflow&nbsp;的相关文章，笔者挑几个重要的总结一下。</p><h3 style=\"text-indent: 0px; text-align: start;\">repaint-reflow-restyle</h3><p style=\"text-indent: 0px; text-align: start;\"><a href=\"https://link.segmentfault.com/?enc=YOd%2BKmhcWBCYABxeg6hZHA%3D%3D.CCKFKm1skuerX9p%2FVFAFW%2ByE7vVe5QUZrTF2q4iomN90tVwZlDrDrAgB%2BbTWPWcXiTtV8lPB%2FGpjPLYRWP7%2Ftg%3D%3D\" target=\"_blank\">repaint-reflow-restyle</a>&nbsp;提到现代浏览器会将多次&nbsp;dom&nbsp;操作合并，但像&nbsp;IE&nbsp;等其他内核浏览器就不保证有这样的实现了，因此给出了一个安全写法：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>// bad\nvar left = 10,\n    top = 10;\nel.style.left = left + \"px\";\nel.style.top  = top  + \"px\";\n \n// better \nel.className += \" theclassname\";\n \n// or when top and left are calculated dynamically...\n \n// better\nel.style.cssText += \"; left: \" + left + \"px; top: \" + top + \"px;\";</code></pre><p style=\"text-indent: 0px; text-align: start;\">比如用一次&nbsp;className&nbsp;的修改，或一次&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>cssText</code></span>&nbsp;的修改保证浏览器一定触发一次重排。但这样可维护性会降低很多，不太推荐。</p><h3 style=\"text-indent: 0px; text-align: start;\">avoid&nbsp;large&nbsp;complex&nbsp;layouts</h3><p style=\"text-indent: 0px; text-align: start;\"><a href=\"https://link.segmentfault.com/?enc=0mR28zjRsjaI1HH%2FTHudLg%3D%3D.4rSLmrefq9T4R%2Bbysum9bC73%2BMjx6yiP%2FWau%2BWhUhKRdloN2Vn0J039rePMRdJowKhGGIwE1WHuinhsMj1EV1X4tweRc8hOdbpGDqmv66Lw%3D\" target=\"_blank\">avoid&nbsp;large&nbsp;complex&nbsp;layouts</a>&nbsp;重点强调了读写分离，首先看下面的&nbsp;bad&nbsp;case：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>function resizeAllParagraphsToMatchBlockWidth() {\n  // Puts the browser into a read-write-read-write cycle.\n  for (var i = 0; i &lt; paragraphs.length; i++) {\n    paragraphs[i].style.width = box.offsetWidth + 'px';\n  }\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">在&nbsp;for&nbsp;循环中不断访问元素宽度，并修改其宽度，会导致浏览器执行&nbsp;N&nbsp;次&nbsp;reflow。</p><p style=\"text-indent: 0px; text-align: start;\">虽然当&nbsp;JavaScript&nbsp;运行时，前一帧中的所有旧布局值都是已知的，但当你对布局做了修改后，前一帧所有布局值缓存都会作废，因此当下次获取值时，不得不重新触发一次&nbsp;reflow。</p><p style=\"text-indent: 0px; text-align: start;\">而读写分离的话，就代表了集中读，虽然读的次数还是那么多，但从第二次开始就可以从布局缓存中拿数据，不用触发&nbsp;reflow&nbsp;了。</p><p style=\"text-indent: 0px; text-align: start;\">另外还提到&nbsp;flex&nbsp;布局比传统&nbsp;float&nbsp;重排速度快很多（3ms&nbsp;vs&nbsp;16ms），所以能用&nbsp;flex&nbsp;做的布局就尽量不要用&nbsp;float&nbsp;做。</p><h3 style=\"text-indent: 0px; text-align: start;\">really&nbsp;fixing&nbsp;layout&nbsp;thrashing</h3><p style=\"text-indent: 0px; text-align: start;\"><a href=\"https://link.segmentfault.com/?enc=C0p6qjT7phY4ZriFLwSTrg%3D%3D.3dQJKFDmgaTdksWpUOiP36%2BAnDEEeOtrfVLB6pWCZOE9PRR%2F1F4NyBDmR5NiCQYDSdLz4yZ3FHBodvNVaX07aA%3D%3D\" target=\"_blank\">really&nbsp;fixing&nbsp;layout&nbsp;thrashing</a>&nbsp;提到了用&nbsp;<a href=\"https://link.segmentfault.com/?enc=4%2BKnQqoZgEGcn9TXOAp8Iw%3D%3D.5%2Fi3xUovls91g9UXHhTWTOub%2FghnYnJ5Fnrpk%2BJVj65IFoKQ2yT6E2QWG%2BcvSPAP\" target=\"_blank\">fastdom</a>&nbsp;实践读写分离：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>ids.forEach(id =&gt; {\n  fastdom.measure(() =&gt; {\n    const top = elements[id].offsetTop\n    fastdom.mutate(() =&gt; {\n      elements[id].setLeft(top)\n    })\n  })\n})</code></pre><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>fastdom</code></span>&nbsp;是一个可以在不分离代码的情况下，分离读写执行的库，尤其适合用在&nbsp;reflow&nbsp;性能优化场景。每一个&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>measure</code></span>、<span style=\"color: rgb(214, 51, 132);\"><code>mutate</code></span>&nbsp;都会推入执行队列，并在&nbsp;<a href=\"https://link.segmentfault.com/?enc=qFyoyRQO78R4k8Uvn62C8Q%3D%3D.hXUwIQhA%2F2%2BH4GyX0c7O2Sl34dj9M11lBEodF9G8IZduSgAUcFC%2F%2Fnf3FbmFdluAzRCxVybJk0zM3pyyo3JeZg3Khfk6bMK89xNgBVPCVd8%3D\" target=\"_blank\">window.requestAnimationFrame</a>&nbsp;时机执行。</p><h2 style=\"text-indent: 0px; text-align: start;\">总结</h2><p style=\"text-indent: 0px; text-align: start;\">回流无法避免，但需要控制在正常频率范围内。</p><p style=\"text-indent: 0px; text-align: start;\">我们需要学习访问哪些属性或方法会导致回流，能不使用就不要用，尽量做到读写分离。在定义要频繁触发回流的元素时，尽量使其脱离文档流，减少回流产生的影响。</p><blockquote style=\"text-indent: 0px; text-align: start;\">讨论地址是：<a href=\"https://link.segmentfault.com/?enc=n7%2FyUD97PHyVDqjJ76vmFA%3D%3D.SrZUDKN7yJ6mrldW4WQc1zYJW0gSSdNVJW7pXxcmqlkuUGMGymhxeIEH9g8KRkp3\" target=\"_blank\">精读《web&nbsp;reflow》·&nbsp;Issue&nbsp;#420&nbsp;·&nbsp;dt-fe/weekly</a></blockquote><p style=\"text-indent: 0px; text-align: start;\"><strong>如果你想参与讨论，请&nbsp;点击这里，每周都有新的主题，周末或周一发布。前端精读&nbsp;-&nbsp;帮你筛选靠谱的内容。</strong></p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31e"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
},{
  "_id": "62c58a344edbe75044849329",
  "title": "托管式服务网络：云原生时代的应用体系架构进化",
  "cover": "",
  "body": "<div class='wang-editor'><p style=\"text-indent: 0px; text-align: start;\">简介：&nbsp;作为业内首个全托管Istio兼容的阿里云服务网格产品&nbsp;ASM，一开始从架构上就保持了与社区、业界趋势的一致性，控制平面的组件托管在阿里云侧，与数据面侧的用户集群独立。<br>作者：王夕宁</p><p style=\"text-indent: 0px; text-align: start;\">本文内容基于作者在&nbsp;2022&nbsp;年云原生产业大会上的演讲内容整理而成。</p><p style=\"text-indent: 0px; text-align: start;\">背景</p><p style=\"text-indent: 0px; text-align: start;\">回顾下应用服务架构体系的演进。从服务调用方与提供方的处理方式来看,&nbsp;可以分为&nbsp;3&nbsp;个阶段。</p><p style=\"text-indent: 0px; text-align: start;\">1.png</p><p style=\"text-indent: 0px; text-align: start;\">第一个阶段是集中式负载均衡,&nbsp;也就是说服务调用方是通过一个外部的负载均衡路由到对应的服务提供方。其优势显而易见,&nbsp;对应用本身无侵入,&nbsp;可以支持多语言多框架来开发实现应用本身,&nbsp;负载均衡统一集中管理,&nbsp;整个部署简单。但劣势也非常显著,&nbsp;因为是集中式所以导致伸缩性受限,&nbsp;同时这种集中式负载均衡的服务治理能力相对都较弱。</p><p style=\"text-indent: 0px; text-align: start;\">第二阶段是指微服务的分布式治理,&nbsp;即服务调用方内置治理能力,&nbsp;以&nbsp;SDK&nbsp;库的方式集成到应用中。带来的优势是整个伸缩性较好,&nbsp;服务治理能力强,&nbsp;但同时会注意到它的劣势,&nbsp;包括对应用本身的侵入、因为依赖于&nbsp;SDK&nbsp;所以导致对多语言支持比较困难、分布式管理部署带来的复杂性等。</p><p style=\"text-indent: 0px; text-align: start;\">第三阶段就是现在的服务网格技术。通过把这些服务治理的能力&nbsp;Sidecar&nbsp;化，就能够把服务治理的能力与应用程序本身进行了解耦，可以较好地支持多种编程语言、同时这些&nbsp;Sidecar&nbsp;能力不需要依赖于某种特定技术框架。这些&nbsp;Sidecar&nbsp;代理形成一个网状的数据平面，通过该数据平面处理和观察所有服务间的流量。控制面对这些&nbsp;Sidecar&nbsp;代理进行统一管理。但因此带来了一定的复杂度。</p><p style=\"text-indent: 0px; text-align: start;\">下图是服务网格的架构图。前面提到,&nbsp;在服务网格技术下,&nbsp;每一个应用服务实例都会伴随了一个&nbsp;Sidecar&nbsp;代理,&nbsp;业务代码不感知&nbsp;Sidecar&nbsp;的存在。这个&nbsp;Sidecar&nbsp;代理负责拦截应用的流量，并且提供流量治理、安全、可观测三大功能。</p><p style=\"text-indent: 0px; text-align: start;\">2.png</p><p style=\"text-indent: 0px; text-align: start;\">在云原生应用模型中，一个应用程序可能会包含若干个服务，每个服务又有若干个实例构成，那么这些成百上千个应用程序的&nbsp;Sidecar&nbsp;代理就形成了一个数据面,&nbsp;也就是图中的数据平面层。</p><p style=\"text-indent: 0px; text-align: start;\">而如何统一管理这些&nbsp;Sidecar&nbsp;代理,&nbsp;这就是服务网格中的控制平面部分要解决的问题。控制平面是服务网格的大脑，负责为数据平面的&nbsp;Sidecar&nbsp;代理下发配置,&nbsp;管理数据面的组件如何执行,&nbsp;同时也为网格使用人员提供统一的&nbsp;API，以便较容易地操纵网格管理能力。</p><p style=\"text-indent: 0px; text-align: start;\">通常来说,&nbsp;启用服务网格之后,&nbsp;开发人员、运维人员以及&nbsp;SRE&nbsp;团队将以统一的、声明的方式解决应用服务管理问题。</p><p style=\"text-indent: 0px; text-align: start;\">服务网格加持下的云原生应用基础设施</p><p style=\"text-indent: 0px; text-align: start;\">服务网格作为一种用来管理应用服务通信的基础核心技术,&nbsp;为应用服务间的调用带来了安全、可靠、快速、应用无感知的流量路由、安全、可观测能力。</p><p style=\"text-indent: 0px; text-align: start;\">可以看到,&nbsp;服务网格加持下的云原生应用基础设施带来了重要的优势,&nbsp;分为六个方面。image.gif</p><p style=\"text-indent: 0px; text-align: start;\">3.png</p><p style=\"text-indent: 0px; text-align: start;\">优势之一：异构服务统一治理</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;多语言多框架的互通与治理、与传统微服务体系融合的双模架构</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;精细化的多协议流量控制、东西向与南北向流量的统一管理</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;统一的异构计算基础设施的自动服务发现</p><p style=\"text-indent: 0px; text-align: start;\">优势之二：端到端的可观测</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;日志、监控与跟踪融合的一体化智能运维</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;直观易用的可视化网格拓扑、基于颜色标识的健康识别体系</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;内置最佳实践、自助式网格诊断</p><p style=\"text-indent: 0px; text-align: start;\">优势之三：零信任安全</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;端到端&nbsp;mTLS&nbsp;加密、基于属性的访问控制&nbsp;(ABAC)</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;OPA&nbsp;声明式策略引擎、全局唯一的工作负载身份（Identity）</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;带有仪表板的完整审计历史记录及洞察分析</p><p style=\"text-indent: 0px; text-align: start;\">优势之四：软硬结合性能优化</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;首个基于&nbsp;Intel&nbsp;Multi-Buffer&nbsp;技术提升&nbsp;TLS&nbsp;加解密的服务网格平台</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;NFD&nbsp;自动探测硬件特征,&nbsp;自适应支持诸如&nbsp;AVX&nbsp;指令集、QAT&nbsp;加速等特性</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;首批通过可信云服务网格平台以及性能评测先进级认证</p><p style=\"text-indent: 0px; text-align: start;\">优势之五：SLO&nbsp;驱动的应用弹性</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;服务级别目标&nbsp;(SLO)&nbsp;策略</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;基于可观测性数据的应用服务的自动弹性伸缩</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;多集群流量突发下的自动切换与故障容灾</p><p style=\"text-indent: 0px; text-align: start;\">优势之六：开箱即用扩展&amp;生态兼容</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;开箱即用的&nbsp;EnvoyFilter&nbsp;插件市场、WebAssembly&nbsp;插件全生命周期管理</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;与&nbsp;Proxyless&nbsp;模式的统一融合,&nbsp;支持&nbsp;SDK、内核&nbsp;eBPF&nbsp;方式</p><p style=\"text-indent: 0px; text-align: start;\">•&nbsp;兼容&nbsp;Istio&nbsp;生态系统,&nbsp;支持&nbsp;Serverless/Knative,&nbsp;AI&nbsp;Serving/KServe</p><p style=\"text-indent: 0px; text-align: start;\">下图是服务网格&nbsp;ASM&nbsp;产品当前的架构。作为业内首个全托管&nbsp;Istio&nbsp;兼容的服务网格产品&nbsp;ASM，一开始从架构上就保持了与社区、业界趋势的一致性，控制平面的组件托管在阿里云侧，与数据面侧的用户集群独立。ASM&nbsp;产品是基于社区开源的&nbsp;Istio&nbsp;定制实现的，在托管的控制面侧提供了用于支撑精细化的流量管理和安全管理的组件能力。通过托管模式，解耦了&nbsp;Istio&nbsp;组件与所管理的&nbsp;K8s&nbsp;集群的生命周期管理，使得架构更加灵活，提升了系统的可伸缩性。</p><p style=\"text-indent: 0px; text-align: start;\">5.png</p><p style=\"text-indent: 0px; text-align: start;\">托管式服务网格&nbsp;ASM&nbsp;在成为多种异构类型计算服务统一管理的基础设施中,&nbsp;提供了统一的流量管理能力、统一的服务安全能力、统一的服务可观测性能力、以及基于&nbsp;WebAssembly&nbsp;实现统一的代理可扩展能力,&nbsp;以此构筑企业级能力。</p><p style=\"text-indent: 0px; text-align: start;\">服务网格技术的下一站如何发展</p><p style=\"text-indent: 0px; text-align: start;\">Sidecar&nbsp;Proxy&nbsp;与&nbsp;Proxyless&nbsp;模式的融合一句话来总结的话，就是同一个控制面,&nbsp;支撑不同的数据面形态。同一个控制面就是指使用&nbsp;ASM&nbsp;托管侧组件作为统一的标准形式的控制入口,&nbsp;这个控制面运行在阿里云侧，属于&nbsp;hosted&nbsp;托管模式。</p><p style=\"text-indent: 0px; text-align: start;\">6.png</p><p style=\"text-indent: 0px; text-align: start;\">image.gif而数据面支持&nbsp;Sidecar&nbsp;Proxy&nbsp;与&nbsp;Proxyless&nbsp;模式的融合,&nbsp;其中数据面的组件虽然不是&nbsp;hosted&nbsp;托管模式,&nbsp;但是也是&nbsp;managed&nbsp;模式,&nbsp;也就是说这些组件的生命周期也是由&nbsp;ASM&nbsp;统一来管理,&nbsp;包括分发到数据面、升级、卸载等。</p><p style=\"text-indent: 0px; text-align: start;\">具体来说,&nbsp;在&nbsp;Sidecar&nbsp;Proxy&nbsp;模式下,&nbsp;除了当前标准的Envoy代理之外,&nbsp;我们的架构可以比较容易地支持其他&nbsp;Sidecar,&nbsp;譬如说&nbsp;Dapr&nbsp;Sidecar,&nbsp;当前微软&nbsp;OSM+Dapr&nbsp;就是采用了这种双&nbsp;Sidecar&nbsp;模式。</p><p style=\"text-indent: 0px; text-align: start;\">在&nbsp;Proxyless&nbsp;模式下,&nbsp;为了提升&nbsp;QPS&nbsp;降低时延,&nbsp;可以使用&nbsp;SDK&nbsp;方式,&nbsp;譬如&nbsp;gRPC&nbsp;已经支持&nbsp;xDS&nbsp;协议客户端,&nbsp;我们的&nbsp;Dubbo&nbsp;团队也在这条路上。我想今年我和北纬团队双方是可以一起在这个点上进行一些突破实现。</p><p style=\"text-indent: 0px; text-align: start;\">另外一个&nbsp;proxyless&nbsp;模式,&nbsp;就是指-&nbsp;内核&nbsp;eBPF&nbsp;+&nbsp;Node&nbsp;级&nbsp;Proxy&nbsp;方式。这个模式是对&nbsp;sidecar&nbsp;模式的一个根本性改变,&nbsp;一个节点只有一个&nbsp;Proxy，并且能力&nbsp;offload&nbsp;到节点上。这部分我们今年也会有些产品落地。</p><p style=\"text-indent: 0px; text-align: start;\">围绕服务网格技术,&nbsp;业界存在着一系列以应用为中心的生态系统,&nbsp;其中,&nbsp;阿里云托管服务网格&nbsp;ASM&nbsp;支持了以下多种生态系统。列举如下：</p><p style=\"text-indent: 0px; text-align: start;\">现代化软件开发的生命周期管理和&nbsp;DevOps&nbsp;创新</p><p style=\"text-indent: 0px; text-align: start;\">服务网格的核心原则（安全性、可靠性和可观察性）支持了现代化软件开发的生命周期管理和&nbsp;DevOps&nbsp;创新,&nbsp;为在云计算环境下如何进行架构设计、开发、自动化部署和运维提供了灵活性、可扩展性和可测试性能力。&nbsp;由此可见,&nbsp;服务网格为处理现代软件开发提供了坚实的基础，任何为&nbsp;Kubernetes&nbsp;构建和部署应用程序的团队都应该认真考虑实施服务网格。</p><p style=\"text-indent: 0px; text-align: start;\">DevOps&nbsp;的重要组成部分之一是创建持续集成和部署&nbsp;(CI/CD)，以更快更可靠地向生产系统交付容器化应用程序代码。在&nbsp;CI/CD&nbsp;Pipeline&nbsp;中启用金丝雀或蓝绿部署可为生产系统中的新应用程序版本提供更强大的测试，并采用安全回滚策略。在这种情况下，服务网格有助于在生产系统中进行金丝雀部署。当前阿里云服务网格&nbsp;ASM&nbsp;支持了与&nbsp;ArgoCD、Argo&nbsp;Rollout、KubeVela&nbsp;以及云效、Flagger&nbsp;等系统的集成实现了应用的蓝绿或金丝雀发布,&nbsp;具体如下：</p><p style=\"text-indent: 0px; text-align: start;\">ArgoCD[1]&nbsp;职责主要是监听&nbsp;Git&nbsp;仓库中的应用编排的变化，并集群中应用真实运行状态进行对比，自动/手动去同步拉取应用编排的变更到部署集群中。如何在阿里云服务网格&nbsp;ASM&nbsp;中集成&nbsp;ArgoCD&nbsp;进行应用程序的发布、更新，简化了运维成本。</p><p style=\"text-indent: 0px; text-align: start;\">Argo&nbsp;Rollouts[2]&nbsp;提供了更强大的蓝绿、金丝雀部署能力。在实践中可以将两者结合来提供基于&nbsp;GitOps&nbsp;的渐进式交付能力。</p><p style=\"text-indent: 0px; text-align: start;\">KubeVela[3]&nbsp;是一个开箱即用的、现代化的应用交付与管理平台。使用服务网格&nbsp;ASM&nbsp;结合&nbsp;KubeVela&nbsp;可以实现应用的渐进式灰度发布，达到平缓升级应用的目的。</p><p style=\"text-indent: 0px; text-align: start;\">阿里云云效流水线&nbsp;Flow[4]&nbsp;提供了基于阿里云服务网格&nbsp;ASM&nbsp;完成&nbsp;Kubernetes&nbsp;应用的蓝绿发布。</p><p style=\"text-indent: 0px; text-align: start;\">Flagger[5]&nbsp;是另外一种渐进式交付工具，可自动执行在&nbsp;Kubernetes&nbsp;上运行的应用程序的发布过程。它通过在测量指标和运行一致性测试的同时，逐渐将流量转移到新版本，降低了在生产中引入新软件版本的风险。阿里云服务网格&nbsp;ASM&nbsp;已经支持通过&nbsp;Flagger&nbsp;实现这种渐进式发布能力。</p><p style=\"text-indent: 0px; text-align: start;\">微服务框架兼容[6]</p><p style=\"text-indent: 0px; text-align: start;\">支持&nbsp;Spring&nbsp;Boot/Cloud&nbsp;应用无缝迁移至服务网格进行统一纳管和治理,&nbsp;提供了融合过程中出现的典型问题解决能力,&nbsp;包括容器集群内外服务如何互通、不同的语言服务之间如何进行互联互通等常见场景。</p><p style=\"text-indent: 0px; text-align: start;\">Serverless&nbsp;容器与基于流量模式的自动扩缩[7]</p><p style=\"text-indent: 0px; text-align: start;\">Serverless&nbsp;和&nbsp;Service&nbsp;Mesh&nbsp;是两种流行的云原生技术，客户正在探索如何从中创造价值。&nbsp;随着我们与客户深入研究这些解决方案，问题经常出现在这两种流行技术之间的交集以及它们如何相互补充上。我们能否利用&nbsp;Service&nbsp;Mesh&nbsp;来保护、观察和公开我们的&nbsp;Knative&nbsp;无服务器应用程序？在一个托管的服务网格&nbsp;ASM&nbsp;技术平台上支持基于&nbsp;Knative&nbsp;的&nbsp;Serverless&nbsp;容器,&nbsp;以及基于流量模式的自动扩缩能力,&nbsp;从中可以替换如何通过托管式服务网格来简化用户维护底层基础设施的复杂度,&nbsp;让用户可以轻松地构建自己的&nbsp;Serverless&nbsp;平台。</p><p style=\"text-indent: 0px; text-align: start;\">AI&nbsp;Serving[8]</p><p style=\"text-indent: 0px; text-align: start;\">Kubeflow&nbsp;Serving&nbsp;是谷歌牵头发起的一个基于&nbsp;Kubernetes&nbsp;支持机器学习的社区项目，它的下一代名称改为&nbsp;KServe,&nbsp;该项目的目的是可以通过云原生的方式支持不同的机器学习框架，基于服务网格实现流量控制和模型版本的更新及回滚。</p><p style=\"text-indent: 0px; text-align: start;\">零信任安全及&nbsp;Policy&nbsp;As&nbsp;Code[9]</p><p style=\"text-indent: 0px; text-align: start;\">在使用&nbsp;Kubernetes&nbsp;Network&nbsp;Policy&nbsp;实现三层网络安全控制之上，服务网格&nbsp;ASM&nbsp;提供了包括对等身份和请求身份认证能力、Istio&nbsp;授权策略以及更为精细化管理的基于&nbsp;OPA(Open&nbsp;Policy&nbsp;Agent)&nbsp;的策略控制能力。</p><p style=\"text-indent: 0px; text-align: start;\">具体来说,&nbsp;构建基于服务网格的零信任安全能力体系包括了以下几个方面：</p><p style=\"text-indent: 0px; text-align: start;\">零信任的基础：工作负载身份；如何为云原生工作负载提供统一的身份；ASM&nbsp;产品为服务网格下的每一个工作负载提供了简单易用的身份定义，并根据特定场景提供定制机制用于扩展身份构建体系,&nbsp;同时兼容社区&nbsp;SPIFFE&nbsp;标准；</p><p style=\"text-indent: 0px; text-align: start;\">零信任的载体：安全证书，ASM&nbsp;产品提供了如何签发证书以及管理证书的生命周期、轮转等机制，通过&nbsp;X509&nbsp;TLS&nbsp;证书建立身份，每个代理都使用该证书。并提供证书和私钥轮换；</p><p style=\"text-indent: 0px; text-align: start;\">零信任的引擎：策略执行，基于策略的信任引擎是构建零信任的关键核心，ASM&nbsp;产品除了支持&nbsp;Istio&nbsp;RBAC&nbsp;授权策略之外，还提供了基于&nbsp;OPA&nbsp;提供更加细粒度的授权策略；</p><p style=\"text-indent: 0px; text-align: start;\">零信任的洞察：视化与分析，ASM&nbsp;产品提供了可观测机制用于监视策略执行的日志和指标，来判断每一个策略的执行情况等；</p><p style=\"text-indent: 0px; text-align: start;\">改造为云原生应用带来的业务价值非常多，其中一个就是弹性扩缩容，它能够更好地应对流量峰值和低谷，达到降本提效的目的。服务网格&nbsp;ASM&nbsp;为应用服务间通信提供了一种非侵入式的生成遥测数据的能力,&nbsp;指标获取不需要修改应用逻辑本身。</p><p style=\"text-indent: 0px; text-align: start;\">7.png</p><p style=\"text-indent: 0px; text-align: start;\">根据监控的四个黄金指标维度（延迟、流量、错误和饱和度），服务网格&nbsp;ASM&nbsp;为管理的服务生成一系列指标,&nbsp;支持多个协议,&nbsp;包括&nbsp;HTTP，HTTP/2，GRPC，TCP&nbsp;等。</p><p style=\"text-indent: 0px; text-align: start;\">此外,&nbsp;服务网格内置了&nbsp;20&nbsp;多个监控标签,&nbsp;支持所有&nbsp;Envoy&nbsp;代理指标属性定义、通用表达式语言&nbsp;CEL,&nbsp;支持自定义&nbsp;Istio&nbsp;生成的指标。</p><p style=\"text-indent: 0px; text-align: start;\">同时，我们也在探索拓宽服务网格驱动的新场景，这里举一个AI&nbsp;Serving的示例[10]&nbsp;。</p><p style=\"text-indent: 0px; text-align: start;\">8.png</p><p style=\"text-indent: 0px; text-align: start;\">这个需求来源也是来自我们的实际客户,&nbsp;客户的使用场景就是希望在服务网格技术之上运行&nbsp;KServe&nbsp;来实现&nbsp;AI&nbsp;服务。KServe&nbsp;平滑运行于服务网格之上,&nbsp;实现模型服务的蓝/绿和金丝雀部署、修订版本之间的流量分配等能力。支持自动伸缩的&nbsp;Serverless&nbsp;推理工作负载部署、支持高可扩展性、基于并发的智能负载路由等能力。</p><p style=\"text-indent: 0px; text-align: start;\">总结</p><p style=\"text-indent: 0px; text-align: start;\">作为业内首个全托管Istio兼容的阿里云服务网格产品&nbsp;ASM，一开始从架构上就保持了与社区、业界趋势的一致性，控制平面的组件托管在阿里云侧，与数据面侧的用户集群独立。ASM&nbsp;产品是基于社区Istio定制实现的，在托管的控制面侧提供了用于支撑精细化的流量管理和安全管理的组件能力。通过托管模式，解耦了&nbsp;Istio&nbsp;组件与所管理的K8s&nbsp;集群的生命周期管理，使得架构更加灵活，提升了系统的可伸缩性。</p><p style=\"text-indent: 0px; text-align: start;\">从&nbsp;2022&nbsp;年&nbsp;4&nbsp;月&nbsp;1&nbsp;日起，阿里云服务网格&nbsp;ASM&nbsp;正式推出商业化版本,&nbsp;提供了更丰富的能力、更大的规模支持及更完善的技术保障，更好地满足客户的不同需求场景。</p><p style=\"text-indent: 0px; text-align: start;\">原文链接：<a href=\"https://link.segmentfault.com/?enc=Rw%2Fi1QpxHcOLuTp89E1mfw%3D%3D.gY4NZvoannZv%2BzXdNFfXTw4E2CRdDa%2FTTM7yUnGK7xkVuNzwbQLZvPw02gw%2BwqIa\" target=\"_blank\">http://click.aliyun.com/m/100...</a></p></div>",
  "hit_num": 2,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31f"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c5"
  }
},{
  "_id": "62c58aa84edbe75044849345",
  "title": "适配器模式在 MyBatis 中的妙用，面试可以拿来吹了！",
  "cover": "",
  "body": "<div class='wang-editor'><p style=\"text-indent: 0px; text-align: start;\">作者：须臾之余\\<br>地址：<a href=\"https://link.segmentfault.com/?enc=%2FYcsi5JwdAsib3DH352tCQ%3D%3D.PGAkKrSIfTRNm2XHm3b3l0F2FO9ybl5z2rR1y5ttCjQqy1Yej2wQcAhM9KhZFzT%2B\" target=\"_blank\">https://my.oschina.net/u/3995125</a></p><p style=\"text-indent: 0px; text-align: start;\"><strong>写在前面：设计模式源于生活，而又高于生活！</strong></p><h3 style=\"text-indent: 0px; text-align: start;\"><strong>什么是适配器模式</strong></h3><blockquote style=\"text-indent: 0px; text-align: start;\">定义：将一个系统的接口转换成另外一种形式，从而使原来不能直接调用的接口变得可以调用。</blockquote><h3 style=\"text-indent: 0px; text-align: start;\"><strong>适配器模式角色划分</strong></h3><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>适配器模式涉及3个角色：\n1.源（Adaptee）：需要被适配的对象或类型，相当于插头。\n2.适配器（Adapter）：连接目标和源的中间对象，相当于插头转换器。\n3.目标（Target）：期待得到的目标，相当于插座。\n适配器模式包括3种形式：类适配器模式、对象适配器模式、接口适配器模式（或又称作缺省适配器模式）。</code></pre><h3 style=\"text-indent: 0px; text-align: start;\"><strong>适配器模式应用场景</strong></h3><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>1、新老版本接口的兼容\n2、Mybatis多种日志框架的整合</code></pre><h2 style=\"text-indent: 0px; text-align: start;\"><strong>适配器创建的方式</strong></h2><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>1.对象适配器(组合模式)\n2.类适配器(继承模式)</code></pre><h3 style=\"text-indent: 0px; text-align: start;\"><strong>适配器快速入门例子</strong></h3><blockquote style=\"text-indent: 0px; text-align: start;\">比如早期的时候&nbsp;V1&nbsp;版本订单接口的入参为&nbsp;Map&nbsp;类型，随着业务的更新和迭代在&nbsp;V2&nbsp;版本的时候该订单接口的入参需要支持&nbsp;List&nbsp;的类型？&nbsp;请问不改变的该接口代码的情况下，如何支持&nbsp;List&nbsp;类型。</blockquote><p style=\"text-indent: 0px; text-align: start;\"><strong>1.&nbsp;源（Adaptee）：需要被适配的对象或类型，相当于插头。</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>public void froOrderMap(Map map) {\n    for (int i = 0; i &lt; map.size(); i++) {\n        // 使用I作为MapKey获取数据\n        String value = (String) map.get(i);\n        System.out.println(\"value:\" + value);\n    }\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>2.&nbsp;目标（Target）：期待得到的目标，相当于插座。</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>public interface List&lt;E&gt; extends Collection&lt;E&gt; {\n    ......\n    int size();\n    E get(int index);\n    E set(int index, E element);\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>3.&nbsp;适配器（Adapter）：连接目标和源的中间对象，相当于插头转换器</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>public class ListAdapter extends HashMap {\n\n    private List list;\n    public ListAdapter(List list) {\n        this.list = list;\n    }\n    @Override\n    public int size() {\n        return list.size();\n    }\n    @Override\n    public Object get(Object key) {\n        return list.get(Integer.valueOf(key.toString()).intValue());\n    }\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>测试运行效果</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>public class Test {\n    public static void main(String[] args) {\n        // 1.获取集合类型用户\n        List member = new MemberService().getMember();\n        //new OrderService().froOrderMap(member);\n        ListAdapter listAdapter = new ListAdapter(member);\n        new OrderService().froOrderMap(listAdapter);\n    }\n}</code></pre><h3 style=\"text-indent: 0px; text-align: start;\"><strong>使用适配器模式实现日志收集</strong></h3><blockquote style=\"text-indent: 0px; text-align: start;\">比如设计一个日志收集系统，可能会考虑文件写入、也可能考虑写入&nbsp;MQ、也可能考虑写入数据库等。</blockquote><h3 style=\"text-indent: 0px; text-align: start;\"><strong>对象适配器方式实现</strong></h3><p style=\"text-indent: 0px; text-align: start;\"><strong>定义基本实体类</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>@Data\npublic class LogBean {\n    /**\n     * 日志ID\n     */\n    private String logId;\n    /**\n     * 日志内容\n     */\n    private String logText;\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>1.&nbsp;源目标接口</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>public interface LogWriteFileService {\n\n    /**\n     * 将日志写入到文件中\n     */\n    void logWriteFile();\n    /**\n     * 从本地文件中读取日志\n     *\n     * @return\n     */\n    List&lt;LogBean&gt; readLogFile();\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>1.&nbsp;源目标接口实现类</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>public class LogWriteFileServiceImpl implements LogWriteFileService {\n    @Override\n    public void logWriteFile() {\n        System.out.println(\"&gt;&gt;&gt;将日志写入文件中...\");\n    }\n  @Override\n    public List&lt;LogBean&gt; readLogFile() {\n        LogBean log1 = new LogBean();\n        log1.setLogId(\"0001\");\n        log1.setLogText(\"Tomcat启动成功..\");\n\n        LogBean log2 = new LogBean();\n        log2.setLogId(\"0002\");\n        log2.setLogText(\"Jetty启动成功..\");\n        List&lt;LogBean&gt; listArrayList = new ArrayList&lt;LogBean&gt;();\n        listArrayList.add(log1);\n        listArrayList.add(log2);\n        return listArrayList;\n    }\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>2.&nbsp;目标接口</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>public interface LogWriteDbService {\n\n    /**\n     * 将日志写入到数据库中\n     */\n   public void writeDbFile(LogBean logBean);\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>2.&nbsp;适配器</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>//LogAdapter ：适配器\n//LogWriteDbService：目标\npublic class LogAdapter implements LogWriteDbService {\n    //源接口\n    private LogWriteFileService logWriteFileService;\n\n    public LogAdapter(LogWriteFileService logWriteFileService) {\n        this.logWriteFileService = logWriteFileService;\n    }\n\n    @Override\n    public void writeDbFile(LogBean logBean) {\n        // 1.从文件中读取日志文件\n        List&lt;LogBean&gt; logBeans = logWriteFileService.readLogFile();\n        //目标\n        // 2.写入到数据库中\n        logBeans.add(logBean);\n        System.out.println(\"&gt;&gt;&gt;将数据写入到数据库中..\");\n        // 3.写入到本地文件中\n        logWriteFileService.logWriteFile();\n    }\n}</code></pre><h3 style=\"text-indent: 0px; text-align: start;\"><strong>适配器模式优缺点</strong></h3><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>适配器模式的优点\n　　更好的复用性\n系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。\n更好的扩展性\n在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。\n\n适配器模式的缺点\n　　过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>Mbatis&nbsp;日志收集分析</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>Java开发中经常用到的日志框架有很多，Log4j、Log4j2、slf4j等等，Mybatis定义了一套统一的日志接口供上层使用，并为上述常用的日志框架提供了相应的适配器\n\n在Mybatis的日志模块中就是使用了适配器模式。Mybatis内部在使用日志模块时，使用了其内部接口 org.apache.ibatis.logging.Log,但是常用的日志框架的对外接口各不相同，Mybatis为了复用和集成这些第三方日志组件，在其日志模块中，提供了多种Adapter,将这些第三方日志组件对外接口适配成org.apache.ibatis.logging.Log，这样Myabtis 就可以通过Log接口调用第三方日志了</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>源码分析图</strong></p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\"><strong>源码剖析</strong></p><p style=\"text-indent: 0px; text-align: start;\"><strong>Mybatis&nbsp;Log&nbsp;接口：相当于源接口</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>package org.apache.ibatis.logging;\n\npublic interface Log {\n  boolean isDebugEnabled();\n  boolean isTraceEnabled();\n  void error(String s, Throwable e);\n  void error(String s);\n  void debug(String s);\n  void trace(String s);\n  void warn(String s);\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>Mybatis&nbsp;源接口实现类</strong></p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\"><strong>适配器第一种</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>package org.apache.ibatis.logging.slf4j;\n\nimport org.apache.ibatis.logging.Log;\nimport org.slf4j.Logger;\n\n//Slf4jLoggerImpl ：相当于适配器\n//Log ：相当于源接口\nclass Slf4jLoggerImpl implements Log {\n\n  //Logger：相当于目标接口\n  private Logger log;\n\n  public Slf4jLoggerImpl(Logger logger) {\n    //源=目标\n    log = logger;\n  }</code></pre><p style=\"text-indent: 0px; text-align: start;\"><strong>适配器第二种</strong></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>package org.apache.ibatis.logging.log4j2;\n\nimport org.apache.ibatis.logging.Log;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.spi.AbstractLogger;\n//Log4j2Impl ：相当于适配器\n//Log ：相当于源接口\npublic class Log4j2Impl implements Log {\n\n  private Log log;\n  //构造器\n  public Log4j2Impl(String clazz) {\n    //目标接口\n    Logger logger = LogManager.getLogger(clazz);\n    //判断类型去实现：相当于目标\n    if (logger instanceof AbstractLogger) {\n      log = new Log4j2AbstractLoggerImpl((AbstractLogger) logger);\n    } else {\n      //源=目标\n      log = new Log4j2LoggerImpl(logger);\n    }\n  }</code></pre><p style=\"text-indent: 0px; text-align: start;\"><br></p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31f"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c5"
  }
},{
  "_id": "62c58b524edbe75044849357",
  "title": "如何运营好技术相关的自媒体？",
  "cover": "",
  "body": "<div class='wang-editor'><h2 style=\"text-indent: 0px; text-align: start;\">一、前言</h2><p style=\"text-indent: 0px; text-align: start;\">今天带来的分享是：如何运营好技术相关的自媒体？</p><p style=\"text-indent: 0px; text-align: start;\">这次我会从「理论」和「实践」两块去小小分享：</p><ul style=\"text-indent: 0px; text-align: start;\"><li>「理论」分享清楚里面的商业底层逻辑和框架。对于每个赚钱的案例，底层逻辑和理论都是相通的。分享给大家，自媒体这块底层逻辑，方便大家在自己的行业里面，赚更多的钱</li><li>「实践」分享清楚自媒体如何实践赚钱，如何落地的去执行</li></ul><p style=\"text-indent: 0px; text-align: start;\">知之为知之，不知为不知。我知无不言言无不尽。大家有问题可以评论，多多交流一起学习</p><p style=\"text-indent: 0px; text-align: start;\">自媒体每个方向都34是通的，这边分享下技术自媒体的商业模式。</p><h2 style=\"text-indent: 0px; text-align: start;\">二、技术自媒体的商业模式</h2><p style=\"text-indent: 0px; text-align: start;\"><strong>2.1&nbsp;聊一聊商业模式</strong></p><p style=\"text-indent: 0px; text-align: start;\">技术自媒体，属于自媒体行业，为什么说是门生意？我认为是因为其中产生了交易。任何有交易的地方，就有生意，就有商业模式。比如你上街去某个车店买个车，去某个房屋中介买个房等等</p><p style=\"text-indent: 0px; text-align: start;\">有人买有人卖，产生了交易，就是一门生意。如果在买卖中间，插入一个环节，就可以获取交易中产生的利润：</p><ul style=\"text-indent: 0px; text-align: start;\"><li>买车，本来你可以从造车厂直接买。但是特别麻烦，车店给你挂牌、车贷等全包服务，你买的开心，买的放心。那么车店拿一辆车是批发价，给你是零售价，两个价格之差，就是利润收入。</li><li>买房，本来原房东直接卖给你即可。但是你怎么找得到呢？各种手续流程，麻烦吧。房屋中介，帮你搞定，收你中介费，这就是利润收入。</li></ul><p style=\"text-indent: 0px; text-align: start;\">这种案例太多了，大家拆解下，其实底层逻辑都是一样的。那自媒体行业是不是这样的？答案：肯定是的。</p><p style=\"text-indent: 0px; text-align: start;\">为什么说有生意，才持续？大家这个答案肯定是知道的。因为公益或者免费是不会长期持续的。只有良好的交易，才能双方获益，就会持续长久。整体来看，交易越多，国家越繁荣昌盛；生意越多，发展肯定越来越好。</p><p style=\"text-indent: 0px; text-align: start;\"><strong>2.2&nbsp;技术自媒体行业的商业模式</strong></p><p style=\"text-indent: 0px; text-align: start;\">商业模式的类型，有很多种。技术自媒体的商业模式属于客户关系管理类型，属于：免费的商业模式。这种案例很常见，比如广告、报纸免费还是不免费、Flickr&nbsp;图片分享网站等等</p><p style=\"text-indent: 0px; text-align: start;\">技术自媒体的商业模式是这样的：</p><ul style=\"text-indent: 0px; text-align: start;\"><li>免费：长期提供给用户粉丝内容价值，并产生粘性和信任：比如&nbsp;Java&nbsp;技术相关的公号，长期为&nbsp;Java&nbsp;工程师提供最新最干货的技术内容</li><li>收入：用广告位，赚流量的广告费。比如一篇文章、菜单栏、新人关注自动回复等都可以是广告位，流量变现，这就是利润收入。</li></ul><p style=\"text-indent: 0px; text-align: start;\">具体说个例子，比如极客时间出了一个&nbsp;Java&nbsp;架构师牛逼的付费课程，但需要潜在付费用户。作为&nbsp;Java&nbsp;工程师，可以直接去极客时间买。</p><p style=\"text-indent: 0px; text-align: start;\">可是谁知道有这个好的课程呢？这时候自媒体主，就可以在公众号推荐这个课程。如果粉丝经过推荐买了这个课程，自媒体主就可以收到了极客时间广告商的广告费和课程的返佣。</p><h2 style=\"text-indent: 0px; text-align: start;\">三、流量的价值和竞品分析</h2><p style=\"text-indent: 0px; text-align: start;\"><strong>3.1&nbsp;如何获取流量</strong></p><p style=\"text-indent: 0px; text-align: start;\">赚钱：第一步，获取流量、第二步，转化沉淀私域流量</p><p style=\"text-indent: 0px; text-align: start;\">获取流量，先确定这个市场的量级，就是整理流量的大小以及评估出这些流量一年能赚多少钱。如何评估呢？有两个方式：</p><ul style=\"text-indent: 0px; text-align: start;\"><li>竞品分析</li><li>用户量分析</li></ul><p style=\"text-indent: 0px; text-align: start;\"><strong>3.2&nbsp;如何评估流量的价值</strong></p><p style=\"text-indent: 0px; text-align: start;\">比如可以看行业报告，看出技术人群在中国有多少用户量</p><p style=\"text-indent: 0px; text-align: start;\">比如可以通过巨量引擎，看看极客时间&nbsp;APP&nbsp;有多少用户量</p><p style=\"text-indent: 0px; text-align: start;\">比如可以看看某个公号报价，一篇技术广告文章推广费多少，对应的阅读量是多少</p><p style=\"text-indent: 0px; text-align: start;\">那么就知道一个用户带来的广告费是多少？换算一下，就知道一年能赚多少钱。然后通过分析，发现技术自媒体行业，竞争对手多不多，那你就有很大的机会在里面赚到钱。比如哪些市场，竞争太大，你进去很难赚到钱。</p><p style=\"text-indent: 0px; text-align: start;\">研究竞争对手，还有很多好处，比如：</p><ul style=\"text-indent: 0px; text-align: start;\"><li>你知道流量是哪里来？是哪个渠道来的</li><li>你知道竞争对手流量是怎么转化的</li><li>拿不准就“抄”对手，人家怎么做，你就怎么做</li><li>把自己想象成你要获取的流量，这些用户。他们在哪里？在干什么？你就在那边获取流量</li></ul><h2 style=\"text-indent: 0px; text-align: start;\">四、技术自媒体如何运营</h2><p style=\"text-indent: 0px; text-align: start;\">没有技术的人，可以不需要技术，就能挣钱。有技术的人，觉得技术能改变一切。但往往这是错觉！任何东西都需要经营，你要做自媒体时，就需要运营。比如运营你的渠道？运营你的社群？运营你的粉丝？</p><p style=\"text-indent: 0px; text-align: start;\">下面具体聊聊自媒体运营，希望给大家一些参考：</p><ol style=\"text-indent: 0px; text-align: start;\"><li>流量永远是漏斗型</li><li>收入结构层层会有</li><li>运营全靠输出：内容型（图文、音频、视频等）</li></ol><p style=\"text-indent: 0px; text-align: start;\">比如技术自媒体，我的运营目前有三大块：</p><ol style=\"text-indent: 0px; text-align: start;\"><li>第一层（弱关系）：技术博客网站</li><li>第二层（强关系）：好友&nbsp;+&nbsp;公众号&nbsp;+&nbsp;社群&nbsp;=&nbsp;微信生态。还有&nbsp;QQ&nbsp;生态、钉钉生态等等</li><li>第三层（超强关系）：付费产品星球社群</li></ol><h3 style=\"text-indent: 0px; text-align: start;\">第一层：收入来自谷歌广告</h3><p style=\"text-indent: 0px; text-align: start;\">这一层，流量来自&nbsp;SEO。第一保证高质量的原创内容，比如&nbsp;Java&nbsp;入门系列教程等等；第二让网站内容多多的曝光，并且引流到自己的技术博客上。比如你的技术&nbsp;IP&nbsp;叫：程序员二哥。你可以将内容分发到各个技术平台和通用平台：</p><ul style=\"text-indent: 0px; text-align: start;\"><li>技术平台：CSDN、博客园、掘金等等</li><li>通用平台：知乎、脉脉等等</li></ul><p style=\"text-indent: 0px; text-align: start;\">这是图文内容，但还有音频和视频。如果你有这块能力的话，就渠道会更多：</p><ul style=\"text-indent: 0px; text-align: start;\"><li>音频：喜马拉雅等等</li><li>视频：B站、抖音、快手、微信短视频等等</li></ul><p style=\"text-indent: 0px; text-align: start;\">记住你的用户在哪，你的内容就在哪。小技巧有这些：</p><ul style=\"text-indent: 0px; text-align: start;\"><li>可以勾搭运营帮忙加精推荐</li><li>可以文章内部挂原创博客链接导流</li></ul><p style=\"text-indent: 0px; text-align: start;\">这里的收入很简单。谷歌广告类似的长期广告，挂着就行啦。案例参考：&nbsp;阮一峰&nbsp;技术网站的广告</p><h3 style=\"text-indent: 0px; text-align: start;\">第二层：收入来自广告商广告费</h3><p style=\"text-indent: 0px; text-align: start;\">上面各种渠道和个人博客渠道，会有源源不断的粉丝转化到第二层。强关系可以带给你公号粉丝、好友、微信群。记得可以相互备份，裂变活动增长。</p><p style=\"text-indent: 0px; text-align: start;\">加你好友，自动回复，让人家关注公号分享最近一篇好文章到朋友圈，拉人家如入微信群。大家找到合适的流量获取平台，就研究，单点突破即可。无非是看用户需要什么内容（图文、视频、音频、工具），那就提供之，并且带上钩子</p><p style=\"text-indent: 0px; text-align: start;\">钩子，就是比现有内容更有价值的东西，让人家关注公号领取，加好友领取等等。俗话叫钩子，其实是转化，涉及到转化流程（文案）、转化承接。钩子，需要要饵料，主要得有饵料。</p><p style=\"text-indent: 0px; text-align: start;\">这一层收入也很明显：公号软文广告、CPS&nbsp;等等。等你有流量，广告商会自动找你投放广告</p><h3 style=\"text-indent: 0px; text-align: start;\">第三层：收入来自付费产品&nbsp;-&nbsp;星球社群</h3><p style=\"text-indent: 0px; text-align: start;\">你有了初始流量池子，里面的用户会有很多痛点和痒点。满足他们，给他们提供价值，你就可以有收入。</p><p style=\"text-indent: 0px; text-align: start;\">这一层就是卖服务，类似咨询等等。需要产生更牛逼的内容&nbsp;+&nbsp;服务。让第二层的用户付费。没有套路，只有干货持续不断的精华干货内容。这就是增值服务。</p><p style=\"text-indent: 0px; text-align: start;\">比如技术人员成长、跳槽、简历都是痛点</p><p style=\"text-indent: 0px; text-align: start;\">最后一层收益最大，最难做。是做一个产品，分为几个阶段：</p><ol style=\"text-indent: 0px; text-align: start;\"><li>一心落在产品和服务上</li><li>一心落在推广和增长上</li><li>一心落在付费用户上</li><li>一心落在人性探究上</li><li>一心从人性出发来研究消费者，然后找出满足人性某个需求的产品</li></ol><p style=\"text-indent: 0px; text-align: start;\">人性是什么？人的需求又是什么？说到底，所以这些东西都在解决一个问题：如何让人变得更懒，让用户怎么用着更舒服，更爽。</p><h2 style=\"text-indent: 0px; text-align: start;\">五、小结</h2><p style=\"text-indent: 0px; text-align: start;\">综上，没有技术的人，他可以不需要技术，就能挣钱。有技术的人，觉得技术能改变一切。但往往这是错觉！</p><p style=\"text-indent: 0px; text-align: start;\">自媒体的商业模式与增长，无非两点：</p><ul style=\"text-indent: 0px; text-align: start;\"><li>做好内容，内容为王</li><li>做好流量，流量就是用户在哪，我就在哪作者：二哥&nbsp;（公号「二哥聊RPA」）关注私信我&nbsp;“666”，送《10&nbsp;大行业&nbsp;RPA&nbsp;应用场景.pdf》出处：<a href=\"https://www.bysocket.com\" target=\"_blank\">https://www.bysocket.com</a>&nbsp;欢迎转载，也请保留这段声明。谢谢！</li><li></li></ul></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31f"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c5"
  }
},{
  "_id": "62c58b934edbe75044849369",
  "title": "Node.js 中的进程和线程",
  "cover": "",
  "body": "<div class='wang-editor'><p style=\"text-indent: 0px; text-align: start;\">线程和进程是计算机操作系统的基础概念，在程序员中属于高频词汇，那如何理解呢？Node.js&nbsp;中的进程和线程又是怎样的呢？</p><h3 style=\"text-indent: 0px; text-align: start;\">一、进程和线程</h3><h4 style=\"text-indent: 0px; text-align: start;\">1.1、专业性文字定义</h4><ul style=\"text-indent: 0px; text-align: start;\"><li>进程（Process），进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器。</li><li>线程（Thread），线程是操作系统能够进行运算调度的最小单位，被包含在进程之中，是进程中的实际运作单位。</li></ul><h4 style=\"text-indent: 0px; text-align: start;\">1.2、通俗理解</h4><p style=\"text-indent: 0px; text-align: start;\">以上描述比较硬，看完可能也没看懂，还不利于理解记忆。那么我们举个简单的例子：</p><p style=\"text-indent: 0px; text-align: start;\">假设你是某个快递站点的一名小哥，起初这个站点负责的区域住户不多，收取件都是你一个人。给张三家送完件，再去李四家取件，事情得一件件做，这叫<strong>单线程，所有的工作都得按顺序执行</strong>。<br>后来这个区域住户多了，站点给这个区域分配了多个小哥，还有个小组长，你们可以为更多的住户服务了，这叫<strong>多线程</strong>，小组长是<strong>主线程</strong>，每个小哥都是一个<strong>线程</strong>。<br>快递站点使用的小推车等工具，是站点提供的，小哥们都可以使用，并不仅供某一个人，这叫<strong>多线程资源共享。</strong><br>站点小推车目前只有一个，大家都需要使用，这叫<strong>冲突</strong>。解决的方法有很多，排队等待或者等其他小哥用完后的通知，这叫<strong>线程同步</strong>。</p><p style=\"text-indent: 0px; text-align: start;\">总公司有很多站点，各个站点的运营模式几乎一模一样，这叫<strong>多进程</strong>。总公司叫<strong>主进程</strong>，各个站点叫<strong>子进程</strong>。<br>总公司和站点之间，以及各个站点互相之间，小推车都是相互独立的，不能混用，这叫<strong>进程间不共享资源</strong>。各站点间可以通过电话等方式联系，这叫<strong>管道</strong>。各站点间还有其他协同手段，便于完成更大的计算任务，这叫<strong>进程间同步</strong>。</p><p style=\"text-indent: 0px; text-align: start;\">还可以看看阮一峰的&nbsp;<a href=\"https://link.segmentfault.com/?enc=7evXo37UzMoGI5DEJrp4XA%3D%3D.TepdZ%2FNtCbcqj36JMWkprzHKbd4iasaA84JdQEDWDRLhz7T5GrrzNlsLUAUR7%2FR4XhDcGWKqeNJuWjF1gk4CTBuCL1bZ2A7C%2BScHidXrttY%3D\" target=\"_blank\">进程与线程的一个简单解释</a>。</p><h3 style=\"text-indent: 0px; text-align: start;\">二、Node.js&nbsp;中的进程和线程</h3><p style=\"text-indent: 0px; text-align: start;\">Node.js&nbsp;是单线程服务，事件驱动和非阻塞&nbsp;I/O&nbsp;模型的语言特性，使得&nbsp;Node.js&nbsp;高效和轻量。优势在于免去了频繁切换线程和资源冲突；擅长&nbsp;I/O&nbsp;密集型操作（底层模块&nbsp;libuv&nbsp;通过多线程调用操作系统提供的异步&nbsp;I/O&nbsp;能力进行多任务的执行），但是对于服务端的&nbsp;Node.js，可能每秒有上百个请求需要处理，当面对&nbsp;CPU&nbsp;密集型请求时，因为是单线程模式，难免会造成阻塞。</p><h4 style=\"text-indent: 0px; text-align: start;\">2.1、Node.js&nbsp;阻塞</h4><p style=\"text-indent: 0px; text-align: start;\">我们利用&nbsp;Koa&nbsp;简单地搭建一个&nbsp;Web&nbsp;服务，用斐波那契数列方法来模拟一下&nbsp;Node.js&nbsp;处理&nbsp;CPU&nbsp;密集型的计算任务：</p><blockquote style=\"text-indent: 0px; text-align: start;\">斐波那契数列，也称黄金分割数列，这个数列从第三项开始，每一项都等于前两项只和：0、1、1、2、3、5、8、13、21、......</blockquote><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>// app.js\nconst Koa = require('koa')\nconst router = require('koa-router')()\nconst app = new Koa()\n\n// 用来测试是否被阻塞\nrouter.get('/test', (ctx) =&gt; {\n    ctx.body = {\n        pid: process.pid,\n        msg: 'Hello World'\n    }\n})\nrouter.get('/fibo', (ctx) =&gt; {\n    const { num = 38 } = ctx.query\n    const start = Date.now()\n    // 斐波那契数列\n    const fibo = (n) =&gt; {\n        return n &gt; 1 ? fibo(n - 1) + fibo(n - 2) : 1\n    }\n    fibo(num)\n\n    ctx.body = {\n        pid: process.pid,\n        duration: Date.now() - start\n    }\n})\n\napp.use(router.routes())\napp.listen(9000, () =&gt; {\n    console.log('Server is running on 9000')\n})</code></pre><p style=\"text-indent: 0px; text-align: start;\">执行&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>node&nbsp;app.js</code></span>&nbsp;启动服务，用&nbsp;Postman&nbsp;发送请求，可以看到，计算&nbsp;38&nbsp;次耗费了&nbsp;617ms，换而言之，因为执行了一个&nbsp;CPU&nbsp;密集型的计算任务，所以&nbsp;Node.js&nbsp;主线程被阻塞了六百多毫秒。如果同时处理更多的请求，或者计算任务更复杂，那么在这些请求之后的所有请求都会被延迟执行。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">我们再新建一个&nbsp;axios.js&nbsp;用来模拟发送多次请求，此时将&nbsp;app.js&nbsp;中的&nbsp;fibo&nbsp;计算次数改为&nbsp;43，用来模拟更复杂的计算任务：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>// axios.js\nconst axios = require('axios')\n\nconst start = Date.now()\nconst fn = (url) =&gt; {\n    axios.get(`http://127.0.0.1:9000/${ url }`).then((res) =&gt; {\n        console.log(res.data, `耗时: ${ Date.now() - start }ms`)\n    })\n}\n\nfn('test')\nfn('fibo?num=43')\nfn('test')</code></pre><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">可以看到，当请求需要执行&nbsp;CPU&nbsp;密集型的计算任务时，后续的请求都被阻塞等待，这类请求一多，服务基本就阻塞卡死了。对于这种不足，Node.js&nbsp;一直在弥补。</p><h4 style=\"text-indent: 0px; text-align: start;\">2.2、master-worker</h4><p style=\"text-indent: 0px; text-align: start;\">master-worker&nbsp;模式是一种并行模式，核心思想是：系统有两个及以上的进程或线程协同工作时，master&nbsp;负责接收和分配并整合任务，worker&nbsp;负责处理任务。</p><h4 style=\"text-indent: 0px; text-align: start;\">2.3、多线程</h4><p style=\"text-indent: 0px; text-align: start;\">线程是&nbsp;CPU&nbsp;调度的一个基本单位，只能同时执行一个线程的任务，同一个线程也只能被一个&nbsp;CPU&nbsp;调用。如果使用的是多核&nbsp;CPU，那么将无法充分利用&nbsp;CPU&nbsp;的性能。</p><p style=\"text-indent: 0px; text-align: start;\">多线程带给我们灵活的编程方式，但是需要学习更多的&nbsp;Api&nbsp;知识，在编写更多代码的同时也存在着更多的风险，线程的切换和锁也会增加系统资源的开销。</p><ul style=\"text-indent: 0px; text-align: start;\"><li><a href=\"https://link.segmentfault.com/?enc=sau5ZciDlO0Xbthp6EiLNw%3D%3D.twnLe6bEFJUiQ8tJvaCeusw%2Fbof1HxXA2tM7LWcwVlRHmBpbLntWGUueMDS9%2BQbm\" target=\"_blank\">worker_threads&nbsp;工作线程</a>，给&nbsp;Node.js&nbsp;提供了真正的多线程能力。</li></ul><p style=\"text-indent: 0px; text-align: start;\">worker_threads&nbsp;是&nbsp;Node.js&nbsp;提供的一种多线程&nbsp;Api。对于执行&nbsp;CPU&nbsp;密集型的计算任务很有用，对&nbsp;I/O&nbsp;密集型的操作帮助不大，因为&nbsp;Node.js&nbsp;内置的异步&nbsp;I/O&nbsp;操作比&nbsp;worker_threads&nbsp;更高效。worker_threads&nbsp;中的&nbsp;Worker，parentPort&nbsp;主要用于子线程和主线程的消息交互。</p><p style=\"text-indent: 0px; text-align: start;\">将&nbsp;app.js&nbsp;稍微改动下，将&nbsp;CPU&nbsp;密集型的计算任务交给子线程计算：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>// app.js\nconst Koa = require('koa')\nconst router = require('koa-router')()\nconst { Worker } = require('worker_threads')\nconst app = new Koa()\n\n// 用来测试是否被阻塞\nrouter.get('/test', (ctx) =&gt; {\n    ctx.body = {\n        pid: process.pid,\n        msg: 'Hello World'\n    }\n})\nrouter.get('/fibo', async (ctx) =&gt; {\n    const { num = 38 } = ctx.query\n    ctx.body = await asyncFibo(num)\n})\n\nconst asyncFibo = (num) =&gt; {\n    return new Promise((resolve, reject) =&gt; {\n        // 创建 worker 线程并传递数据\n        const worker = new Worker('./fibo.js', { workerData: { num } })\n        // 主线程监听子线程发送的消息\n        worker.on('message', resolve)\n        worker.on('error', reject)\n        worker.on('exit', (code) =&gt; {\n            if (code !== 0) reject(new Error(`Worker stopped with exit code ${code}`))\n        })\n    })\n}\n\napp.use(router.routes())\napp.listen(9000, () =&gt; {\n    console.log('Server is running on 9000')\n})</code></pre><p style=\"text-indent: 0px; text-align: start;\">新增&nbsp;fibo.js&nbsp;文件，用来处理复杂计算任务：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>const { workerData, parentPort } = require('worker_threads')\nconst { num } = workerData\n\nconst start = Date.now()\n// 斐波那契数列\nconst fibo = (n) =&gt; {\n    return n &gt; 1 ? fibo(n - 1) + fibo(n - 2) : 1\n}\nfibo(num)\n\nparentPort.postMessage({\n    pid: process.pid,\n    duration: Date.now() - start\n})</code></pre><p style=\"text-indent: 0px; text-align: start;\">执行上文的&nbsp;axios.js，此时将&nbsp;app.js&nbsp;中的&nbsp;fibo&nbsp;计算次数改为&nbsp;43，用来模拟更复杂的计算任务：</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">可以看到，将&nbsp;CPU&nbsp;密集型的计算任务交给子线程处理时，主线程不再被阻塞，只需等待子线程处理完成后，主线程接收子线程返回的结果即可，其他请求不再受影响。<br>上述代码是演示创建&nbsp;worker&nbsp;线程的过程和效果，实际开发中，请使用线程池来代替上述操作，因为频繁创建线程也会有资源的开销。</p><blockquote style=\"text-indent: 0px; text-align: start;\">线程是&nbsp;CPU&nbsp;调度的一个基本单位，只能同时执行一个线程的任务，同一个线程也只能被一个&nbsp;CPU&nbsp;调用。</blockquote><p style=\"text-indent: 0px; text-align: start;\">我们再回味下，本小节开头提到的线程和&nbsp;CPU&nbsp;的描述，此时由于是新的线程，可以在其他&nbsp;CPU&nbsp;核心上执行，可以更充分的利用多核&nbsp;CPU。</p><h4 style=\"text-indent: 0px; text-align: start;\">2.4、多进程</h4><p style=\"text-indent: 0px; text-align: start;\">Node.js&nbsp;为了能充分利用&nbsp;CPU&nbsp;的多核能力，提供了&nbsp;cluster&nbsp;模块，cluster&nbsp;可以通过一个父进程管理多个子进程的方式来实现集群的功能。</p><ul style=\"text-indent: 0px; text-align: start;\"><li><a href=\"https://link.segmentfault.com/?enc=EQN6zYrKsrWJZFH0SxnKvw%3D%3D.%2BQwHMJ46afVsg6%2B9LBiL9h7vO52TyDiqlOI0bas5zEJ8rhW5LteR5gQZSf6G91wv\" target=\"_blank\">child_process&nbsp;子进程</a>，衍生新的&nbsp;Node.js&nbsp;进程并使用建立的&nbsp;IPC&nbsp;通信通道调用指定的模块。</li><li><a href=\"https://link.segmentfault.com/?enc=CWfu2DE3jjGHSoEqrwS9sw%3D%3D.UGSCEgoDNXsA7bOcgfVlr0fhGPLsczffyoPLo8T6kTRv1RD4snuG71yatvVc5%2FJ7\" target=\"_blank\">cluster&nbsp;集群</a>，可以创建共享服务器端口的子进程，工作进程使用&nbsp;child_process&nbsp;的&nbsp;fork&nbsp;方法衍生。</li></ul><p style=\"text-indent: 0px; text-align: start;\">cluster&nbsp;底层就是&nbsp;child_process，master&nbsp;进程做总控，启动&nbsp;1&nbsp;个&nbsp;agent&nbsp;进程和&nbsp;n&nbsp;个&nbsp;worker&nbsp;进程，agent&nbsp;进程处理一些公共事务，比如日志等；worker&nbsp;进程使用建立的&nbsp;IPC（Inter-Process&nbsp;Communication）通信通道和&nbsp;master&nbsp;进程通信，和&nbsp;master&nbsp;进程共享服务端口。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p><p style=\"text-indent: 0px; text-align: start;\">新增&nbsp;fibo-10.js，模拟发送&nbsp;10&nbsp;次请求：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>// fibo-10.js\nconst axios = require('axios')\n\nconst url = `http://127.0.0.1:9000/fibo?num=38`\nconst start = Date.now()\n\nfor (let i = 0; i &lt; 10; i++) {\n    axios.get(url).then((res) =&gt; {\n        console.log(res.data, `耗时: ${ Date.now() - start }ms`)\n    })\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">可以看到，只使用了一个进程，10&nbsp;个请求慢慢阻塞，累计耗时&nbsp;15&nbsp;秒：</p><p style=\"text-indent: 0px; text-align: start;\">接下来，将&nbsp;app.js&nbsp;稍微改动下，引入&nbsp;cluster&nbsp;模块：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>// app.js\nconst cluster = require('cluster')\nconst http = require('http')\nconst numCPUs = require('os').cpus().length\n// const numCPUs = 10 // worker 进程的数量一般和 CPU 核心数相同\nconst Koa = require('koa')\nconst router = require('koa-router')()\nconst app = new Koa()\n\n// 用来测试是否被阻塞\nrouter.get('/test', (ctx) =&gt; {\n    ctx.body = {\n        pid: process.pid,\n        msg: 'Hello World'\n    }\n})\nrouter.get('/fibo', (ctx) =&gt; {\n    const { num = 38 } = ctx.query\n    const start = Date.now()\n    // 斐波那契数列\n    const fibo = (n) =&gt; {\n        return n &gt; 1 ? fibo(n - 1) + fibo(n - 2) : 1\n    }\n    fibo(num)\n\n    ctx.body = {\n        pid: process.pid,\n        duration: Date.now() - start\n    }\n})\napp.use(router.routes())\n\nif (cluster.isMaster) {\n    console.log(`Master ${process.pid} is running`)\n    \n    // 衍生 worker 进程\n    for (let i = 0; i &lt; numCPUs; i++) {\n        cluster.fork()\n    }\n\n    cluster.on('exit', (worker, code, signal) =&gt; {\n        console.log(`worker ${worker.process.pid} died`)\n    })\n} else {\n    app.listen(9000)\n    console.log(`Worker ${process.pid} started`)\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">执行&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>node&nbsp;app.js</code></span>&nbsp;启动服务，可以看到，cluster&nbsp;帮我们创建了&nbsp;1&nbsp;个&nbsp;master&nbsp;进程和&nbsp;4&nbsp;个&nbsp;worker&nbsp;进程：</p><p style=\"text-indent: 0px; text-align: start;\">通过&nbsp;fibo-10.js&nbsp;模拟发送&nbsp;10&nbsp;次请求，可以看到，四个进程处理&nbsp;10&nbsp;个请求耗时近&nbsp;9&nbsp;秒：</p><p style=\"text-indent: 0px; text-align: start;\">当启动&nbsp;10&nbsp;个&nbsp;worker&nbsp;进程时，看看效果：</p><p style=\"text-indent: 0px; text-align: start;\">仅需不到&nbsp;3&nbsp;秒，不过进程的数量也不是无限的。在日常开发中，worker&nbsp;进程的数量一般和&nbsp;CPU&nbsp;核心数相同。</p><h4 style=\"text-indent: 0px; text-align: start;\">2.5、多进程说明</h4><p style=\"text-indent: 0px; text-align: start;\">开启多进程不全是为了处理高并发，而是为了解决&nbsp;Node.js&nbsp;对于多核&nbsp;CPU&nbsp;利用率不足的问题。<br>由父进程通过&nbsp;fork&nbsp;方法衍生出来的子进程拥有和父进程一样的资源，但是各自独立，互相之间资源不共享。通常根据&nbsp;CPU&nbsp;核心数来设置进程数量，因为系统资源是有限的。</p><h3 style=\"text-indent: 0px; text-align: start;\">三、总结</h3><p style=\"text-indent: 0px; text-align: start;\">1、大部分通过多线程解决&nbsp;CPU&nbsp;密集型计算任务的方案都可以通过多进程方案来替代；<br>2、Node.js&nbsp;虽然异步，但是不代表不会阻塞，CPU&nbsp;密集型任务最好不要在主线程处理，保证主线程的畅通；<br>3、不要一味的追求高性能和高并发，达到系统需要即可，高效、敏捷才是项目需要的，这也是&nbsp;Node.js&nbsp;轻量的特点。<br>4、Node.js&nbsp;中的进程和线程还有很多概念在文章中提到了但没展开细讲或没提到的，比如：Node.js&nbsp;底层&nbsp;I/O&nbsp;的&nbsp;libuv、IPC&nbsp;通信通道、多进程如何守护、进程间资源不共享如何处理定时任务、agent&nbsp;进程等；<br>5、以上代码可在&nbsp;<a href=\"https://link.segmentfault.com/?enc=%2F83UtDijGZ75wMiOWeca2A%3D%3D.YAsSo1lk%2FwoDorUnmhrPjKmeOjWWA1eR7o8YtTJp%2FvPS%2F2qjIy618uRLMoOLgymZN5Hu%2B7CBphWl51yylYWRuA%3D%3D\" target=\"_blank\">https://github.com/liuxy0551/node-process-thread</a>&nbsp;查看。</p><p style=\"text-indent: 0px; text-align: start;\"><br></p></div>",
  "hit_num": 2,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31f"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c5"
  }
},{
  "_id": "62c58c0d4edbe75044849386",
  "title": "Elasticsearch 实现分页的 3 种方式，还有谁不会？？",
  "cover": "",
  "body": "<div class='wang-editor'><h2 style=\"text-indent: 0px; text-align: start;\"><strong>一、from&nbsp;+&nbsp;size&nbsp;浅分页</strong></h2><p style=\"text-indent: 0px; text-align: start;\">\"浅\"分页可以理解为简单意义上的分页。</p><p style=\"text-indent: 0px; text-align: start;\">它的原理很简单，就是查询前20条数据，然后截断前10条，只返回10-20的数据。这样其实白白浪费了前10条的查询。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>GET test_dev/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"filter\": [\n        {\n          \"term\": {\n            \"age\": 28\n          }\n        }\n      ]\n    }\n  },\n  \"size\": 10,\n  \"from\": 20,\n  \"sort\": [\n    {\n      \"timestamp\": {\n        \"order\": \"desc\"\n      },\n      \"_id\": {\n        \"order\": \"desc\"\n      }\n    }\n  ]\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">其中，from定义了目标数据的偏移值，size定义当前返回的数目。默认from为0，size为10，即所有的查询默认仅仅返回前10条数据。</p><p style=\"text-indent: 0px; text-align: start;\">在这里有必要了解一下from/size的原理：</p><blockquote style=\"text-indent: 0px; text-align: start;\">因为es是基于分片的，假设有5个分片，from=100，size=10。则会根据排序规则从5个分片中各取回100条数据数据，然后汇总成500条数据后选择最后面的10条数据。</blockquote><p style=\"text-indent: 0px; text-align: start;\">做过测试，越往后的分页，执行的效率越低。总体上会随着from的增加，消耗时间也会增加。而且数据量越大，就越明显！</p><h2 style=\"text-indent: 0px; text-align: start;\"><strong>二、scroll&nbsp;深分页</strong></h2><p style=\"text-indent: 0px; text-align: start;\">from+size查询在10000-50000条数据（1000到5000页）以内的时候还是可以的，但是如果数据过多的话，就会出现深分页问题。</p><p style=\"text-indent: 0px; text-align: start;\">为了解决上面的问题，elasticsearch提出了一个scroll滚动的方式。</p><p style=\"text-indent: 0px; text-align: start;\">scroll&nbsp;类似于sql中的cursor，使用scroll，每次只能获取一页的内容，然后会返回一个<span style=\"color: rgb(214, 51, 132);\"><code>scroll_id</code></span>。根据返回的这个<span style=\"color: rgb(214, 51, 132);\"><code>scroll_id</code></span>可以不断地获取下一页的内容，所以scroll并不适用于有跳页的情景。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>GET test_dev/_search?scroll=5m\n{\n  \"query\": {\n    \"bool\": {\n      \"filter\": [\n        {\n          \"term\": {\n            \"age\": 28\n          }\n        }\n      ]\n    }\n  },\n  \"size\": 10,\n  \"from\": 0,\n  \"sort\": [\n    {\n      \"timestamp\": {\n        \"order\": \"desc\"\n      },\n      \"_id\": {\n        \"order\": \"desc\"\n      }\n    }\n  ]\n}</code></pre><ul style=\"text-indent: 0px; text-align: start;\"><li><span style=\"color: rgb(214, 51, 132);\"><code>scroll=5m</code></span>表示设置<span style=\"color: rgb(214, 51, 132);\"><code>scroll_id</code></span>保留5分钟可用。</li><li>使用scroll必须要将from设置为0。</li><li>size决定后面每次调用<span style=\"color: rgb(214, 51, 132);\"><code>_search</code></span>搜索返回的数量</li></ul><p style=\"text-indent: 0px; text-align: start;\">然后我们可以通过数据返回的<span style=\"color: rgb(214, 51, 132);\"><code>_scroll_id</code></span>读取下一页内容，每次请求将会读取下10条数据，直到数据读取完毕或者<span style=\"color: rgb(214, 51, 132);\"><code>scroll_id</code></span>保留时间截止：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>GET _search/scroll\n{\n  \"scroll_id\": \"DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAJZ9Fnk1d......\",\n  \"scroll\": \"5m\"\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">注意：请求的接口不再使用索引名了，而是&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>_search/scroll</code></span>，其中GET和POST方法都可以使用。</p><h4 style=\"text-indent: 0px; text-align: start;\"><strong>scroll删除</strong></h4><p style=\"text-indent: 0px; text-align: start;\">根据官方文档的说法，scroll的搜索上下文会在scroll的保留时间截止后自动清除，但是我们知道scroll是非常消耗资源的，所以一个建议就是当不需要了scroll数据的时候，尽可能快的把<span style=\"color: rgb(214, 51, 132);\"><code>scroll_id</code></span>显式删除掉。</p><p style=\"text-indent: 0px; text-align: start;\">清除指定的<span style=\"color: rgb(214, 51, 132);\"><code>scroll_id</code></span>：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>DELETE _search/scroll/DnF1ZXJ5VGhlbkZldGNo.....</code></pre><p style=\"text-indent: 0px; text-align: start;\">清除所有的scroll：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>DELETE _search/scroll/_all</code></pre><h2 style=\"text-indent: 0px; text-align: start;\"><strong>三、search_after&nbsp;深分页</strong></h2><p style=\"text-indent: 0px; text-align: start;\">scroll&nbsp;的方式，官方的建议不用于实时的请求（一般用于数据导出），因为每一个&nbsp;<span style=\"color: rgb(214, 51, 132);\"><code>scroll_id</code></span>&nbsp;不仅会占用大量的资源，而且会生成历史快照，对于数据的变更不会反映到快照上。</p><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>search_after</code></span>&nbsp;分页的方式是根据上一页的最后一条数据来确定下一页的位置，同时在分页请求的过程中，如果有索引数据的增删改查，这些变更也会实时的反映到游标上。但是需要注意，因为每一页的数据依赖于上一页最后一条数据，所以无法跳页请求。</p><p style=\"text-indent: 0px; text-align: start;\">为了找到每一页最后一条数据，每个文档必须有一个全局唯一值，官方推荐使用<span style=\"color: rgb(214, 51, 132);\"><code>&nbsp;_uid</code></span>&nbsp;作为全局唯一值，其实使用业务层的&nbsp;id&nbsp;也可以。</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>GET test_dev/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"filter\": [\n        {\n          \"term\": {\n            \"age\": 28\n          }\n        }\n      ]\n    }\n  },\n  \"size\": 20,\n  \"from\": 0,\n  \"sort\": [\n    {\n      \"timestamp\": {\n        \"order\": \"desc\"\n      },\n      \"_id\": {\n        \"order\": \"desc\"\n      }\n    }\n  ]\n}</code></pre><ul style=\"text-indent: 0px; text-align: start;\"><li>使用<span style=\"color: rgb(214, 51, 132);\"><code>search_after</code></span>必须要设置<span style=\"color: rgb(214, 51, 132);\"><code>from=0</code></span>。</li><li>这里我使用timestamp和<span style=\"color: rgb(214, 51, 132);\"><code>_id</code></span>作为唯一值排序。</li><li>我们在返回的最后一条数据里拿到sort属性的值传入到<span style=\"color: rgb(214, 51, 132);\"><code>search_after</code></span>。</li></ul><p style=\"text-indent: 0px; text-align: start;\">使用sort返回的值搜索下一页：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>GET test_dev/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"filter\": [\n        {\n          \"term\": {\n            \"age\": 28\n          }\n        }\n      ]\n    }\n  },\n  \"size\": 10,\n  \"from\": 0,\n  \"search_after\": [\n    1541495312521,\n    \"d0xH6GYBBtbwbQSP0j1A\"\n  ],\n  \"sort\": [\n    {\n      \"timestamp\": {\n        \"order\": \"desc\"\n      },\n      \"_id\": {\n        \"order\": \"desc\"\n      }\n    }\n  ]\n}</code></pre><p style=\"text-indent: 0px; text-align: start;\">你都学会了吗？</p><blockquote style=\"text-indent: 0px; text-align: start;\">版权声明：本文为CSDN博主「zhexiao27」的原创文章，遵循CC&nbsp;4.0&nbsp;BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：<a href=\"https://link.segmentfault.com/?enc=kVsAn%2BkT4pS65GNhwHT%2FUg%3D%3D.HqaQ2KyEWkxC%2FnJbJpctP%2B2sRZ7cO%2BpApqxMLCMaTLnlgBMvKpwS3U5443v8yuGa%2FDYNLUCO2ot%2F83%2FpxpRoxA%3D%3D\" target=\"_blank\">https://blog.csdn.net/andybeg...&nbsp;&nbsp;</a></blockquote><p style=\"text-indent: 0px; text-align: start;\"><br></p></div>",
  "hit_num": 3,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c320"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c5"
  }
},{
  "_id": "62c58e3a4edbe75044849409",
  "title": "阿里云混合云密码应用分析",
  "cover": "",
  "body": "<div class='wang-editor'><p style=\"text-indent: 0px; text-align: start;\">简介：&nbsp;“十四五”是国家数字化战略转型建设的关键阶段，5G、人工智能、云计算、大数据等新一代信息技术进一步加快了工业和信息化领域数字化转型的步伐。与此同时，也带来了新的网络安全风险。加快推动商用密码与新一代信息技术的深度融合和协同创新，增加商用密码技术在工业和信息化领域应用推广，提升安全保障能力已达成业界广泛共识。<br>banner.jpg</p><p style=\"text-indent: 0px; text-align: start;\">“十四五”是国家数字化战略转型建设的关键阶段，5G、人工智能、云计算、大数据等新一代信息技术进一步加快了工业和信息化领域数字化转型的步伐。与此同时，也带来了新的网络安全风险。加快推动商用密码与新一代信息技术的深度融合和协同创新，增加商用密码技术在工业和信息化领域应用推广，提升安全保障能力已达成业界广泛共识。</p><p style=\"text-indent: 0px; text-align: start;\">为进一步推动商用密码应用，促进商用密码产业供需双向对接，工业和信息化部商用密码应用产业促进联盟（CCPA）联合产学研各方力量举办了系列活动，6月24日，“工业和信息化领域商用密码应用推进技术论坛”第二期在线如期举行。本期技术论坛特邀行业专家及头部企业代表，共同探索密码在新技术领域的应用落地路径，推动商用密码技术创新应用发展。阿里云智能混合云平台高级技术专家杨晓黎应邀参加本次技术论坛，分享了「阿里云混合云密码应用分析」，深入交流了阿里云混合云对云上密码应用场景的分析，以及面临的挑战与思考。</p><p style=\"text-indent: 0px; text-align: start;\">混合云是实现政企数智化创新最佳选择</p><p style=\"text-indent: 0px; text-align: start;\">如今政企数字化转型全面进入“云”时代，云已经成为了数字化转型的基石和枢纽，混合云是实现政企数智化创新的优选方案。阿里云混合云是首个全自研大规模成熟商用的原生混合云。基于阿里云分布式架构，针对企业级市场使用特点，为客户量身打造的开放、统一、可信的企业级云平台，混合云与阿里云公共云同根同源，客户可在任何环境本地化部署公共云产品及服务，并具备一键弹性至公共云的能力，让客户随时随地尽享混合云产品服务。</p><p style=\"text-indent: 0px; text-align: start;\">从阿里云混合云成立至今经历了从1.0到2.0的进化。Apsara&nbsp;Stack&nbsp;2.0在继承公共云稳定基因和一致性体验的同时，对比1.0主要有以下几个变化。首先，飞天2.0完全继承了阿里云公共云最新的技术成果，具备一云多芯、一云多Region和全场景灾备的能力。同时，对云的“管理”升级成了对云的“运营”。此外，当前的阿里云混合云不仅有中心云，也有我们的边缘云，构筑了云边一体的完整方案。今天的Apsara&nbsp;Stack&nbsp;2.0已经从单一的私有云场景演进到服务于大型集团&amp;行业云场景，成为企业客户上云的最佳选择。</p><p style=\"text-indent: 0px; text-align: start;\">阿里云混合云密码应用场景分析</p><p style=\"text-indent: 0px; text-align: start;\">安全面临的挑战<br>在数字化的整体趋势下，互联网和大数据给人们的生活方式带来了巨大的改变，随着云计算的日益普及，各行各业都在进行信息化改造和上云，这也对信息的安全提出了更高的要求。在当下，信息安全已经不仅仅只是关乎个人隐私，还会危及到国计民生，云计算做为信息的基础设施，承载的数据越来越多，数据安全影响面越来越大，仅仅从勒索软件的危害，就可见一斑，勒索团伙以窃取的数据为要挟，单次敲诈金额可达千万美金，近年来几乎所有国家的政府、金融、教育、医疗、制造、交通、能源等行业均受到影响&nbsp;可以说有互联网的地方就可能存在攻击。</p><p style=\"text-indent: 0px; text-align: start;\">挑战.jpg</p><p style=\"text-indent: 0px; text-align: start;\">近几年来信息安全引起国家的重视，上升到了国家安全的高度，多个关系网络安全的法规陆续出台，各个行业的技术规范也都对安全提出明确的要求。这就要求我们在云计算上密码应用的范围会越来越广、越来越深入。</p><p style=\"text-indent: 0px; text-align: start;\">夯实密码基础服务，服务上层应用<br>应用的对象为云系统，云系统从可变更人角度分为云平台和租户侧，除了最底层的物理基础设施，云平台自身还包括云平台基础服务层、融合管控层和云服务与接口层，层和层之间、服务和服务之间存在各种相互依赖。</p><p style=\"text-indent: 0px; text-align: start;\">平台架构.jpg</p><p style=\"text-indent: 0px; text-align: start;\">如何让整个云平台快速落地实现密码应用，阿里云混合云给密码应用改造确定的原则是通过“夯实密码基础服务、服务上层应用”来实现密码改造的全路径。</p><p style=\"text-indent: 0px; text-align: start;\">具体需要考虑的几个方面包括：</p><ol style=\"text-indent: 0px; text-align: start;\"><li>夯实密码应用基础服务，这也是支撑整个云平台密码应用的基础；</li><li>在底层基础设施能力具备的基础上，需要考虑上层云平台如何使用这些密码基础服务，以达到业务无感知；</li><li>业务的连续性不受影响，可扩展性良好。</li></ol><p style=\"text-indent: 0px; text-align: start;\">解决了以上三个方面整个云平台其实就初步具备了密码应用能力。但这还不够！接下来需要思考的是可视化能力，可见可查，以方便审查。</p><p style=\"text-indent: 0px; text-align: start;\">对云平台，由阿里云混合云提供密码技术应用，而对租户侧，是由客户来实施密码应用改造，阿里云混合云提供密码应用的能力，以方便客户对应用实施密码技术应用。</p><p style=\"text-indent: 0px; text-align: start;\">平台访问边界<br>我们以双机房容灾场景为分析目标。</p><p style=\"text-indent: 0px; text-align: start;\">访问场景.jpg</p><p style=\"text-indent: 0px; text-align: start;\">可控机房我们视为相对安全区域，对安全区域外到安全区域内的访问，安全性要求更高；之所以称为可控机房，从技术上需要具备两个层面的的密码技术控制访问：一个是物理环境管理，另外一个是网络访问边界。</p><p style=\"text-indent: 0px; text-align: start;\">物理环境管理主要为机房的门禁、监控等措施，能够从物理上隔离开风险；</p><p style=\"text-indent: 0px; text-align: start;\">网络访问边界包含三个场景：</p><ol style=\"text-indent: 0px; text-align: start;\"><li>通过互联网到云平台的访问：这种场景主要为通过VPN接入；</li><li>局域网访问：也就是通过办公网接入运营、运维平台等实施运营和运维操作；</li><li>机房间的通信：这种通信包含了不同云产品之间的访问以及产品内部不同机房间的数据同步等。</li></ol><p style=\"text-indent: 0px; text-align: start;\">云平台上的应用<br>混合云管理平台（Apsara&nbsp;Uni-manager）的主要作用是提供产品和服务给客户使用，并不是为了直接提供应用。是面向阿里云专有云和混合云场景的企业级云管理平台。它提供全方位的云资源供给、运维和运营管理能力，具备一体化管控、智能化运维、精细化运营及个性化扩展等核心竞争力，简化混合云管理，提升用户体验，加速企业数字化转型。</p><p style=\"text-indent: 0px; text-align: start;\">云管.jpg</p><p style=\"text-indent: 0px; text-align: start;\">混合云管理平台（Apsara&nbsp;Uni-manager）由以下几部分组成：</p><p style=\"text-indent: 0px; text-align: start;\">运营控制台：通过一体化的管控入口，提供精细化资源治理、智能化数据分析和个性化功能扩展等能力，降低企业的云管理成本。</p><p style=\"text-indent: 0px; text-align: start;\">运维控制台：通过自动化的运维流程，提供主动式监控告警、根源问题定位和故障自动修复等能力，降低云环境的运维成本，保障云环境安全稳定运行。</p><p style=\"text-indent: 0px; text-align: start;\">智能指挥官：通过高可视化的数据大屏，为企业IT的决策者提供了混合云多维度的全景数据展示，包括混合云总体运行状态和资源使用情况，并支持针对不同角色设置不同的首页仪表盘。</p><p style=\"text-indent: 0px; text-align: start;\">混合云平台密码应用技术<br>定义了边界和平台上的应用，那么密码应用的范围就清楚了，对于云平台密码技术应用，密码应用基础服务是基础设施，提供服务给上层云产品，满足身份鉴别、信息传输加密、重要数据落盘加密、和日志完整性等对密码技术的需要。</p><p style=\"text-indent: 0px; text-align: start;\">平台.jpg</p><p style=\"text-indent: 0px; text-align: start;\">引入的密码基础服务包含：云服务密码机、密钥管理服务、证书基础服务、认证和鉴权服务、国密算法库以及协议栈里的国密算法套件。</p><p style=\"text-indent: 0px; text-align: start;\">具体到平台改造上，包含了如下几个场景：</p><ol style=\"text-indent: 0px; text-align: start;\"><li>互联网访问场景下的用户登录身份鉴别、数据传输加密、重要信息落盘加密保护和日志完整性以达到从用户登录开始到操作可追溯，数据有保护；</li><li>局域网访问场景下，控制台和堡垒机的身份鉴别、传输加密、账密和个人信息等落盘加密、日志的完整性保护；</li><li>机房间通信的传输加密。</li></ol><p style=\"text-indent: 0px; text-align: start;\">混合云租户侧密码应用技术<br>平台的密码应用是租户侧的能力，阿里云混合云在租户侧主要提供密码应用的能力，整体建设思路：</p><ol style=\"text-indent: 0px; text-align: start;\"><li>全面合规对标，分别建设面向云平台和云租户的独立密码服务体系；</li><li>IAAS层密码服务体系以符合安全等级要求的密码硬件方式提供，满足密评要求；</li><li>提供密码PaaS层服务，面向各租户提供合规密码服务，满足密评要求；</li><li>租户层面统一实现对底层密码资源、密钥资源的合规管理，满足密评要求；</li><li>提供统一、标准、流程化的密码服务接口及指南，快速与应用体系整合。</li></ol><p style=\"text-indent: 0px; text-align: start;\">租户侧.jpg</p><p style=\"text-indent: 0px; text-align: start;\">客户可以使用这些能力来实现密码改造，分为两种方式提供：第一种是密码服务，借助密码产品，提供如签名验签、数据加解密等服务；第二种是云产品本身提供的密码应用能力，如WAF上的SSL卸载，存储落盘加密能力等。</p><p style=\"text-indent: 0px; text-align: start;\">国内首家通过商用密码应用安全性评估</p><p style=\"text-indent: 0px; text-align: start;\">在密码法颁布之后，阿里云凭借自研飞天云操作系统的全方位安全能力,成为国内首家通过云平台密评的云厂商,客户在阿里云上能享受到更安全、合规的云服务。2.jpg</p><p style=\"text-indent: 0px; text-align: start;\">阿里云一直重视密码标准工作,密切关注密码领域相关技术标准要求,并按照密评标准要求对云平台进行了持续、彻底的改造,使云平台在底座架构的关键数据链路上能够符合密评标准要求。</p><p style=\"text-indent: 0px; text-align: start;\">更多产品资讯欢迎访问#阿里云混合云&nbsp;#阿里云专有云&nbsp;或加入钉群（32450454）交流。</p><p style=\"text-indent: 0px; text-align: start;\">原文链接：<a href=\"https://link.segmentfault.com/?enc=G31yY8UUQv0cdI87hSxHRQ%3D%3D.Y2kBRX3HA4QENC6CNfFgbRBz%2FqlyH9v7UNLN8AfpWVc%2FXBbi5m6bfWhiCsTDr8I6\" target=\"_blank\">http://click.aliyun.com/m/100...</a></p><p style=\"text-indent: 0px; text-align: start;\"><br></p></div>",
  "hit_num": 3,
  "like_num": 0,
  "author": {
    "_id": "62c579674edbe75044849038"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c5"
  }
},{
  "_id": "62c58e954edbe75044849432",
  "title": "几行代码就能实现复杂的 Excel 导入导出，这个工具类真心强大！",
  "cover": "",
  "body": "<div class='wang-editor'><h3 style=\"text-indent: 0px; text-align: start;\"><strong>功能介绍</strong></h3><h4 style=\"text-indent: 0px; text-align: start;\"><strong>IMPORT</strong></h4><ul style=\"text-indent: 0px; text-align: start;\"><li>ExcelHandle&nbsp;核心处理器</li><li>ExcelWorkbookManage&nbsp;excel所有工作表管理</li><li>ExcelInitConfig&nbsp;配置文件初始化</li><li>AbstractFileParser&nbsp;文件转换类</li></ul><h4 style=\"text-indent: 0px; text-align: start;\"><strong>alanpoi&nbsp;import有何优势？</strong></h4><ul style=\"text-indent: 0px; text-align: start;\"><li><strong>用户不需要额外引入poi等繁琐的jar</strong></li><li><strong>毫秒级解析大文件，支持一键解析多sheet页签，不需要自己按照一定的格式循环匹配解析所有数据</strong></li><li><strong>不管你的系统多么复杂，有多少个导入，</strong><span style=\"color: rgb(214, 51, 132);\"><code>alanpoi</code></span><strong>全部支持，而且准确返回你需要的对象，减轻开发者工作量</strong></li><li><strong>目前外界业务越来越复杂，对各个功能要求也越来越严格，当然导入也不例外，alanpoi支持错误一键回写到excel，对应到每一行</strong></li><li>alanpoi灵活可扩展，提供了ExcelConsumeInterface接口，可继承它，实现valid、error、end三个方法编写自己的业务</li><li>valid:&nbsp;方法参数返回excel所有数据，用户可进行自我校验error:&nbsp;导入错误会回调end:&nbsp;方法参数返回校验成功的数据，valid校验失败的数据不会返回，用户可以自己操作持久化或者其他业务</li></ul><h3 style=\"text-indent: 0px; text-align: start;\"><strong>怎么使用alanpoi实现导入</strong></h3><p style=\"text-indent: 0px; text-align: start;\">项目中使用:</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.alanpoi&lt;/groupId&gt;\n    &lt;artifactId&gt;alanpoi-analysis&lt;/artifactId&gt;\n    &lt;version&gt;1.3.0&lt;/version&gt;\n&lt;/dependency&gt;</code></pre><blockquote style=\"text-indent: 0px; text-align: start;\">简单一句话：一配置一继承一调用</blockquote><h4 style=\"text-indent: 0px; text-align: start;\"><strong>一配置</strong></h4><p style=\"text-indent: 0px; text-align: start;\">在项目resources目录中新建<span style=\"color: rgb(214, 51, 132);\"><code>excel-config.xml</code></span>文件，cosume中配置自己的消费类路径，继承<span style=\"color: rgb(214, 51, 132);\"><code>ExcelConsumeInterface</code></span>接口，sheet中的vo是把当前sheet序列化的对象路径，column中当然就是配置vo中的属性了。</p><p style=\"text-indent: 0px; text-align: start;\">其中name可选字段，填了就是按照这个匹配excel列名，不填就是按照offset顺序；导入包含多个sheet就配置多个</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>&lt;?xml version = \"1.0\" encoding = \"GB2312\"?&gt;\n&lt;exg name=\"excelId\" version=\"1.0\" file-type=\"excel\"&gt;\n  &lt;excel id=\"ACCOUNT\" consume=\"com.xxx.FinAccountImportHandler\"&gt;\n     &lt;sheet index=\"0\" row-start=\"1\" column-start=\"0\"\n            vo=\"com.xxx.vo.FinAccountImportVO\"&gt;\n         &lt;column name=\"公司/供应商编号\" offset=\"1\"&gt;companyCode&lt;/column&gt;\n         &lt;column name=\"公司/供应商名称\" offset=\"2\"&gt;companyName&lt;/column&gt;\n         &lt;column name=\"银行账号\" offset=\"3\"&gt;bankAccount&lt;/column&gt;\n         &lt;column name=\"开户银行\" offset=\"4\"&gt;bankName&lt;/column&gt;\n     &lt;/sheet&gt;\n &lt;/excel&gt;\n&lt;/exg&gt;</code></pre><h4 style=\"text-indent: 0px; text-align: start;\"><strong>一继承</strong></h4><p style=\"text-indent: 0px; text-align: start;\"><span style=\"color: rgb(214, 51, 132);\"><code>consume</code></span>类继承<span style=\"color: rgb(214, 51, 132);\"><code>ExcelConsumeInterface</code></span>接口，实现方法</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>/**\n * when error will 调用\n *\n * @param excelError\n */\nvoid error(ExcelError excelError);\n\n/**\n * custom valid data\n *\n * @param workbookId\n * @param sheetDataList\n */\nvoid validData(String workbookId, List&lt;ExcelSheetData&gt; sheetDataList, Map&lt;Serializable, Object&gt; excelParam);\n\n/**\n * @param sheetDataList return success data\n */\nvoid end(List&lt;ExcelSheetData&gt; sheetDataList, Map&lt;Serializable, Object&gt; excelParam);</code></pre><h4 style=\"text-indent: 0px; text-align: start;\"><strong>一调用</strong></h4><p style=\"text-indent: 0px; text-align: start;\">用户调用<span style=\"color: rgb(214, 51, 132);\"><code>ExcelExportUtil</code></span>类的<span style=\"color: rgb(214, 51, 132);\"><code>customImportData</code></span>即可，参数excelId就是<span style=\"color: rgb(214, 51, 132);\"><code>excel-conifg.xml</code></span>中配置的id</p><h3 style=\"text-indent: 0px; text-align: start;\"><strong>Export</strong></h3><h4 style=\"text-indent: 0px; text-align: start;\"><strong>描叙</strong></h4><p style=\"text-indent: 0px; text-align: start;\">能够用一行代码实现绝不用第二行，如果一行不行，那就再加一行！</p><h4 style=\"text-indent: 0px; text-align: start;\"><strong>模式</strong></h4><p style=\"text-indent: 0px; text-align: start;\">注解模式导出：</p><ul style=\"text-indent: 0px; text-align: start;\"><li><strong>ExcelSheet注解：</strong>&nbsp;<strong>用于导入类上，可制定sheet名，列头的颜色、字体、高度、宽度</strong></li><li><strong>ExcelColum注解:</strong>&nbsp;<strong>用于导入类的属性上，可指定列头的名称，单元格的样式</strong></li><li><strong>DateFormat注解:</strong>&nbsp;<strong>用于导入类的属性上,&nbsp;可以按照指定格式输出到excel,默认\"</strong><span style=\"color: rgb(214, 51, 132);\"><code>yyyy/MM/dd</code></span><strong>\"</strong></li><li><strong>NumFormat注解:</strong>&nbsp;<strong>用于导入类的属性上，可以按照指定格式输出到excel,默认\"</strong><span style=\"color: rgb(214, 51, 132);\"><code>00.00</code></span><strong>\"</strong></li></ul><p style=\"text-indent: 0px; text-align: start;\">样例：</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>@ExcelSheet(name = \"测试\", backColor = AlanColors.GREEN, font = \"宋体\", fontSize = 25)\n@Data\npublic class ExportVO {\n    @ExcelColumn(name = \"名称\", width = 32, link = \"${url}\")\n    private String name;\n\n    @ExcelColumn(name = \"值\")\n    private String value;\n\n    @ExcelColumn(name = \"金额\")\n    @NumFormat(value = \"0000.00##\")\n    private BigDecimal amount;\n\n    @ExcelColumn(name = \"时间格式化\")\n    @DateFormat(value = \"yyyy-MM-dd hh:mm:ss\")\n    private Date dateTime;\n\n    @DateFormat\n    @ExcelColumn(name = \"日期格式化\")\n    private java.sql.Date date;\n    \n    @ExcelColumn(isExist = false)\n    private String url;\n}</code></pre><h4 style=\"text-indent: 0px; text-align: start;\"><strong>使用</strong></h4><p style=\"text-indent: 0px; text-align: start;\">方式一.&nbsp;直接导出到浏览器</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>ExcelExportUtil.export(Colletion&lt;?&gt;,Class,HttpServletRequest,HttpServletResponse,fileName);</code></pre><p style=\"text-indent: 0px; text-align: start;\">方式二.&nbsp;调用<span style=\"color: rgb(214, 51, 132);\"><code>getWorkbook</code></span>获取工作表，自行处理<span style=\"color: rgb(214, 51, 132);\"><code>workbook</code></span></p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>ExcelExportUtil.getWorkbook(Collection&lt;?&gt; singleSheetData, Class&lt;?&gt; c)</code></pre><h4 style=\"text-indent: 0px; text-align: start;\"><strong>高级使用</strong></h4><p style=\"text-indent: 0px; text-align: start;\">示例一：导出指定列（动态导出列）</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>List&lt;ExportVO&gt; list = new ArrayList&lt;&gt;();\nfor (int i = 0; i &lt; 500; i++) {\n    ExportVO exportVO = new ExportVO();\n    exportVO.setName(\"name\" + i);\n    exportVO.setValue(new BigDecimal(123.11 + i * 0.09));\n    exportVO.setAmount(new BigDecimal(6666.666 + i * 10));\n    exportVO.setDate(new Date(132324343 + i * 100));\n    exportVO.setDateTime(new java.util.Date());\n    list.add(exportVO);\n}\nList&lt;String&gt; colList = new ArrayList&lt;&gt;();\n//按照顺序仅导出add的列\ncolList.add(\"name\");\ncolList.add(\"value\");\n//调用获取workbook对象；也可以直接调用exportSpecifyCol方法导出到浏览器\nWorkbook workbook = ExcelExportUtil.getWorkbookSpecifyCol(list, ExportVO.class, colList);</code></pre><p style=\"text-indent: 0px; text-align: start;\">示例二：多sheet页签导出</p><pre style=\"text-indent: 0px; text-align: start; line-height: 1.5;\"><code>List&lt;ExportVO&gt; list = new ArrayList&lt;&gt;();\nList&lt;Export2VO&gt; list2 = new ArrayList&lt;&gt;();\nfor (int i = 0; i &lt; 500; i++) {\n    ExportVO exportVO = new ExportVO();\n    exportVO.setName(\"name\" + i);\n    exportVO.setValue(new BigDecimal(123.11 + i * 0.09));\n    exportVO.setAmount(new BigDecimal(6666.666 + i * 10));\n    exportVO.setDate(new Date(132324343 + i * 100));\n    exportVO.setDateTime(new java.util.Date());\n    list.add(exportVO);\n    Export2VO export2VO = new Export2VO();\n    export2VO.setName(\"name\" + i);\n    export2VO.setValue(\"value\" + i);\n    export2VO.setAmount(new BigDecimal(6666.666 + i * 10));\n    export2VO.setDate(new Date(132324343 + i * 100));\n    export2VO.setDateTime(new java.util.Date());\n    list2.add(export2VO);\n}\nMap&lt;Class&lt;?&gt;, Collection&lt;?&gt;&gt; map = new HashMap&lt;&gt;();\nmap.put(ExportVO.class, list);\nmap.put(Export2VO.class, list2);\n//调用获取workbook对象；也可以直接调用exportByMultiSheet方法导出到浏览器\nWorkbook workbook = ExcelExportUtil.getWorkbookByMultiSheet(map);</code></pre><p><br></p></div>",
  "hit_num": 1,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c322"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c5"
  }
},{
  "_id": "62c59097ad3d4af82fb0c9da",
  "title": "\"整洁架构\"和商家前端的重构之路",
  "cover": "",
  "body": "<article class=\"article fmt article-content\"><h2 id=\"item-1\">1. 背景</h2><p>团队归属于后方业务支撑部门，组内的项目都以pc中后台应用为主。对比移动端应用，代码库比较庞大，业务逻辑也相对复杂。在持续的迭代过程中，我们发现当前的代码仓库仍然有不少可以优化的点：</p><h4>可以减弱对ui框架的依赖</h4><p>21年前端平台决定技术栈统一迁移到React生态，后续平台的基础建设也都围绕React展开，这就使得商家使用Vue生态做开发的系统面临技术栈迁移的难题，将业务逻辑和UI框架节藕变得异常重要。</p><h4>代码风格可以更加统一</h4><p>随着代码量和团队成员的增加，应用里风格迥异的代码也越来越多。为了能够持续迅速的进行迭代，团队急需一套统一的顶层代码架构设计方案。</p><h4>可以集成自动化测试用例</h4><p>随着业务变得越来越复杂，在迅速的迭代过程中团队需要频繁地对功能进行回归，因此我们对于自动化单测用例的诉求也变的越来越强烈。</p><p>为了完成以上的优化，四组对现有的应用架构做了一次重构，而重构的核心就是整洁架构。</p><h2 id=\"item-2\">2. 整洁架构(The Clean Architecture)</h2><p>整洁架构(The clean architecture)是由 Robert C. Martin (Uncle Bob)在2012年提出的一套代码组织的理念，其核心主要是依据各部分代码作用的不同将其拆分成不同的层次，在各层次间制定了明确的依赖原则，以达到以下目的：</p><ol><li>与框架无关：无论是前端代码还是服务端代码，其逻辑本身都应该是独立的，不应该依赖于某一个第三方框架或工具库。一套独立的代码可以把第三方框架等作为工具使用。</li><li>可测试：代码中的业务逻辑可以在不依赖ui、数据库、服务器的情况下进行测试。</li><li>和ui无关：代码中的业务逻辑不应该和ui做强绑定。比如把一个web应用切换成桌面应用，业务逻辑不应该受到影响。</li><li>和数据库无关：无论数据库用的是mysql还是mongodb，无论其怎么变，都不该影响到业务逻辑。</li><li>和外部服务无关：无论外部服务怎么变，都不影响到使用该服务的业务逻辑。<br><span class=\"img-wrap\"><img class=\"lazy entered loaded exited\" referrerpolicy=\"no-referrer\" data-src=\"/img/bVc0Hcu\" alt=\"\" title=\"\" data-ll-status=\"loaded\" src=\"/img/bVc0Hcu\"></span></li></ol><p>为了实现以上目的，整洁架构把应用划分成了entities、use cases、interface adapters(MVC、MVP等)、Web/DB等至少四层。这套架构除了分层之外，在层与层之间还有一个非常明确的依赖关系，外层的逻辑依赖内层的逻辑。</p><p><strong>Entity</strong><br>entities封装了企业级的业务逻辑和规则。entities没有什么固定的形式，无论是一个对象也好，是一堆函数的集合也好，唯一的标准就是能够被企业的各个应用所复用。</p><p><strong>Use Case</strong><br>entities封装了企业里最通用的一部分逻辑，而应用各自的业务逻辑就都封装在use case里面。日常开发中最常见的对于某个模型的crud操作就属于usecase这一层。</p><p><strong>Interface Adapter</strong><br>这一层类似于胶水层，需要负责内圈的entity和use case同外圈的external interfaces之间的数据转化。需要把外层服务的数据转化成内层entity和usecase可以消费的数据，反之亦然。如上面图上画的，这一层有时候可能很简单(一个转化函数)， 有时候可能复杂到包含一整个MVC/MVP的架构。</p><p><strong>External Interfaces</strong><br>我们需要依赖的外部服务，第三方框架，以及需要糊的页面UI都归属在这一层。这一层完全不感知内圈的任何逻辑，所以无论这一层怎么变(ui变化)，都不应该影响到内圈的应用层逻辑(usecase)和企业级逻辑(entity)。</p><p><strong>依赖原则</strong><br>在整洁架构的原始设计中，并不是强制一定只能写这么四层，根据业务的需要还可以拆分的更细。不过无论怎么拆，都需要遵守前面提到的从外至内的依赖原则。即entity作为企业级的通用逻辑，不能依赖任何模块。而外层的ui等则可以使用usecase、entity。</p><h2 id=\"item-3\">3. 重构</h2><p>前面介绍了当前代码库目前的一些具体问题，而整洁架构的理念正好可以帮助我们优化代码可维护性。</p><p>作为前端，我们的业务逻辑不应该依赖视图层(ui框架及其生态)，同时应当保证业务逻辑的独立性和可复用性(usecase &amp; entity)。最后，作为数据驱动的端应用，要保证应用视图渲染和业务逻辑等不受数据变动的影响(adapter &amp; entity)。</p><p>根据以上的思考，我们对“整洁架构”做了如下落地。</p><p><strong>Entities</strong><br>对于前端应用来说，在entity层我们只需要将服务端的生数据做一层简单的抽象，生成一个贫血对象给后续的渲染和交互逻辑使用。<br><span class=\"img-wrap\"><img class=\"lazy\" referrerpolicy=\"no-referrer\" data-src=\"/img/bVc0HpC\" alt=\"\" title=\"\"></span><br><span class=\"img-wrap\"><img class=\"lazy\" referrerpolicy=\"no-referrer\" data-src=\"/img/bVc0HpE\" alt=\"\" title=\"\"></span><br><span class=\"img-wrap\"><img class=\"lazy\" referrerpolicy=\"no-referrer\" data-src=\"/img/bVc0Hp6\" alt=\"\" title=\"\"></span></p><p>以上是商家后台订单模型的entity工厂函数，工厂主要负责对服务端返回的生数据进行加工处理，让其满足渲染层和逻辑层的要求。除了抽象数据之外，可以看到在entity工厂还对数据进行了校验，将脏数据、不符合预期的数据全部处理掉或者进行兜底(具体操作要看业务场景)。</p><p>有一点需要注意的是，在设计entity的时候(尤其是基础entity)需要考虑复用性。举个例子，在上面orderEntity的基础上，我们通过简单的组合就可以生成一个虚拟商品订单entity:<br><span class=\"img-wrap\"><img class=\"lazy\" referrerpolicy=\"no-referrer\" data-src=\"/img/bVc0Hp9\" alt=\"\" title=\"\"></span></p><p>如此一来，我们就通过entity层达到了2个目的：</p><ol><li>把前端的逻辑和服务端接口数据隔离开，无论服务端怎么变，前端后续的渲染、业务代码不需要变，我们只需要变更entitiy工厂函数；并且经过entity层处理过后，所有流入后续渲染&amp;交互逻辑的数据都是可靠的；对于部分异常数据，前端应用可以第一时间发现并报警。</li><li>通过对业务模型进行抽象，实现了模块间的组合、复用。另外，抽象出的entity对代码的维护性也有非常大的帮助，开发者可以非常直观的知道所使用的entity所包含的所有字段。</li></ol><p><strong>Usecase</strong><br>usecase这一层即是围绕entity展开的一系列crud操作，以及为了页面渲染做的一些联动(通过ui store实现)。由于当前架构的原因(没有bff层)，usecase还可能承担部分微服务串联的工作。</p><p>举个例子，商家后台订单页面在渲染前有一堆准备逻辑：</p><ol><li>根据route的query参数以及一些商家类型参数来决定默认选中哪个tab</li><li>根据是国内商家还是境外商家，调用对应的供应商接口来更新供应商下拉框<br>现在大致的实现是：<br><span class=\"img-wrap\"><img class=\"lazy\" referrerpolicy=\"no-referrer\" data-src=\"/img/bVc0Hqe\" alt=\"\" title=\"\"></span><br><span class=\"img-wrap\"><img class=\"lazy\" referrerpolicy=\"no-referrer\" data-src=\"/img/bVc0Hqf\" alt=\"\" title=\"\"></span></li></ol><p>我们能看到7-15、24-125行对this.subType进行了赋值。但由于我们无法确定20行的函数是否也对this.subType进行了赋值，所以光凭mounted函数的代码我们并不能完全确定subType的值究竟是什么，需要跳转到getAllLogisticsCarrier函数确认。这段代码在这里已经做了简化，实际的代码像getAllLogisticsCarrier这样的调用还有好几个，要想搞清楚逻辑就得把所有函数全看一遍，代码的可读性一般。同时，由于函数都封装在ui组件里，因此要想给函数覆盖单测的话也需要一些改造。<br>为了解决问题，我们将这部分逻辑都拆分到usecase层：<br><span class=\"img-wrap\"><img class=\"lazy\" referrerpolicy=\"no-referrer\" data-src=\"/img/bVc0Hqh\" alt=\"\" title=\"\"></span><br><span class=\"img-wrap\"><img class=\"lazy\" referrerpolicy=\"no-referrer\" data-src=\"/img/bVc0Hqj\" alt=\"\" title=\"\"></span><br><span class=\"img-wrap\"><img class=\"lazy\" referrerpolicy=\"no-referrer\" data-src=\"/img/bVc0Hqk\" alt=\"\" title=\"\"></span></p><p>首先，可以看到所有usecase一定是一个纯函数，不会存在副作用的问题。</p><p>其次，prepareOrderPage usecase专门为订单页定制，拆分后一眼就能看出来订单页的准备工作需要干决定选中的tab和拉取供应商列表两件事情。而另一个拆分出来的queryLogisticsCarriers则是封装了商家后台跨境、国内两种逻辑，后续无论跨境还是国内的逻辑如何变更，其影响范围被限制在了queryLogisticsCarriers函数，我们需要对其进行功能回归；而对于prepareOrderPage来说，queryLogisticsCarriers只是() =&gt; Promise&lt;{ carriers: ICarrires }&gt;的一个实现而已，其内部调用queryLogisticsCarriers的逻辑完全不受影响，不需要进行回归。</p><p>最后，而由于我们做了依赖倒置，我们可以非常容易的给usecase覆盖单测：<br><span class=\"img-wrap\"><img class=\"lazy\" referrerpolicy=\"no-referrer\" data-src=\"/img/bVc0Hqm\" alt=\"\" title=\"\"></span><br><span class=\"img-wrap\"><img class=\"lazy\" referrerpolicy=\"no-referrer\" data-src=\"/img/bVc0Hqv\" alt=\"\" title=\"\"></span></p><p>单测除了进行功能回归之外，它的描述(demo里使用了Given-When-Then的格式，由于篇幅的原因，关于单测的细节在后续的文章再进行介绍)对于了解代码的逻辑非常非常非常有帮助。由于单测和代码逻辑强行绑定的缘故，我们甚至可以将单测描述当成一份实时更新的业务文档。</p><p>除了方便写单测之外，在通过usecase拆分完成之后，ui组件真正成为了只负责“ui”和监听用户交互行为的组件，这为我们后续的React技术栈迁移奠定了基础；通过usecase我们也实现了很不错的模块化，对于使用比较多的一些entity，他的crud操作可以通过独立的usecase具备了在多个页面甚至应用间复用的能力。</p><p><strong>Adapter</strong><br>上面usecase例子中的fetchAllLogisticsCarrier就是一个adapter，这一层起到的作用是将外部系统返回的数据转化成entity，并以一种统一的数据格式返回回来。</p><p>这一层很核心的一点即是可以依赖entity的工厂函数，将接口返回的数据转化成前端自己设计的模型数据，保证流入usecase和ui层的数据都是经过处理的“干净数据”。除此之外，通常在这一层我们会用一种固定的数据格式返回数据，比如例子中的 {success: boolean, data?: any}。这样做主要是为了抹平对接多个系统带来的差异性，同时减少多人协作时的沟通成本。<br><span class=\"img-wrap\"><img class=\"lazy\" referrerpolicy=\"no-referrer\" data-src=\"/img/bVc0Hqw\" alt=\"\" title=\"\"></span></p><p>通过Adapter + entity的组合，我们基本形成了前端应用和后端服务之间的防腐层，使得前端可以在完全不清楚接口定义的情况下完成ui渲染、usecase等逻辑的开发。在服务端产出定义后，前端只需要将实际接口返回适配到自己定义的模型(通过entity)即可。这一点对前端的测试周提效非常非常非常重要，因为防腐层的存在，我们可以在测试周完成需求评审之后根据prd的内容设计出业务模型，并以此完成需求开发，在真正进入研发周后只需要和服务端对接完成adapter这一层的适配即可。</p><p>在实践过程中，我们发现在对接同一个系统的时候(对商家来说就是stark服务)各个adapter对于异常的处理几乎一模一样(上述的11-15行)，我们可以通过Proxy对其进行抽离实现复用。当然，后续我们也完全有机会根据接口定义来自动生成adapter。</p><p><strong>UI</strong><br>在经过前面的拆分之后，无论咱们的UI层用React还是Vue来写，要做的工作都很简单了：</p><ol><li>监听交互事件并调用对应的usecase来进行响应</li><li>通过usecase来获取entity数据进行渲染</li></ol><p>由于entity已经做了过滤和适配处理，所以在ui层我们可以放心大胆的用，不需要再写一堆莫名其妙的判断逻辑。另外由于entity是由前端自己定义的模型，无论开发过程中服务端接口怎么变，受影响的都只有entity工厂函数，ui层不会受到影响。</p><p>最后，在ui层我们还剩下令人头痛的技术栈迁移问题。整个团队目前使用vue的项目有10个，按迭代频率和项目规模迁移的方案可以分为两类：</p><ul><li>迭代频繁的大应用：主要包括代码行数较多、逻辑较为复杂的几个中大型应用。这些应用想要一把梭直接完成迁移成本极高，但同时每个迭代又有相当的需求。基于这种情况，对于这三个应用我们采取了微前端的方式进行迁移。每个应用分别起一个对应的React应用，对于新页面以及部分逻辑已经完全和ui解藕迁移成本不高的业务，都由React应用来承接，最后通过module federation的方式实现融合。</li><li>迭代不频繁的小应用：剩下的应用均是复杂度不高的小应用，这部分应用迭代的需求不多，以维护为主。因此我们的方案是对现有逻辑进行整洁架构重构，在ui和逻辑分层之后直接对ui层进行替换完成迁移。</li></ul><h2 id=\"item-4\">4. 后续</h2><p>通过整洁架构我们形成了统一的编码规范，在前端应用标准化的道路上迈下了坚实的一步。可以预见的是整个标准化的过程会非常漫长，我们会陆续往标准中增加新的规范使其更加完善，短期内在规划中的有：</p><ul><li>单测即文档：上面提到了usecase通过依赖倒置来配合单测落地，后续团队期望将一些业务逻辑的实现细则通过单测的描述来进行沉淀，解决业务文档实时性的问题。</li><li>完善监控体系：前端常遇到的3种异常包括 代码逻辑异常、性能瓶颈(渲染卡顿、内存不足等)、数据导致异常。对于数据异常，我们可以在entity层映射的过程中加入对异常数据的埋点上报来填补目前监控的空白。（代码逻辑异常通过sentry已经监控，性能监控对于中后台应用不需要）</li></ul><p>后续在标准逐渐稳定之后，我们也期望基于稳定的规范进行一些工程化的实践(比如根据mooncake文档自动生成adapter层、基于usecase实现功能开关等)，敬请期待。</p><p><strong>参考链接：</strong><br>The Clean Architecture：<a href=\"https://link.segmentfault.com/?enc=bZsgKcf%2FyS4sRRVHdZByyg%3D%3D.0WtuubQkanLLBznlGCxQQCw%2BobIGt%2FdKzRMi1bThGkP7aHl77B6v3FXVgPML4rKPnYvBgCes5YBccoPuS%2FX0oe%2F0hLW1aCsxHbSoL4SV0rQ%3D\" rel=\"nofollow\" target=\"_blank\">https://blog.cleancoder.com/u...</a><br>Module Federation：<a href=\"https://link.segmentfault.com/?enc=NT%2F9G8Gv4sTXGrWZdBOnqA%3D%3D.xxMBQUpCeJ9zZaQWHLJrDweYOgk45tXi8mvWA7JtyLm5KyViJ54Ir9uaOEyKKz2dj9xoWSXPhk2I5FaAsq6fyQ%3D%3D\" rel=\"nofollow\" target=\"_blank\">https://webpack.js.org/concep...</a><br>Anti-corruption Layer pattern：<a href=\"https://link.segmentfault.com/?enc=iXLHj3Bu9YltkhZxdJyZIg%3D%3D.WMlymUiiceHNBV%2BiOj3sk7y88Su9OWHLE2WI5mHqMk4VeMOwoIPrDbioad4J6jyNDdpS6uHi3knO9Dx4qn55wxD9QRDJmE73HhdogtoDbLSrQkU7DPY%2BJ0vMSFydKrPG\" rel=\"nofollow\" target=\"_blank\">https://docs.microsoft.com/en...</a></p><p>*文/陈子煜<br>@得物技术公众号</p></article>",
  "hit_num": 0,
  "like_num": 0,
  "author": {
    "_id": "62c519b592cd299ebb39c31b"
  },
  "column": {
    "_id": "62c51ba0f6d569ab7080a8c4"
  }
}]
